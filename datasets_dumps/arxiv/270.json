{"entry_id": "http://arxiv.org/abs/2303.06978v1", "published": "20230313102550", "title": "A Newton-like Method based on Model Reduction Techniques for Implicit Numerical Methods", "authors": ["Tobias K. S. Ritschel"], "primary_category": "math.NA", "categories": ["math.NA", "cs.NA", "cs.SY", "eess.SY"], "text": "\n\t\n\tSelf-supervised based general laboratory progress pretrained model for cardiovascular event detection\n    Li-Chin Chen^1, \n        Kuo-Hsuan Hung^1,\n        Yi-Ju Tseng^2, \u00a0Member,\u00a0IEEE,\n        Hsin-Yao Wang^3, \n        Tse-Min Lu^4,5,6,\n\t  Wei-Chieh Huang^7,4,6,\n        Yu Tsao^1, \u00a0Senior Member,\u00a0IEEE\n       \n\n    March 30, 2023\n===================================================================================================================================================================================================================\n\nempty\nempty\n\n\n\t\n\t\n\tIn this paper, we present a Newton-like method based on model reduction techniques, which can be used in implicit numerical methods for approximating the solution to ordinary differential equations. In each iteration, the Newton-like method solves a reduced order linear system in order to compute the Newton step. This reduced system is derived using a projection matrix, obtained using proper orthogonal decomposition, which is updated in each time step of the numerical method. We demonstrate that the method can be used together with Euler's implicit method to simulate CO_2 injection into an oil reservoir, and we compare with using Newton's method. The Newton-like method achieves a speedup of between 39% and 84% for systems with between 4,800 and 52,800 state variables.\n\n \n\n\t\n\t\n\n\u00a7 INTRODUCTION\n\nNewton's method iteratively approximates the solution to a set of nonlinear algebraic equations using successive linearization. It is ubiquitous in numerical methods for simulation, state and parameter estimation, and optimal control of ordinary, partial, differential-algebraic, and stochastic systems of differential equations. In particular, implicit numerical methods are suitable for stiff systems, and they require the solution of one or more sets of nonlinear equations in each time step.\n\nEach iteration of Newton's method requires the solution of a linear system of equations. For large-scale systems with many state variables, this is computationally expensive.\n\nTherefore, many variations of Newton-type methods, where the Newton step is approximated, have been proposed\u00a0<cit.>.\n\nTwo widely used variations are 1)\u00a0the simplified Newton method where the Jacobian matrix is not reevaluated in each iteration (such that its factorization can be reused) and 2)\u00a0inexact Newton methods\u00a0<cit.> where the linear system in each Newton iteration is solved approximately using an iterative method\u00a0<cit.>.\n\nLarge-scale systems often arise as the result of spatial discretization of partial differential equations (PDEs)\u00a0<cit.> or as a network of interacting subsystems\u00a0<cit.>. In the former case, it is common that the resulting set of ordinary differential equations (ODEs) is stiff due to fast local changes (compared to the simulation horizon). The stiffness of network systems depends on the dynamics of the individual subsystems and their interactions.\n\nModel order reduction, or simply model reduction, methods\u00a0<cit.> are relevant to any type of large-scale system. They identify a lower order dynamical system whose state variables can be used to approximate the state of the original dynamical system.\n\nFor linear systems, there exist several model reduction methods, and the theory is well-developed.\n\nHowever, the reduction of general nonlinear systems is an active field of research and remains challenging.\n\nIn this work, we propose a Newton-like method where a reduced order linear system is solved in each iteration. We use a projection matrix to compute the system matrices in this reduced system and to compute the approximate Newton step from the solution to the reduced system. We use proper orthogonal decomposition (POD)\u00a0<cit.> to compute the projection matrix. The method is relevant to implicit numerical methods, and we demonstrate its utility using Euler's implicit method.\n\nA similar method was proposed by Nigro et al.\u00a0<cit.>. However, we compute a projection matrix in each time step whereas they only compute it a few times during the simulation. Instead, they update the projection matrix adaptively during both the time steps and Newton iterations. Finally, if convergence is too slow, we solve the original (full order) linear system for the Newton step. The advantage of the method proposed in this work is its simplicity.\n\nWe test the Newton-like method on numerical simulation of CO_2 injection into an oil reservoir. This process is modeled using four coupled PDEs which are discretized using a finite volume method.\n\nThe remainder of this paper is structured as follows. In Section\u00a0<ref>, we discuss numerical simulation of nonlinear systems using Euler's implicit method and Newton's method, and we discuss model reduction and POD in Section\u00a0<ref>. In Section\u00a0<ref>, we present the Newton-like method proposed in this paper, and we discuss details of the implementation in Section\u00a0<ref>. Finally, we present the numerical examples in Section\u00a0<ref>, and we present conclusions in Section\u00a0<ref>.\n \n\t\n\n\u00a7 NUMERICAL SIMULATION\n\nWe consider nonlinear systems in the form\n\n\n    \u1e8b(t)    = f(x(t), u(t), d(t), p),\n\n\nwhere x are the states, u are manipulated inputs, d are disturbance variables, p are parameters, and f is the right-hand side function. We include the dependency of f on u, d, and p for completeness, and we assume a zero-order hold parametrization of u and d:\n\n\n\t\n    u(t)    = u_k,     t \u2208 [t_k, t_k+1[, \n    \n    \t\td(t)    = d_k,     t \u2208 [t_k, t_k+1[.\n\n\n\n\n\n \u00a7.\u00a7 Discretization\n\nWe discretize\u00a0(<ref>) using Euler's implicit method:\n\n\n    x_k+1 - x_k    = f(x_k+1, u_k, d_k, p) \u0394 t_k.\n\n\nHere, x_k \u2248 x(t_k) and \u0394 t_k is the k'th time step size.\n\nAs the right-hand side function, f, is nonlinear in the states,\u00a0(<ref>) is a set of nonlinear algebraic equations which must be solved for x_k+1 given x_k, u_k, d_k, p, and \u0394 t_k.\n\n\n\n \u00a7.\u00a7 Newton's method\n\nWe write the nonlinear algebraic equations\u00a0(<ref>) in residual form:\n\n\n    R_k(x_k+1)\n    \t   = R_k(x_k+1; x_k, u_k, d_k, p) \n       = x_k+1 - x_k - f(x_k+1, u_k, d_k, p) \u0394 t_k = 0.\n\n\nIn Newton's method, an approximation of the solution to\u00a0(<ref>) is iteratively improved using the update formula\n\n\n    x_k+1^(\u2113+1)   = x_k+1^(\u2113) + \u0394 x_k+1^(\u2113),\n\n\nwhere x_k+1^(\u2113) is the \u2113'th approximation. If\n\n\n    R_k(x_k+1^(\u2113)) < \u03c4\n\n\nfor some tolerance, \u03c4, the iterations are terminated.\n\nThe Newton step \u0394 x_k+1^(\u2113) is the solution to the linear system of equations obtained by linearizing\u00a0(<ref>) around x_k+1^(\u2113):\n\n\n    R_k(x_k+1^(\u2113)) + R_kx_k+1(x_k+1^(\u2113)) \u0394 x_k+1^(\u2113)   = 0.\n\n\nThe Jacobian matrix is\n\n\n    R_kx_k+1(x_k+1)    = I - fx(x_k+1, u_k, d_k, p) \u0394 t_k,\n\n\nwhere I is the identity matrix and fx is the Jacobian of f.\n\nWe rearrange terms in order to write the linear system in the form\n\n\n    A_k^(\u2113)\u0394 x_k+1^(\u2113)   = b_k^(\u2113),\n\n\nwhere the system matrix and the right-hand side are\n\n\n\t\n    A_k^(\u2113)   = R_kx_k+1(x_k+1^(\u2113)), \n    \n    \t\tb_k^(\u2113)   = -R_k(x_k+1^(\u2113)).\n\n\n \n\t\n\n\u00a7 MODEL ORDER REDUCTION\n\nIn this section, we discuss the challenges of reducing general nonlinear models, and we present the POD method used in the Newton-like method.\n\nThe purpose of model reduction is to approximate the states, x, by a smaller number of reduced states, x\u0302, e.g., using a linear relation:\n\n\n    x(t)    \u2248 V x\u0302(t).\n\n\nHere, x\u2208\u211d^n_x, V\u2208\u211d^n_x \u00d7 n_r, and x\u0302\u2208\u211d^n_r where the number of reduced states, n_r is significantly smaller than the number of states, n_x. Direct substitution of\u00a0(<ref>) into the original system\u00a0(<ref>) gives\n\n\n    V \u1e8b\u0302\u0307(t)    = f(V x\u0302(t), u(t), d(t), p).\n\n\nNext, the differential equations are multiplied by the transpose of W \u2208\u211d^n_x\u00d7 n_r from the left:\n\n\n    W^T V \u1e8b\u0302\u0307(t)    = W^T f(V x\u0302(t), u(t), d(t), p).\n\n\n\n\nAssuming that W^T V is invertible, the reduced system is\n\n\n    \u1e8b\u0302\u0307(t)    = f\u0302(x\u0302(t), u(t), d(t), p),\n\n\nwhere the reduced right-hand side function, f\u0302, is\n\n\n    f\u0302(x\u0302(t),     u(t), d(t), p) \n       = (W^T V)^-1 W^T f(V x\u0302(t), u(t), d(t), p).\n\n\nFor general nonlinear systems, evaluating the reduced right-hand side function in\u00a0(<ref>) is more expensive than evaluating the right-hand side function in the original system (for linear systems, the reduced system matrices can be computed prior to simulation or analysis). Consequently, using explicit numerical methods for the reduced system\u00a0(<ref>) is, in most cases, not faster than for the original system. However, for implicit methods, the most computationally expensive step is to solve the linear system of equations in each iteration of the Newton step. Therefore, it is possible to achieve significant speedup by simulating the reduced system. However, it still remains challenging to accurately approximate general nonlinear systems using a reduced system.\n\n\n\tThe matrix W^T V is often the identity matrix or a diagonal matrix (e.g., for clustering approaches).\n\n\n\n\n\n\n\n\n\n\n\n\n \u00a7.\u00a7 Proper orthogonal decomposition\n\nIn the Newton-like method presented in Section\u00a0<ref>, we use POD\u00a0<cit.> to compute the projection matrices V and W based on a matrix of snapshots, X. That is, each column of X contains the state vector x_k = x(t_k) for some value of k. The singular value decomposition of X is\n\n\n    X = U \u03a3 R,\n\n\nwhere U and R are matrices of left and right singular vectors, respectively, and \u03a3 is a diagonal matrix with the singular values on the diagonal in descending order. The projection matrices V = W consist of the columns of U corresponding to singular values larger than \u03f5\u03a3_11. Based on numerical experiments, we choose \u03f5 = 50 \u03f5_m where \u03f5_m = 2^-52 is the machine precision\n \n\t\n\n\u00a7 NUMERICAL SIMULATION\nUSING THE NEWTON-LIKE METHOD\n\nIn the Newton-like method, we replace the Newton update\u00a0(<ref>) by\n\n\n\n    x_k+1^(\u2113+1)   = x_k+1^(\u2113) + V_k \u0394x\u0302_k+1^(\u2113),\n\n\nwhere V_k is the projection matrix computed using POD, as described in Section\u00a0<ref>, and \u0394x\u0302_k+1^(\u2113) is the reduced Newton step obtained by solving\n\n\n    \u00c2_k^(\u2113)\u0394x\u0302_k+1^(\u2113)   = b\u0302_k^(\u2113).\n\n\nWe derive the system matrix and the right-hand side following the same steps as in Section\u00a0<ref>. First, we approximate the Newton step by\n\n\n    \u0394 x_k+1^(\u2113)   \u2248 V_k \u0394x\u0302_k+1^(\u2113).\n\n\nNext, as the linear system would otherwise be overdetermined, we multiply the linear system of equations by W_k^T from the left. The resulting set of linear equations is\n\n\n\n\n\n\n    W_k^T A_k^(\u2113) V_k \u0394x\u0302_k+1^(\u2113)   = W_k^T b_k^(\u2113).\n\n\nConsequently, the reduced system matrix and right-hand side in\u00a0(<ref>) are\n\n\n\t\n    \u00c2_k^(\u2113)   = W_k^T A_k^(\u2113) V_k, \n    b\u0302_k^(\u2113)   = W_k^T b_k^(\u2113).\n\n\n\nThe dimension of \u00c2_k^(\u2113) is n_r\u00d7 n_r which is significantly smaller than the dimension of A_k^(\u2113) which is n_x\u00d7 n_x. Therefore, the solution of the linear system\u00a0(<ref>) is much less computationally expensive.\n\n\n\n \u00a7.\u00a7 Algorithms\n\nWe implement Euler's implicit method as shown in Algorithm\u00a0<ref>. We use Newton's method in the first N_b time steps. For each subsequent time step, we create a snapshot matrix, X_k, consisting of up to N_h of the previous time steps. Based on the snapshot matrix, we compute the projection matrices V_k and W_k as described in Section\u00a0<ref>. Finally, we use the projection matrices in the Newton-like method to solve the residual equations\u00a0(<ref>) for the next time step, x_k+1. Based on numerical experiments, we choose N_b = ln(n_x) and N_h = \u221a(n_x).\n\nWe implement the Newton-like method as shown in Algorithm\u00a0<ref>. The initial guess is x_k and the result is x_k+1. In each iteration, the reduced system\u00a0(<ref>) is solved unless the previous reduced Newton step was too small. In line\u00a0<ref>, we ensure that the full order system is not solved twice in a row. The iterations continue until the norm of the residual equations is below the tolerance \u03c4. For convenience, we also use \u03c4 in line\u00a0<ref> to determine when to solve the full order system.\n\n\n\n\n\n\t\n\n\u00a7 IMPLEMENTATION DETAILS\n\nWe implement Algorithm\u00a0<ref> and\u00a0<ref> in Matlab\u00a0<cit.>. The Jacobian matrices of f and R_k are represented as sparse. All other quantities are represented as dense. We use Matlab's  to compute the left singular vectors corresponding to the N_h largest singular values, and we use Matlab's  (i.e., the backslash operator) to solve the sparse linear systems.\n\nFurthermore, we implement the evaluation of the right-hand side function and its Jacobian using the C++ library DUNE\u00a0<cit.> and the thermodynamic library, ThermoLib\u00a0<cit.>, and we use a Matlab MEX interface\u00a0<cit.> to call the implementation from Matlab. The MEX interface allocates memory and evaluates the Jacobian of f as sparse before returning it to Matlab, i.e., we do not use Matlab's  to convert it from a dense matrix.\n\nFinally, we carry out the computations using Windows Subsystem for Linux 2 (WSL2) on a Windows 10 laptop with 12\u00a0MB shared level 3 cache, 1,280\u00a0KB level 2 cache for each core, and 48\u00a0KB and 32\u00a0KB level 1 instruction and data cache for each core, respectively. Furthermore, each core contains two 11'th generation Intel Core i7 3\u00a0GHz processors.\n \n\t\n\n\u00a7 NUMERICAL EXAMPLE\n\nIn this section, we present a numerical example of CO_2 injection into an oil reservoir. We provide a brief description of the model in Appendix\u00a0<ref>, and we use the porosity and permeability fields of the top layer of model 2 from\u00a0<cit.>. They are shown in Fig.\u00a0<ref> and\u00a0<ref>. Clearly, they are very heterogeneous.\n\nInitially, the reservoir contains water and oil consisting of methane, n-decane and CO_2, and the water and oil phases do not mix. Furthermore, we assume that there is no gas phase. We inject liquid CO_2, which also contains 1\u2030 methane and 1\u2030 n-decane (mole fractions). The CO_2 is injected through two wells located at opposite corners. Each well injects 0.11\u00a0m^3 per day.\n\nFig.\u00a0<ref> shows an example of a simulation of 1,200 grid cells. The reservoir consists of the left-most 20 columns of cells in the fields shown in Fig.\u00a0<ref> and\u00a0<ref>.\n\nThe top row of figures show the oil saturation (ratio between oil and water volume) over time and the bottom row shows the pressure. As CO_2 is injected, it displaces water. Therefore, the oil saturation decreases in the middle area. In this simulation, the oil and water cannot leave the reservoir. Consequently, the pressure increases significantly over. Furthermore, the pressure is almost completely uniform in this simulation.\n\nFig.\u00a0<ref> shows the computation time of simulating 8\u00a0days of CO_2 injection using Euler's implicit method and 1)\u00a0Newton's method and 2)\u00a0the Newton-like method described in Section\u00a0<ref>. We use 40\u00a0time steps of 0.1\u00a0day and 20\u00a0time steps of 0.2\u00a0day, and we repeat the simulation for different numbers of grid cells. The number of grid cells changes the simulation scenario because we include a larger part of the reservoir, i.e., we do not refine the discretization. The computation time increases linearly with the number of grid cells, and the increase is lower for the Newton-type method. Fig.\u00a0<ref> shows the speedup which is between 39% (for the lowest number of grid cells) and 84%. The mean speedup is 66% and the standard deviation is 12%.\n\n\n\n\n\n\n\n\n\n\n \n\t\n\n\u00a7 CONCLUSIONS\n\nIn this paper, we propose a Newton-like method based on model reduction methods (specifically, POD). The method can improve the computational efficiency of implicit numerical methods for approximating the solution to general nonlinear ODEs. Such systems are difficult to reduce directly using existing model reduction methods.\n\nThe method approximates the linear system solved in each Newton iteration by a lower order system which is significantly less computationally expensive to solve. The system matrix and right-hand side of the reduced linear system are computed based on a projection matrix, which is updated in each time step (except for the first few time steps).\n\nWe demonstrate the utility of the method for numerical simulation of CO_2 injection into an oil reservoir. We model\nthis process by four coupled PDEs, and we discretize them using a finite volume method.\n\nCompared to Newton's method, the Newton-like method achieves a speedup of between 39% and 84% for 1,200 to 13,200 grid cells, which correspond to 4,800 and 52,800 state variables.\n \n\n\t\n\t\n\n\t\n\t\n\n\u00a7 COMPOSITIONAL FLOW IN POROUS MEDIA\n\nIn this appendix, we modify an isothermal and compositional model presented in previous work\u00a0<cit.>. Specifically, we assume that there is no gas phase and that the rock and the water are incompressible. The purpose of these simplifications is to obtain a model which (after spatial discretization) consists of a set of ODEs.\n\nThe concentrations of water, C_w, and the k'th component in the oil phase, C_k, are described by the PDEs\n\n\n\t\n    \u2202_t C_w    = -\u2207\u00b7\ud835\udc0d^w, \n    \u2202_t C_k    = -\u2207\u00b7\ud835\udc0d_k + Q_k,\n\n\n\nwhere \ud835\udc0d^w and \ud835\udc0d_k are the molar fluxes of the water component and of the k'th component, and Q_k is a source term representing the injection of component k.\n\nThe molar flux of the k'th component is the product of the mole fraction, x_k, and the molar flux of the entire oil phase:\n\n\n    \ud835\udc0d_k    = x_k \ud835\udc0d^o.\n\n\nThe molar fluxes of both the oil and the water phase are the products of the molar density, \u03c1^\u03b1, and the volumetric flux, i.e.,\n\n\n    \ud835\udc0d^\u03b1   = \u03c1^\u03b1\ud835\udc2e^\u03b1,    \u03b1   \u2208{w, o},\n\n\nand the volumetric flux is given by a generalization of Darcy's law to multiphase fluids:\n\n\n    \ud835\udc2e^\u03b1   = -k_r^\u03b1/\u03bc^\u03b1\ud835\udc0a (\u2207 P - \u03c1\u0305^\u03b1 g \u2207 z),    \u03b1   \u2208{w, o}.\n\n\nWe use Corey's model\u00a0<cit.> of the relative permeabilities, k_r^\u03b1, and we use the model by\u00a0Lohrenz et al.\u00a0<cit.> to describe the viscosity of the oil phase, \u03bc^o. The viscosity of the water phase is \u03bc^w = 0.3\u00a0cP. In this work, we assume the permeability tensor, \ud835\udc0a, to be a multiple of the identity matrix, i.e., the permeability is the same in all directions. Furthermore, P is pressure, \u03c1\u0305^\u03b1 is the mass density, g is the gravity acceleration constant, and z is depth.\n\nAs for the flux of component k, the source term is the product of the mole fraction and the source term for the entire oil phase:\n\n\n    Q_k    = x_k Q^o.\n\n\nWe specify both x_k and Q^o.\n\n\n\n \u00a7.\u00a7 Volume balance and cubic equation of state\n\nWhen both oil and gas is present, the phase equilibrium problem for each grid cell is an equality-constrained minimization problem. The objective function is the combined Helmholtz' energy of the rock, water, oil and gas phase and the constraints specify the amounts of moles of each component (in both phases) and the combined volume of all four phases. However, when there is no gas phase, the phase equilibrium problem simplifies to finding a pressure which satisfies the volume balance:\n\n\n    V^w + V^o + V^r    = V.\n\n\nThe volumes of the rock, V^r, the water, V^w, and the entire grid cell, V, are independent of the pressure. Consequently, given the amount of moles in the water phase, n_w, the oil volume, V^o, can be isolated in\u00a0(<ref>).\n\nGiven the oil volume V^o = V - V^w - V^r, we can compute the corresponding molar volume v^o = V^o/N^o, where N^o is the total amount of moles in the oil phase, and evaluate the pressure using the cubic equation of state\n\n\n    P    = RT/v^o - b_m - a_m/(v^o + \u03f5 b_m)(v^o + \u03c3 b_m).\n\n\nHere, R is the gas constant, T is temperature (60^\u2218C in this work), a_m = a_m(T, n^o) and b_m(n^o) are mixing parameters (n^o is a vector of moles of each component in the oil phase), and \u03f5 and \u03c3 are parameters which depend on the specific cubic equation of state used. We use the Peng-Robinson equation of state.\n\n\n\tAfter spatial discretization, the flow models described previously\u00a0<cit.> consist of differential-algebraic equations (DAEs) in the form\n\t\n\t\n\t\t\n    \u1e8b(t)    = F(y(t), u(t), d(t), p), \n    \n    \t\t\t0    = G(x(t), y(t), z(t), p),\n\n\t\n\t\n\twhereas the model described above is in the form\n\t\n\t\n\t\t\n    \u1e8b(t)    = F(y(t), u(t), d(t), p), \n    \n    \t\t\ty(t)    = G\u0303(x(t), p).\n\n\t\n\t\n\tHere, y and z are algebraic variables, F is the right-hand side function, and G and G\u0303 are algebraic functions. As the algebraic equations\u00a0(<ref>) are explicit in the algebraic variables, the above model is also in the form\u00a0(<ref>), i.e.,\n\t\n\t\n    \u1e8b(t)\n    \t\t   = f(x(t), u(t), d(t), p) \n       = F(G\u0303(x(t), p), u(t), d(t), p).\n\n\n\n\n\n \u00a7.\u00a7 Discretization\n\nThe PDEs\u00a0(<ref>) are in the form\n\n\n    \u2202_t C    = -\u2207\u00b7\ud835\udc0d + Q,\n\n\nand we discretize them using a finite volume method. First, we integrate over each grid cell, \u03a9_i:\n\n\n    \u2202_t \u222b_\u03a9_i C  V    = -\u222b_\u03a9_i\u2207\u00b7\ud835\udc0d V + \u222b_\u03a9_i Q  V.\n\n\nThe left-hand side can be evaluated exactly, i.e.,\n\n\n    \u222b_\u03a9_i C  V    = n_i,\n\n\nwhere n_i is the total amount of moles in the i'th grid cell. Next, we use Gauss' divergence theorem, write the surface integral as the sum of the integrals over each face of the grid cell, \u03b3_ij, and approximate the integrals:\n\n\n    \u222b_\u03a9_i\u2207\u00b7\ud835\udc0d V\n    \t   = \u222b_\u2202\u03a9_i\ud835\udc0d\u00b7\ud835\udc27 A \n       = \u2211_j\u2208\ud835\udca9^(i)\u222b_\u03b3_ij\ud835\udc0d\u00b7\ud835\udc27 A \n       \u2248\u2211_j\u2208\ud835\udca9^(i) (A \ud835\udc0d\u00b7\ud835\udc27)_ij.\n\n\nThe set \ud835\udca9^(i) contains the indices of the grid cells that are adjacent to the i'th grid cell, A_ij is the area of face \u03b3_ij (the face shared by \u03a9_i and \u03a9_j), and \ud835\udc27 is the outward normal vector on the boundary of the grid cell, \u2202\u03a9_i.\n\nSimilarly, we approximate the integral of the source term as\n\n\n    \u222b_\u03a9_i Q  V    \u2248 (Q V)_i.\n\n\nThe resulting approximation in\u00a0(<ref>) contains the flux evaluated at the center of each face of the grid cell. We use a two-point flux approximation\u00a0<cit.> to approximate this flux. The result is\n\n\n\t\n    (A \ud835\udc0d^w \u00b7\ud835\udc27)_ij   \u2248 -(\u0393\u0124^w \u0394\u03a6^w)_ij, \n    \n    \t\t(A \ud835\udc0d_k \u00b7\ud835\udc27)_ij   \u2248 -(x_k \u0393\u0124^o \u0394\u03a6^o)_ij,\n\n\n\nwhere \u0393_ij is the geometric part of the transmissibilities, \u0124^\u03b1 is the fluid part of the transmissibilities, and \u0394\u03a6^\u03b1 is difference in potential. The geometric part of the transmissibilities is given by\n\n\n\t\n    \u0393_ij   = A_ij(\u0393\u0302_ij^-1 + \u0393\u0302_ji^-1)^-1, \n    \u0393\u0302_ij   = (\ud835\udc0a_i c_ij - c_i/|c_ij - c_i|^2) \u00b7\ud835\udc27,\n\n\n\nwhere c_ij is the center of \u03b3_ij and c_i is the center of \u03a9_i. Furthermore, the difference in potential is\n\n\n    \u0394\u03a6_ij^\u03b1   = (\u0394 P - \u03c1\u0305^\u03b1 g \u0394 z)_ij,\n\n\nwhere we approximate the mass density at the face center using an average, i.e.,\n\n\n    \u03c1\u0305_ij^\u03b1   = (\u03c1\u0305_i^\u03b1 + \u03c1\u0305_j^\u03b1)/2,\n\n\nand the differences in pressure and depth are\n\n\n\t\n    \u0394 P_ij   = P_j - P_i,    \u0394 z_ij   = z_j - z_i.\n\n\n\nFinally, the fluid part of the transmissibilities is upwinded based on the difference in potential:\n\n\n    \u0124_ij^\u03b1   =\n    \t\n    \t\t(\u03c1^\u03b1 k_r^\u03b1/\u03bc^\u03b1)_i    if\u00a0\u0394\u03a6_ij^\u03b1 <    0, \n    \n    \t\t(\u03c1^\u03b1 k_r^\u03b1/\u03bc^\u03b1)_j    if\u00a0\u0394\u03a6_ij^\u03b1\u2265 0.\n\n\n\n\t\n\t\n\n"}