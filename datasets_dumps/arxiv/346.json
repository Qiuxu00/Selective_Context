{"entry_id": "http://arxiv.org/abs/2303.06846v1", "published": "20230313042424", "title": "Improved quantum error correction with randomized compiling", "authors": ["Aditya Jain", "Pavithran Iyer", "Stephen D. Bartlett", "Joseph Emerson"], "primary_category": "quant-ph", "categories": ["quant-ph"], "text": "\n\n\n\n\n\nDepartment of Applied Mathematics, University of Waterloo, Waterloo, Ontario N2L 3G1, Canada.\n\n\nInstitute for quantum computing, University of Waterloo, Waterloo, Ontario N2L 3G1, Canada.\n\n\nKeysight Technologies Canada Inc., Mississauga, Ontario L5N 2M2, Canada.\n\n\n\n\nDepartment of Applied Mathematics, University of Waterloo, Waterloo, Ontario N2L 3G1, Canada.\n\n\n\nInstitute for quantum computing, University of Waterloo, Waterloo, Ontario N2L 3G1, Canada.\n\n\n\nXanadu, Toronto, Ontario M5G 2C8, Canada. \n\n\n\n\n\n\nCentre for Engineered Quantum Systems, School of Physics, University of Sydney, Sydney, New South Wales 2006, Australia.\n\n\n\n\nDepartment of Applied Mathematics, University of Waterloo, Waterloo, Ontario N2L 3G1, Canada.\n\n\nInstitute for quantum computing, University of Waterloo, Waterloo, Ontario N2L 3G1, Canada.\n\n\nKeysight Technologies Canada Inc., Mississauga, Ontario L5N 2M2, Canada.\n\n\n\nCurrent hardware for quantum computing suffers from high levels of noise, and so to achieve practical fault-tolerant quantum computing will require powerful and efficient methods to correct for errors in quantum circuits. Here, we explore the role and effectiveness of using noise tailoring techniques to improve the performance of error correcting codes. Noise tailoring methods such as randomized compiling (RC) convert complex coherent noise processes to effective stochastic noise. While it is known that this can be leveraged to design efficient diagnostic tools, we explore its impact on the performance of error correcting codes. Of particular interest is the important class of coherent errors, arising from control errors, where RC has the maximum effect \u2013 converting these into purely stochastic errors. For these errors, we show here that RC delivers an improvement in performance of the concatenated Steane code by several orders of magnitude. We also show that below a threshold rotation angle, the gains in logical fidelity can be arbitrarily magnified by increasing the size of the codes. These results suggest that using randomized compiling can lead to a significant reduction in the resource overhead required to achieve fault tolerance.\n\n\nImproved quantum error correction with randomized compiling\n    Joseph Emerson\n    Received: date / Accepted: date\n===========================================================\n\n\n\n\n\n\n\u00a7 INTRODUCTION\n\n\nNoise is pervasive in present-day quantum computation. The theory of fault tolerance was developed to guarantee reliable computations in the presence of noise. However, fault tolerant constructions demand a large overhead in terms of additional resources required to encode a logical computation in a way that is resilient to errors. Achieving the target logical error rates as required by various applications with the limited amount of resources in terms of the number of physical qubits is a challenging task. Along with designing better error correcting codes, decoders and high quality hardware components of a quantum computer, there are other ways of reducing logical error rates. Active noise tailoring by randomized compiling (RC) <cit.> is a potential candidate for two key reasons. First, RC significantly simplifies the form of the noise on the encoded quantum information. Second, RC can be used to transform an unknown error model into one that is adapted to the error correction capabilities of a particular code.\n\nRandomized compiling tools were leveraged to accurately predict the performance of quantum error correction schemes in Ref.\u00a0<cit.>. Although simplifying the form of the noise makes the performance more predictable, it was observed that RC can sometimes degrade the performance of an error correcting code. We can understand this effect by using the \u03c7-representation <cit.> of a physical noise process. In this representation, the action of noise on a quantum state \u03c1 is given by: (\u03c1) = \u2211_i,j\u03c7_i,jP_i\u03c1 P_j where P_i denote Pauli matrices in the n-qubit Pauli group _n without phases, i.e., P_i \u2208n/{\u00b1 1, \u00b1 i}. Noise tailoring methods such as RC can transform the elements of the \u03c7-matrix, for example by removing off-diagonal elements \u03c7_i,j\u2200 i \u2260 j. This mathematical transformation is commonly referred to as twirling <cit.>.\nIf one were to remove the contribution of \u03c7_i,j corresponding to Pauli errors that are correctable by the decoder, this could have a negative impact of the code's performance. In general, noise tailoring methods are oblivious to the details of what error terms are relevant for quantum error correction.\n\nThe impact of twirling the noise on the performance of error correction schemes has been explored in the literature under various settings. The performance of surface codes under coherent and incoherent error models have been compared in Ref.\u00a0<cit.>, and using numerical studies it was noted that while the threshold is similar in both cases, the subthreshold performance of the twirled channel is significantly better than the original coherent error model. In another setting, analytical calculations of the logical error rate of repetition codes under rotation errors reveal that coherent errors can accumulate faster, leading to worse logical error rates than their corresponding Pauli approximations\u00a0<cit.>. The necessity of active coherence-suppression methods for codes with large distances was also noted, but their impact on the code\u2019s performance was not explored. For the Toric code under coherent error models, a laborious analysis has shown that the effective logical channel approaches an incoherent channel provided the noise decreases with increasing code size\u00a0<cit.>. However, in the scenario where the error rate remains constant independent of the code size, there are several challenges to arriving at a similar conclusion. In Ref.\u00a0<cit.>, the poor predictability of the logical error rate and the code\u2019s pseudo threshold under coherent errors provided by their twirled counterparts was identified, reinforcing the need for active noise tailoring. The impact of twirling the noise for complex error models, such as combinations of stochastic errors and rotations around an arbitrary non-Pauli axis, is unknown. The scaling of the potential gains from twirling with increased code-concatenation levels remains unexplored.\n\nIn this paper, we analyze the impact of RC on the performance of quantum error correction. In particular, we show that RC improves the performance of a concatenated Steane code under a coherent noise model (specifically, a tensor product of arbitrary identical unitary errors). This positive result demonstrates that RC tools can play a key role in achieving fault tolerance. We present a detailed study of the performance gains with respect to changes in the axis of rotation and the number of levels of concatenation. We identify a special axis of rotation for a given concatenation level where maximum gains from RC are achieved. We note that this axis can be different from the axes of rotation for which the best pseudo-threshold for the code is achieved. It has been observed, in previous studies, that randomized compiling can also degrade logical performance\u00a0<cit.>. Our study shows that a wide class of physically motivated error models do not exhibit such behaviour. However, we identify some complex noise models where such degradation can occur and provide numerical results for the same.\n\nThe paper is structured as follows. In section <ref>, we introduce the necessary background material including noise processes, randomized compiling and quantum error correction. Section <ref> discusses the methods used to study the impact of randomized compiling on the logical performance. In section <ref>, we present analytical studies for gains offered by randomized compiling using realistic error models. Finally, in section <ref> we provide concluding remarks and describe some interesting open problems. \n\n\n\n\u00a7 BACKGROUND\n\n\nIn this section, we review the mathematical description of noise processes in quantum circuits as well as the formalism of stabilizer quantum error correction. \n\n\n\n \u00a7.\u00a7 Noise in quantum circuits\n\n\nThe interaction of a quantum system with its environment manifests as errors on the stored quantum information. While the system and its environment together undergo unitary time evolution, the system's reduced dynamics is often a non-unitary map. Markovian noise processes are described by completely positive trace preserving (CPTP) maps : \u03c1\u21a6(\u03c1). One of the common ways to represent a CPTP map is using the \u03c7-matrix: \u03c7(), a 4\u00d7 4 matrix where: (\u03c1) = \u2211_i,j\u03c7_i,j P_i\u03c1 P_j, where P_i, P_j are Pauli matrices.\n\nA special subclass of noise processes that are widely analyzed in developing fault-tolerant protocols is Pauli channels. They correspond to the probabilistic action of Pauli matrices on the input state, i.e., (\u03c1) = \u2211_i,j\u03c7_i,i P_i\u03c1 P_i, where \u03c7_i,i can be interpreted as the probability of the Pauli error P_i.\n\nWhile it is easy to study quantum error correction on Pauli error models, unfortunately realistic noise is often poorly approximated by Pauli error models. This causes a severe disparity between error models that can be accurately analyzed in theory and those that occur in experiments. Noise tailoring, achieved through Randomized compiling <cit.>, is a promising tool that helps resolve this disparity. With RC, the average logical performance of a QEC scheme over several compilations with random Pauli gates can be well approximated by the performance of the QEC scheme under an effective Pauli error model. The effective Pauli error model is nothing but the Pauli twirl of the underlying CPTP noise process , denoted by () defined as\n\n    ()(\u03c1) = \u2211_P \u2208_n P (P \u03c1 P) P  .\n\nWe will use the notation ^T to denote the Pauli Twirl of the CPTP map : ().\n\n\n\n \u00a7.\u00a7 Quantum Error Correction\n\n\nAn [[n,k]] stabilizer code  is a 2^k dimensional space defined as: = { |\u03c8\u27e9 :  S_i|\u03c8\u27e9 = |\u03c8\u27e9 ,  1 \u2264 i\u2264 n-k}, where S_i are stabilizer generators. See Ref.\u00a0<cit.> for an introduction to stabilizer codes and fault tolerance. Concatenated codes are a family of codes where we encode the physical qubits at level \u2113 using the code at level \u2113-1. This is a way of constructing larger codes from smaller ones and these codes are typically used to guarantee error suppression in fault tolerance proofs <cit.>.\n\nMeasuring stabilizer generators yields a signature of the error that occurred called a syndrome. Inferring the error from the syndrome is called decoding. There are several ways to define a decoder, the simplest of which is the minimum weight decoder. It selects a Pauli error of minimum Hamming weight consistent with the observed syndrome. While some errors on the encoded states can be undone by quantum error correction, there are uncorrectable errors that cause unwanted logical operations on the encoded states under a quantum error correction routine. These uncorrectable errors determine the logical error rate. A valuable tool to define the logical error rate is the effective channel, which encapsulates the effect of a physical noise process and a quantum error correction protocol on the encoded quantum information.\n\nBesides the error-correcting code and the underlying physical noise process, the effective channel is a function of the measured error syndrome s. We will use the notation ^s_1 to denote the effective channel where the subscript \u201c1\" refers to one encoding level. The relevance of the subscript becomes crucial for concatenated codes <cit.>, where ^s_\u2113 refers to the effective channel for a level-\u2113 concatenated code. A particularly useful quantity is the average of logical channels ^s_\u2113 over all syndrome outcomes, denoted by _\u2113:\n\n    _\u2113 = \u2211_s^s_\u2113(s)  ,\n\nwhere (s) is the probability of observing the outcome s <cit.>. The average logical channel _\u2113 indicates how quantum error correction suppresses the effect of physical errors, on average. We will use logical infidelity r(_\u2113) <cit.> as a measure of the logical error rate.\n\nThe average logical infidelity for a code under a noise process  is calculated using the following equation: <cit.>\n\n    r(_1) = 1 -  \u2211_E,E^'\u2208_C\n     s(E) = s(E^')  , E = E^'\u03d5(E) \u03d5^\u22c6(E^') \u03c7_E,E^' ,\n\nwhere \u03c7_i,j represents the (i,j)^th entry of the \u03c7-matrix of , _C is the set of correctable errors, E is the logical component in the decomposition of E with respect to the Stabilizer group and \u03d5(E) is specified by R_s(E) E = \u03d5(E)  S for any Pauli error E and some stabilizer S. We use this expression at various points to calculate the logical infidelity. To calculate the entries of the \u03c7-matrix of the effective logical channel we use the following general expression: <cit.>\n\n    \u03c7(_1)_l,m = \u2211_E,E^'\u2208_C\n     s(E) = s(E^')  , E = E^'\u03d5(E, l) \u03d5^\u22c6(E^', m) \u03c7_E P_l,P_mE^' .\n\nwhere R_s(E) |E P_l| = \u03d5(E,l)  S  |P_l|, for l \u2208{0,1,2,3}, any Pauli error E and some stabilizer S. Here |P| stands for the bare Pauli without any associated global phase. \n\nWe calculate the \u03c7-matrix for logical channels at higher levels i.e, for \u2113>1 by recursing the expression in Eq.(<ref>) and using the entries of \u03c7(_\u2113-1) in the right hand side to evaluate \u03c7(_\u2113).\n\n\n\n\u00a7 METHODS\n\n\n\nThe goal of this paper is twofold. First, we want to identify important scenarios for physical errors wherein RC can be leveraged to improve the performance of quantum error correcting codes. Second, identify settings under which such performance gains cannot be guaranteed. For the first goal, we study the performance of concatenated Steane code under realistic error models. We start off by simple rotations about Z-axis and progressively move to arbitrary rotations followed by a combination of coherent and stochastic error models. For the second goal, we generate numerical results for a large ensemble of noise processes belonging to more complex noise models which involve random rotations on different qubits and arbitrary CPTP maps. All the performance metrics in this paper are derived in the memory model and assume perfect syndrome extraction. Simulations with gate dependent errors can be pursued in the future.\n\nFor both the goals, it is crucial to understand how RC can be applied alongside quantum error correction in practice. We follow the methods of Ref.\u00a0<cit.>. The main idea can be summarized as follows. Recall that noise tailoring by randomized compiling is achieved by inserting random Pauli gates in a circuit such that its net effect does not change the logical output of the circuit. Consequently, the average output distribution of the circuit over all possible Pauli random gates can be understood by studying the response of the original circuit against Pauli noise on the individual components. In the same spirit, we insert random Pauli gates around all the individual components of a quantum error correction circuit. There is no need to account for sources of noise in the extra Pauli random gates because they can be absorbed into the original elements of the quantum error correcting circuit. The theory of RC prescribes exponentially many compilations of the underlying circuit to achieve perfect twirling. However, in practice, only a handful compilations can be realized\u00a0<cit.>. Despite this practical limitation, we assume the ideal application of RC in this paper for simplicity. We leave the details of this procedure to the appendix section <ref>. \n\nWe now have two variations of the average fidelity. First, the standard notion \u2013 average fidelity over all syndrome outcomes, r(_1), defined in Eq.\u00a0(<ref>). Second, the average fidelity over syndrome outcomes as well as logically equivalent compilations of the quantum error correction circuit, which we will denote r_rc. Note that the number of random compilations for a circuit with n elements grows as (4^n). In the ideal case, where we have considered all of these compilations in r_rc(_1), it reduces to r(^T_1).\n\nWhile Eq.\u00a0(<ref>) addresses the logical channel of a block code, we can easily extend these definitions for a concatenated code assuming a hard decoder <cit.>. In this case, the logical channel at level-\u2113 can be recursively defined in as a function whose input physical channels are the logical channels at level-(\u2113-1). We will use the notation r(_\u2113) and r(^T_\u2113) to denote the logical channels of a level-\u2113 concatenated code without RC and with RC, respectively. Their ratio, denoted by \u03b4_\u2113, where\n\n    \u03b4_\u2113 = r(_\u2113)/r(^T_\u2113),\n\nis an indicator of the performance gain due to RC, which we will estimate for various error models. Note that \u03b4_\u2113 > 1 indicates a performance gain whereas \u03b4_\u2113 < 1 denotes a performance loss.\n\n\n\n\u00a7 RESULTS AND DISCUSSION\n\n\n\nThis section is devoted to case studies of performance gains from RC for the concatenated Steane code, under various interesting classes of error models, and inferences we can draw from these studies. Markovian errors can be broadly classified into unital and non-unital maps. Since non-unital components of a noise map do not impact the error rate significantly <cit.>, we restrict our attention to unital maps in this paper. In particular, we choose coherent rotations which form an important class of unital maps. In practice, these typically arise from imperfect pulses used to implement quantum gates in the hardware. Interestingly, these are also the class of errors on which randomized compiling has the maximum effect of turning them into purely incoherent noise. \n\n\n\n \u00a7.\u00a7 Rotation about  Lgaxis\n\nWhile we ideally want to study the impact of RC on the performance of a quantum error correcting code under general coherent errors, let us first start with a simple yet interesting model \u2013 rotations about the Z-axis. Although the RC process tailors the underlying physical noise, irrespective of the choice of the code, through this example we show that in fact the gains produced from RC can be arbitrarily increased by choosing codes of increasing distances.\n\nRecall that the rotation about Z-axis is specified by \u03c1\u2192 R_Z(\u03c9)\u03c1 R_Z(-\u03c9) where\n\n    R_Z(\u03c9) = cos (\u03c9/2)  I + i sin (\u03c9/2)  Z  .\n\nApplying the rotation independently across all n = 7 the physical qubits of the Steane code, is specified by the map\n\n    (\u03c1\u0305) = R^ n_Z(\u03c9) \u03c1\u0305 R^ n_Z(-\u03c9)\n        .\n\nThe performance of the Steane code under the above error model, can be inferred from Eq.\u00a0(<ref>), where the correctable errors _ can be defined with respect to the minimum weight decoder. Explicitly enumerating all correctable errors, we find that there are 22 correctable errors of weight at most one, and 42 two-qubit ones. Since we are confined to rotations about the Z-axes, we can limit ourselves to the correctable errors of Z-type. Reserving the details of our derivation to Appendix\u00a0<ref>, we find\n\n    r(_1) \u2248 63  (\u03c9/2)^4 - 476  (\u03c9/2)^6 + \ud835\udcaa(\u03c9^8)  .\n\nIn comparison, the logical infidelity for quantum error correction with randomized compiling is\n\n    r(^T_1) \u2248  21  (\u03c9/2)^4 - 112  (\u03c9/2)^6 + \ud835\udcaa(\u03c9^8)  .\n\nFinally, the performance gain from RC quantified using the metric \u03b4_1 defined in eq. <ref> can now be estimated as\n\n    \u03b4_1 = r(_1)/r(^T_1)\u2248 3 - 5/3 (\u03c9)^2 + \ud835\udcaa(\u03c9^4)  .\n\n\nWe now show that the above modest performance gains can be made arbitrarily large by  concatenating the Steane code with itself. It is possible to extend the analysis above via recursion to approximate the effective logical channel for a level \u2113 concatenated Steane code for \u2113 > 1. The details of this procedure can be found in Appendix\u00a0<ref>. The approximate logical channel allows us to estimate the performance of level \u2113 concatenated Steane code and study the impact of randomized compiling on it.\nTo understand the impact of RC with the number of levels, we can do a leading order analysis of the recursive relations used to construct the average logical channel, described in Appendix\u00a0<ref>. We find that for small rotation angle \u03c9, the average infidelity of the logical channel scales as\n\n    r(_\u2113)    \u2248 63^2^\u2113 - 1 (\u03c9/2)^2^\u2113 + 1 , \n    \n    r(^T_\u2113)    \u2248 21^2^\u2113 - 1 (\u03c9/2)^2^\u2113 + 1 .\n\nSubsequently, the scaling of gain \u03b4_\u2113 with the levels of concatenation is given by\n\n    \u03b4_\u2113\u2248 3^2^\u2113 - 1 - (5\u00d72^l-1\u00d73^2^l-3) \u03c9^2 + O(\u03c9^4)  .\n\nFigure <ref> corroborates this scaling law for the exact value of the logical error rates of the concatenated Steane code, in other words, showing that log(log(\u03b4_\u2113))) is approximately a linear function of \u2113. Note that the above analysis is accurate for small rotation angles.\n\nVarying the rotation angles leads us to another important discovery. Figure <ref> shows the gains from randomized compiling for a range of rotation angles for levels 1 \u2264\u2113\u2264 5. The gains from RC grow significantly with increase in number of levels of the code. The figure suggests the presence of a threshold rotation angle \u03c9_\u22c6 below which arbitrary gains from RC can be achieved by increasing the size of the code (levels of concatenation). On the contrary, for rotations \u03c9 > \u03c9_\u22c6, the trend reverses.\n\nWe now turn to more general noise models, where we will find that the presence of a threshold in the case of rotations about the Z-axis, extends to the general case.\n\n\n\n\n\n \u00a7.\u00a7 Rotation about an arbitrary axis\n\n\nWhile the above analysis considered coherent error models described by rotations about the Z-axis, it is straightforward to apply these ideas to rotations about any of the Pauli axes. We now investigate average gains due to RC for a rotation about an arbitrary axis.\n\nWe consider a general error model where the physical qubits of a code undergo rotations about an arbitrary axes of the Bloch sphere, described by the unitary matrix U, i.e., (\u03c1\u0305) = U^\u2297 n\u03c1\u0305  (U^\u2020)^\u2297 n. The following parameterization for U <cit.> is useful for our analysis:\n\n    [ cos(\u03c9/2) + i sin(\u03c9/2) cos(\u03b8)       i e^-i\u03d5sin(\u03c9/2) sin(\u03b8);       i e^-i\u03d5sin(\u03c9/2) sin(\u03b8)        cos(\u03c9/2) - i sin(\u03c9/2) ].\n\nwhere 0 \u2264\u03b8\u2264\u03c0 and 0 \u2264\u03d5\u2264 2 \u03c0 define the axis (in polar angles) about which each qubit is rotated, and \u03c9 gives the magnitude of the rotation. For example, \u03b8 = \u03d5 = 0 can be identified with rotations about the Z-axis. The performance gain from RC can be defined following Eq.\u00a0<ref>, as a function of the parameters \u03b4(\u03b8, \u03d5, \u03c9). The average gain for an unknown axis is computed as\n\n    \u03b4_\u2113(\u03c9) = 1/2 \u03c0\u222b_0^2\u03c0 d\u03d5\u222b_0^\u03c0sin(\u03b8)  d\u03b8\u03b4_\u2113(\u03b8,\u03d5, \u03c9)   ,\n\nfor \u2113 = 1. Likewise, for concatenated codes, \u03b4_\u2113 denotes the average gain in performance for level \u2113. This is similar to the conclusion drawn for the case of rotations about the Z-axis. First of all we see that for all coherent errors RC improves the performance of the Steane code. Furthermore, performance gains are largest for coherent errors that correspond to rotations about the X,Y or Z axes.\n\nUsing the general techniques developed in the appendix to approximate the effective logical channel of a level-\u2113 concatenated code, we can estimate the gains \u03b4_\u2113 in average performance due to RC over the various rotation axes. Similar to the case of Z-rotations, Fig.\u00a0<ref> suggests the presence of a threshold \u03c9_\u22c6 wherein for rotation angles \u03c9\u2264\u03c9_\u22c6 the gains can be arbitrarily increased by choosing codes of larger distance, whereas the trend reverses for \u03c9 > \u03c9_\u22c6.\n\nNote that threshold angle \u03c9_\u22c6 for rotations about an unknown axis is higher the threshold for rotations about the Z-axes, i.e., \u03c9_\u22c6 > \u03c9_\u22c6. This can be explained as follows. In the case of a generic non-Pauli axis, the twirled noise model, i.e., is in the presence of RC, is composed of a probabilistic mixture of X, Y and Z type errors. Whereas, in the case of a fixed Pauli axis, we only have errors of one type (either X, Y or Z). For a fixed error budget, specified by fidelity, the case of a non-Pauli axis results in the error strength spread over a larger number of correctable errors than the case of a fixed Pauli axis which would include relatively higher weight Pauli errors of one type. Hence, the Steane code has better error correction capability. Figure <ref> provides evidence to our argument by showing that the threshold angle for performance gains from RC under rotations about various axes, is higher for non-Pauli axes compares to the Pauli ones. As a consequence, we also note that for rotation angles \u03c9_\u22c6 < \u03c9 < \u03c9_\u22c6, the largest gains from RC are achieved for rotations axes that lie between the X, Y and Z axes as opposed to the individual Pauli axes.\n\n\n\n\n \u00a7.\u00a7 Composition of coherent and stochastic map\n\nSo far, we have shown that RC always improves the performance of quantum error correcting codes under coherent errors. Generic unital maps can be approximately described as a composition of a coherent error and a Pauli error model <cit.>. In what follows, we consider a more general unital map where we model coherent errors in a similar fashion as in the previous section and for Pauli errors, we choose the depolarizing error model, i.e., \n\n    \u2243 (_dep\u2218_coh)^\u2297 n,\n\nwhere \n\n    _coh(\u03c1)    = U \u03c1 U^\u2020,\n    _dep(\u03c1)    = (1-p) \u03c1 + p/2\ud835\udd40.\n\nand U can be parameterized using Eq.\u00a0(<ref>). In what follows, we will study the impact of RC under the approximation given by Eq.\u00a0(<ref>). Note that both the coherent as well as the incoherent parts of the error model contribute to the strength of noise, for instance, the average gate fidelity. While RC only affects the coherent part of the error process, we expect that for a fixed noise strength, the performance gain due to RC under the error model described above will diminish with increasing p. This expectation is supported by the numerical simulations presented in Fig.\u00a0<ref>, where we present numerical estimates of \u03b4_\u2113(\u03c9,p) for several depolarizing strengths p.  Here, \u03b4_\u2113(\u03c9,p) is defined analogous to Eq.\u00a0(<ref>) as\n\n    \u03b4_\u2113(\u03c9,p) = 1/2 \u03c0\u222b_0^2\u03c0\u222b_0^\u03c0\u03b4_\u2113(\u03b8, \u03d5, \u03c9, p) sin(\u03b8)  d\u03b8 d\u03d5 .\n\n\n\nNote that in all of the error models considered so far, we have only observed gains in performance due to RC. However, amongst the most general CPTP maps including the unital as well as non-unital types, we have identified cases under which RC can lead to a loss in the performance. Some examples of these maps are mentioned in Appendix\u00a0<ref>.\n\n\n\n\u00a7 CONCLUSION\n\n\nThe application of randomized compiling in fault tolerance is attractive for two reasons. First, amongst the exponentially growing number of parameters controlling a physical noise process, RC effectively eliminates the impact of most of them on a QEC scheme. Second, since RC removes multiple noise sources, we expect the code to perform better. This paper provides concrete evidence to show that RC improves the performance of quantum error correction under a wide class of coherent errors. We have identified noise regimes where gains are drastic for the case of concatenated Steane codes. In particular, it grows doubly exponentially with the number of levels, under small rotations about a Pauli axis. Our results can be extended to guarantee performance gains under generic unital noise processes, leveraging tools from <cit.> that approximate a unital noise process as a composition of a coherent and an incoherent error model. These observations strengthen the need for active noise tailoring methods as a crucial component of a fault tolerant scheme. \n\nPerformance gains offered by RC also depend on the strength of errors affecting the physical qubits. We stumbled upon an interesting observation that indicates gains decrease when the amount of coherent rotation error passes beyond a threshold value. To the best of our knowledge a threshold of this nature hasn't been reported in earlier works. The threshold helps estimate the maximum possible noise that can be alleviated on a hardware device by leveraging RC tools. We also carried out extensive studies to analyze the variation of this threshold with the features of the underlying coherent error model.\n\nBeyond the paradigm of identical unital maps across all physical qubits, we argue that unilateral conclusions about performance gains due to RC cannot be made, i.e., it depends strongly on the microscopic details of the underlying physical noise process. Our arguments are strengthened by numerical studies of complex physical noise processes that revealed some cases where the code's performance can also degrade in the presence of RC. In Ref.\u00a0<cit.>, it was shown that twirled noise processes may improve or degrade thresholds depending on the decoding algorithm used. In this paper we arrive at a similar conclusion by exploring different error models for the minimum weight decoder.\n\nObtaining efficiently computable estimates for performance gains due to RC in different experimental setups would be crucial to optimizing fault tolerance resources in near-term applications. In the absence of exact values, it would be useful to provide bounds for the impact of RC on the code\u2019s performance. Although RC's impact on performance depends strongly on the underlying noise process, it is still interesting to see that it can provide significant gains for a wide variety of realistic error models and relevant error regimes. \n\nTo ensure a performance gain from a noise tailoring technique, such as RC, ideally, we want to cancel the impact of those terms in the underlying noise process, which correspond to uncorrectable errors \u2013 since these add to the logical infidelity. It would be worthwhile to explore ways of controlling physical noise sources to ensure that RC always offers a gain in performance. It would also be interesting to explore different Twirling gate sets that can tailor the noise process to suppress terms that contribute negatively to the logical channel\u2019s fidelity. Although we identified a handful of cases where a performance loss is observed, it will be noteworthy to develop cheap experimental protocols to ascertain whether performing error correction with RC will be significantly beneficial for a given device. \n\n\n\nThis research was undertaken thanks in part to funding from the Canada First Research Excellence Fund. Research was partially sponsored by the ARO and was accomplished under Grant Number: W911NF-21-1-0007.  SDB acknowledges support from the Australian Research Council (ARC) via the Centre of Excellence in Engineered Quantum Systems (EQuS) project number CE170100009.  \n\n\n\n\n\n\n\n\n\n\n\u00a7 LOGICAL FIDELITY CALCULATION FOR ROTATION ABOUT Z-AXIS\n\n\nIn this appendix section, we will derive the logical performance of Steane code under a unitary noise process described by a small over-rotation about the Z-axis, i.e. (\u03c1) = R_Z(\u03c9)\u03c1 R_Z(-\u03c9) where\n\n    R_Z(\u03c9) = cos (\u03c9/2)  I + i sin (\u03c9/2)  Z  .\n\n\nRecall that the Steane code is a [[n,k]] quantum code with n = 7, k = 1, whose encoded states are fixed by the Stabilizer group  generated by n-k generators:\n\n    = \u27e8 ZZZZIII, ZZIIZZI, ZIZIZIZ, XXXXIII, XXIIXXI, XIXIXIX\u27e9 .\n\nThe effect of the unitary noise in eq. <ref> on each of the n qubits in the encoded state can be written as\n\n^n(\u03c1\u0305)    = R^n_Z(\u03c9) \u03c1\u0305 R^n_Z(-\u03c9) \n\n    = \u2211_w \u2208^2n_2 (-1)^\u2211_j=n+1^2n w_j (cos(\u03c9/2))^2n-|w| (i sin(\u03c9/2))^|w| (_j=1^n Z^w_j) \u03c1\u0305 (_j=n+1^2n Z^w_j)  .\n\nwhere |w| is the Hamming weight of the binary sequence w \u2208^2n_2.\n\nTo understand the effect of RC on performance, we need to estimate the total contribution to logical fidelity from terms in the noise process whose effect is rendered useless by RC. Since the noise model in eq. <ref> only applies Z-type errors, it suffices to consider the effect of correctable errors E and E^' that are purely Z-type, besides the identity. In other words, E, E^'\u2208\u27e8 Z_1, Z_2, \u2026, Z_n\u27e9. Table <ref> shows the contribution to the logical fidelity that is eliminated by RC. Each of the four rows in the table is associated with a \u03c7-matrix element of a particular form, labelled by \u03b3_i for 1\u2264 i \u2264 4.\n\n\n\nTable <ref> provides all the ingredients necessary to compute the logical infidelity of the Steane code under the RC setting:\n\nr(^T_1)     = 1 - (\u03ba_1 + 7 \u03ba_2 + 7 \u03ba_3 + 7 \u03ba_4)  , \n\n    = 1/512 (256 - 231 cos(\u03c9) - 49 cos(3 \u03c9) + 21 cos(5 \u03c9) + 3 cos(7 \u03c9)) . \n\nNote that the coefficient appearing alongside each \u03d5_i in eq. <ref> corresponds to its multiplicity, i.e., the number of combinations of errors E, E^' that result in the same value of \u03d5_i. In the absence of RC, the logical infidelity can be calculated using both tables <ref> and <ref>:\n\nr(_1)    = 1-(\u03ba_1 + 7 \u03ba_2 + 7 \u03ba_3 + 7 \u03ba_4 + 14 \u03b3_1 + 14 \u03b3_2 + 42 \u03b3_3 + 14 \u03b3_4) ,\n\n   = 1/64 (32 - 21 cos(\u03c9)  - 14 cos(3 \u03c9) + 3 cos(7 \u03c9)) . \n\n\nThe above expressions describe the logical infidelities for level-1 concatenated Steane code in the RC and non-RC settings. The gain \u03b4_1 can be calculated as the ratio of the above quantities. The appendix section <ref> discusses the recursion to compute the average logical channel for level-\u2113 concatenated Steane code followed by the computation of the different metrics at level-\u2113.\n\n\n\u00a7 LOGICAL CHANNEL FOR THE CONCATENATED STEANE CODE\n \nIn this appendix section, we will describe the computation of the average logical channel for the level-\u2113 concatenated Steane code under rotations about the Z-axis described in section <ref>. Ideally, we would like to take an exact average over conditional channels corresponding to all possible syndromes of the level-\u2113 concatenated Steane code. However, the number of syndromes and hence the number of conditional channels grow exponentially with the number of physical qubits and the analysis becomes intractable beyond a few levels. Instead, in this section we compute an approximation wherein we recurse over the individual entries of the level-1 logical channel to arrive at the level-\u2113 logical channel. We will achieve this in two broad steps:\n\n\t\n  * Computation of level-1 logical channel.\n\t\n  * Establish a recursion to compute level-(\u2113+1) from level-\u2113 logical channel.\n\n\nFor a given noise process , we refer to its \u03c7-matrix as \u03c7() and the corresponding logical \u03c7-matrix as \u03c7(_1). The following equation prescribes a way to calculate the entries of \u03c7() from \u03c7() <cit.>.\n\n\n\n    \u03c7(_1)_l,m = \u2211_E,E^'\u2208_C\n     s(E) = s(E^')  , E = E^'\u03d5(E, l) \u03d5^\u22c6(E^', m) \u03c7_E P_l,P_mE^' .\n\nwhere _C refers to the set of correctable errors, P_i denotes the logical version of Pauli P_i, and R_s(E) |E P_l| = \u03d5(E,l)  S  |P_l|, for l \u2208{0,1,2,3}, any Pauli error E and some stabilizer S. Here |P| stands for the bare Pauli without any associated global phase. Note that, since the error model is a rotation about the Z-axis, we have _C = \u27e8{S_j Z_i  :  1 \u2264 i \u2264 n  ,  S_j\u2208_Z}\u27e9. Here Z_i refers to a single qubit Z error on qubit i and _Z = \u27e8 ZZZZIII, ZZIIZZI, ZIZIZIZ \u27e9. \n\nIt is easy to see that the average logical channel for the level-\u2113 concatenated Steane code \u03c7(_\u2113) takes the form <cit.>:\n\n    \u03c7(_\u2113) = [                     [\u03c7(_\u2113)]_0,0               0               0     [\u03c7(_\u2113)]_0,3;                               0               0               0               0;                               0               0               0               0;                 ([\u03c7(_\u2113)]_0,3)^*               0               0   1-[\u03c7(_\u2113)]_0,0 ],\n\nwhere ([\u03c7(_\u2113)]_0,3)^* denotes the complex conjugate of [\u03c7(_\u2113)]_0,3. \n\nFirst, we compute the entries for the level-1 matrix \u03c7(_1). Using Table <ref>, we have\n\n[\u03c7(_1)]_0,0     = \u03ba_1 + 7 \u2211_i=1^3 \u03d5_i + 28 \u03c7_3 + 14 \u2211_j=1^4 \u03c7_j , \n\n    = 1/64 (21 cos(\u03c9)+14 cos(3 \u03c9)-3 cos(7 \u03c9)+32) . \n\n\n\n\nTable <ref> provides all the ingredients necessary to compute [\u03c7(_1)]_0,3. Taking into account the multiplicities of terms of each kind, we have\n\n  [\u03c7(_1)]_0,3     = \u03b6_1 + 42 \u03b6_4 + 7 \u2211_i=2^8 \u03b6_i , \n\n     = -1/8 i sin^3(\u03c9)  (9 cos(2 \u03c9)+3 cos(4 \u03c9)+2) .\n \t\t\n\n\nIn the second step, we establish a recursion to compute the individual entries of \u03c7(_\u2113) from the entries of \u03c7_\u2113-1() under hard-decoding algorithm. After massaging the expressions in equations <ref> and <ref>, we observe that \n\n\t[\u03c7(_\u2113+1)]_0,0     = f_0,0([\u03c7(_\u2113)]_0,0), and\n\n[\u03c7(_\u2113+1)]_0,3     = f_0,3([\u03c7(_\u2113)]_0,3),\n\nwhere\n\nf_0,0(z)     = z^2 (63 - 434 z + 1260 z^2 - 1848 z^3 + 1344 z^4 - 384 z^5), and\n\nf_0,3(z)     = -2 z^3 (7 + 84 z^2 + 192 z^4).\n\n\nCombining the above two steps, we compute all the entries of [\u03c7(_\u2113+1)]. \n\nFor small rotation angle \u03c9, we observe from equations <ref> and <ref> that upto leading order \n\n\t[\u03c7(_\u2113)]_0,0     \u22481 - 63^2^\u2113- 1 (\u03c9/2)^2^\u2113+1, and \n\n\t\t[\u03c7(_\u2113)]_0,3     \u2248- i 14^3^\u2113- 1/2 (\u03c9/2)^3^\u2113.\n\nNote that with increase in number of levels \u2113, for small angle \u03c9, [\u03c7(_\u2113)]_0,0\u2192 1 and [\u03c7(_\u2113)]_0,3\u2192 0. This is expected because for small angles, the channel is close to the identity channel and the error correction procedures is able to correct all the errors. Also, note that the off diagonal entry approaches 0 faster than the diagonal entry approaches 1. This is a consequence of the process of error correction decohering the physical channel <cit.>. \n\nNow, we compute the logical \u03c7-matrix corresponding to the noise process under RC i.e. \u03c7(^T_\u2113). The matrix in this case takes the form:\n\n    \u03c7(^T_\u2113) = [                   [\u03c7(^T_\u2113)]_0,0               0               0               0;                               0               0               0               0;                               0               0               0               0;                               0               0               0 1-[\u03c7(^T_\u2113)]_0,0 ].\n\nSimilar to the nonRC case, we first compute the entries for the level-1 matrix \u03c7(^T_1). Using the ingredients from table <ref>, we have\n\n    [\u03c7(^T_1)]_0,0 = 1/512 (256 + 231 cos(\u03c9) + 49 cos(3 \u03c9) - 21 cos(5 \u03c9) - 3 cos(7 \u03c9))  .\n\nThe recursive relation to calculate the above quantity for higher levels is given by:\n\n    [\u03c7(^T_\u2113+1)]_0,0 = g_0,0([\u03c7(^T_\u2113)]_0,0)  ,\n\nwhere\n\n    g_0,0(z) = z^2 (21 - 98 z + 210 z^2 - 252 z^3 + 168 z^4 - 48 z^5)  .\n\nFor small rotation angle \u03c9, upto leading order\n\n    [\u03c7(^T_\u2113)]_0,0\u2248 1 - 21^2^\u2113 - 1 (\u03c9/2)^2^\u2113+1 .\n\nThe above expression indicates that [\u03c7(^T_\u2113)]_0,0\u2192 1 with increase in number of concatenation levels \u2113 provided the angle of rotation is below the threshold.\n\nHaving arrived at an expression for the average logical channel for a level-\u2113 concatenated code, we can now define the logical error rate using the infidelity and diamond distance metrics. The logical infidelity takes the simple closed form:\n\nr_\u2113 = 1 - [\u03c7(_\u2113)]_0,0 .\n\n\n\n\n\n\n\n\u00a7 NUMERICAL RESULTS FOR COMPLEX NOISE MODELS\n \nIn this appendix section, we will present numerical studies of the performance of concatenated Steane codes under two distinct models of general Markovian noise. The results are presented as scatter plots formatted as follows. Each point is associated to the performance of a physical noise process. While the X- coordinate is used to denote the physical error rate, its Y-coordinate denotes the ratio between the performance in the non-RC setting and the RC setting, measured by \u03b4_\u2113 in eq. <ref>. Note that RC can either improve or degrade the code's performance. We have used a dashed line at \u03b4_\u2113 = 1 to identify the breakeven region where RC has no impact on the performance. Points that lie below the dashed line, coloured in red, identify physical channels where a degradation in performance is observed. On the other hand, points in green that lie above the dashed line identify physical channels where RC provides a performance gain. The points in grey, that lie close to the dashed line should be ignored since they correspond to cases where the relative difference between the logical error rates for the non-RC and RC cases is negligible: less than 10%.\n\n\nThe first complex error model is a unitary model where each qubit experiences a different random rotation about an arbitrary non-Pauli axis n\u0302, specified by U of the form\n\n    U = e^-i \u03c0/2\u03b4n\u0302\u00b7\u03c3\u20d7 ,\n\nwhere \u03b4 is the angle of rotation. Hence, the n-qubit unitary errors in our model are of the form \u2297_i=1^n U_i, where U_i in prescribed by eq. <ref>. We control the noise strength by setting the rotation angles \u03b4_i drawn from the normal distribution: (\u03bc_\u03b4, \u03bc_\u03b4), where 10^-3\u2264\u03bc_\u03b4\u2264 10^-1. Fig. <ref> shows the performance gain metric under this error model. It demonstrates that there exist some instances where RC provides a performance gain of 10x, as well as others where RC causes a performance degradation of 10x.\n\n\n\n\nThe second error model is described by the i.i.d action of a random single qubit CPTP map, on each of the physical qubits of the code. The random CPTP map on a single qubit is derived from unitary dynamics U on a Hilbert space of three qubits <cit.>. The unitary matrix U is generated form a random Hermitian matrix H using U = e^-i H t, where 0 \u2264 t \u2264 1 provides a handle on the strength of noise described by the resulting CPTP map. We vary the noise strength by controlling t in the range [0.001, 0.1]. Figure <ref> shows RC\u2019s impact on the performance of concatenated Steane codes under physical CPTP maps. The absence of a clear trend showing a performance gain or degradation is evident for level-2 in fig. <ref>. Even across physical CPTP maps with similar fidelity, while for one instance, RC induces a performance gain of up to three orders of magnitude, for another, it inflicts a loss in performance of similar magnitude.\n\n\n\nThe case of level-1 performance under physical CPTP maps in fig. <ref> is rather different from the level-2 case in <ref>. Over the large ensemble of 18000 physical CPTP maps, we observe that RC always leads to performance gains for the level-1 Steane code. These performance gains can be explained as follows. First of all, a CPTP map can be well approximated by its leading Kraus operator K, which is derived from the largest eigenvector of its Choi matrix <cit.>. Furthermore, in an i.i.d physical error model, K can be expressed as a tensor product. In terms of K, the leading contributions to infidelity come from chi-matrix entries \u03c7_i,j expressed as:\n\n    \u03c7_i,j = (K P_i) (K^\u2020 P_j)  ,\n\nwhere P_i is a single qubit of one type (X, Y or Z), and P_j = P_i S for some stabilizer S, is a three-qubit error of the same type as P_i. In the low noise regime, the off-diagonal entries of K are small, especially for incoherent CPTP maps, where K is close to a Positive sem-definite matrix <cit.>. Using the fact that the trace inner product between K and the Pauli matrix Z is a real number d given by d = K_1,1 - K_2,2, we can conclude that \u03c7_i,j in eq. <ref> for Z-type errors P_i and P_j of weights 1 and 3 respectively, is always positive. In other words, the \u03c7_i,j\u223c d^4 for some d \u226a 1. Removing such terms should degrade the performance of the code. On the contrary, removal of \u03c7_i,j for uncorrectable errors P_i, P_j leads to performance gains. The largest of these chi-matrix entries can be identified with two Z-type Pauli errors P_i, P_j, each having weight two. This property can be associated with the fact that the Steane code is degenerate: there exists a logical operator whose weight is smaller than that of a stabilizer. Repeating a similar analysis as before, we find that the corresponding \u03c7_i,j for these uncorrectable errors, also scale as d^4 for some d \u226a 1. Their removal leads to performance gains. Note that there are more uncorrectable errors than correctable ones and the corresponding chi-matrix elements have comparable magnitudes. Hence, we find that RC is more likely to induce performance gains. Note that higher concatenation levels of the Steane code do not correspond to degenerate codes. Hence, we cannot guarantee a performance gain or degradation in those cases, as shown in fig. <ref>\n\n\n\n\u00a7 APPLYING RC IN A FAULT TOLERANCE SCHEME\n \n\nRandomized compiling <cit.> is a technique that tailors a general Markovian noise process into an effective Pauli noise process. In this appendix section, we will briefly review how we can apply randomized compiling in a fault-tolerant setting. This procedure was first described in Ref.\u00a0<cit.>.\n\nIn fault tolerant circuits, each logical gate G is sandwiched between quantum error correction () routines. Similar to Ref.\u00a0<cit.>, we divide logical gates into two sets: _1 and _2, calling them easy and hard gates respectively. A requirement for _1 and _2 is\n\n    G\u00a0T\u00a0G^\u2020\u00a0 = (T)\u00a0C\n\nfor all easy logical gates C\u2208_1, n-qubit Pauli gates T and hard gates G. Here (T) refers to the compilation of the Pauli gate T in the  routine. The above requirement can be proven to be true using results from standard randomized compiling <cit.>. \n\nFigure <ref> shows a canonical presentation of a quantum circuit, where the k-th clock cycle is composed of an easy gate C_k and a hard gate G_k, sandwiched between  routines. Noise processes affecting easy and hard gates are denoted by _1,k and _2,k respectively. These complex processes can be tailored to Pauli errors by inserting Pauli gates T_1,k, T^\u2020_1,k,T_2,k, T^\u2020_2,k as shown in fig. <ref>. However, to guarantee that they be applied in a noiseless fashion, we compile them into the existing gates in the fault tolerant circuit. This is achieved as follows. First T^\u2020_1,k and T_2,k are compiled into  following _1,k, resulting in (T^\u2020_1,kT_2,k). Secondly, T^\u2020_2,k is propagated across G_k, and compiled with C_k+1T_k+1, resulting in a dressed gate C^D_k+1 defined by\n\t\n    C^D_k+1 = G_k\u00a0T_k\u00a0G_k^\u2020C_k+1 T_k+1 .\n\n\tUsing eq. <ref>, it is easy to see that C^D_k+1 is equivalent to quantum error correction followed by an easy gate.\n\nFigure <ref> shows the result of compiling all of the twirling gates into the easy gates and quantum error correction routines. Note that the compiled circuit is logically equivalent to the original circuit in the absence of noise. However, in the presence of noise, the average output of the circuit is dictated by the performance of (T) averaged over the different choices of Pauli gates T. This is what we refer to as  in the RC setting. In practice, this average performance can be achieved by repeating every iteration (shot) of the algorithm with a different Pauli operation compiled into the constituent  routines. In this paper, we have used the performance of the  routine under the twirled noise process as a proxy to the performance of  in the RC setting, for the analytical and numerical studies.\n\n\n\n\n\n\n\n\n"}