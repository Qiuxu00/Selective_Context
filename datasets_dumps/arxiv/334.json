{"entry_id": "http://arxiv.org/abs/2303.06863v1", "published": "20230313051531", "title": "Semantically Secure Private Set Intersection over Outsourced Multi-Owner Secret-Shared Databases", "authors": ["Dongfang Zhao"], "primary_category": "cs.CR", "categories": ["cs.CR", "cs.DB"], "text": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  University of Nevada, Reno\n  United States\ndzhao@unr.edu\n\n\nPrivate set intersection (PSI) aims to allow users to find out the commonly shared items among the users without revealing other membership information.\nThe most recently proposed approach to PSI in the database community was Prism,\nwhich is built upon secret sharing and the assumption that multiple non-colluding servers are available.\nOne limitation of Prism lies in its semantic security:\nthe encoding on the servers is deterministic,\nimplying that the scheme cannot be indistinguishable under a chosen-plaintext attack (IND-CPA).\nThis paper extends the original PSI scheme of Prism by two orthogonal primitives,\nnamely Kaleido-RND and Kaleido-AES:\nthe former exhibits highly efficient performance with randomized encoding and the latter is provably secure under CPA attacks with more computational overhead.\nA system prototype is implemented and deployed on a 34-node cluster of SQLite instances.\nExtensive experiments on the TPC-H benchmark and three real-world applications confirm the effectiveness of the proposed Kaleido primitives.\n\n\nprintfolios=true\nSemantically Secure Private Set Intersection over Outsourced Multi-Owner Secret-Shared Databases\n    Dongfang Zhao\n    Received: date / Accepted: date\n================================================================================================\n\n\n\n\n\n\u00a7 INTRODUCTION\n\n\nPrivate set intersection (PSI) aims to allow users to find out the commonly shared items among the users without revealing other membership information.\nAs can be used as a versatile cryptographic primitive, \nPSI has been actively studied in the literature of applied cryptography\u00a0<cit.> and recently in privacy-preserving outsourced databases\u00a0<cit.>.\nAs a concrete example,\nPSI has been recognized as a crucial building block to support various operations in outsourced databases,\nsuch as semi-joins\u00a0<cit.>.\n\nThe most recently proposed approach to PSI in the database community was Prism\u00a0<cit.>,\nwhich is built upon secret sharing and the assumption that multiple non-colluding servers are available.\nSecret sharing\u00a0<cit.>, as the name suggests,\nallows users to split a plaintext into multiple portions such that a single portion (stored on a distinct server) does not reveal any information about the plaintext.\nand is usually considered as a specific form of secure multiparty computation (MPC)\u00a0<cit.>.\nPrism demonstrates a high efficiency that is based on group-homomorphic exponentiation.\n\nOne limitation of Prism\u00a0<cit.> lies in its semantic security:\nAlthough the exact number of shared entities is masked through number-theoretical modular exponentiation,\nsuch encoding is deterministic,\nimplying that the scheme cannot be indistinguishable under a chosen-plaintext attack (IND-CPA).\nThe first goal of this paper is,\ntherefore,\nto describe an attack that can reveal information more than the intersection among parties. \n\nTo guarantee the semantic security of Prism,\nthe second goal of this paper is to extend the original PSI scheme of Prism by two orthogonal primitives:\n(i) Kaleido-RND, an efficient module to randomize the group generator based on which the exponentiation is computed in the codomain of a multiplicative group,\nand (ii) Kaleido-AES, a pseudorandom function to ensure the IND-CPA security of the entire PSI scheme.\nAs the name suggests, our proposed schemes aim to garble the original Prism scheme,\nending up a scattered prism\u2014looking like a kaleidoscope.\nWhile Kaleido-RND is highly efficient and does offer randomization on the ciphertext,\nKaleido-RND is not proven IND-CPA secure.\nHowever, we will demonstrate that Kaleido-AES is provably semantically secure with the cost of computational overhead.\n\nTo demonstrate the effectiveness of the proposed Kaleido schemes,\nwe implement a system prototype with about 1,000 lines of Python and Shell script and deploy the system on a 34-node cluster of SQLite instances on CloudLab\u00a0<cit.>.\nWe evaluate Prism, Kaleido-RND, and Kaleido-AES with the TPC-H benchmark and three real-world applications,\nwhere we scale the number of database owners (i.e., clients) between 2 and 32.\nOur results show that Kaleido-RND only incurs insignificant overhead on the server encoding and is generally negligible in the entire system.\nMoreover, although Kaleido-AES seems to introduce much computational overhead compared to the original Prism,\nthe overhead is orders of magnitude lower than the communication cost,\ndemonstrating the practicality of Kaleido-AES in addition to its provable security.\n\nIn summary, this paper makes the following technical contributions.\n\n    \n  * We demonstrate a security vulnerability of a state-of-the-art PSI scheme, Prism, in outsourced databases. We provide both the intuition behind an effective attack and detail such an attack with concrete examples.\u00a0(<ref>)\n    \n    \n  * We propose a series of new primitives, namely Kaleido, to extend Prism such that the new PSI scheme is semantically secure.\n    We prove the IND-CPA security of Kaleido under the widely-accepted computational assumption and exemplify its correctness with both theoretical analysis and case studies.\u00a0(<ref>)\n    \n    \n  * We implement the Kaleido scheme with about 1,000 lines of Python and Shell scripts.\n    We deploy the system on two servers and 32 database owners hosted in the public cloud, CloudLab\u00a0<cit.>.\n    Extensive experiments on the TPC-H benchmark and three real-world applications confirm the effectiveness of the proposed Kaleido schemes.\u00a0(<ref>)\n\n\n\n\n\u00a7 PRELIMINARY\n\n\n\n\n \u00a7.\u00a7 Private Set Intersection and Secure Multi-Party Computation\n\n\nPrivate set intersection (PSI)\u00a0<cit.> has been extensively studied in outsourced databases,\nsuch as being used as a building block for privacy-preserving joins between outsourced databases\u00a0<cit.>.\nIndeed, PSI can be considered a special form of set operations among multiple parties,\nand therefore can be implemented through a general-purpose secure multi-party computation scheme,\nwhich mostly reply on arithmetic or boolean gates that incur significant computation overhead.\n\nSecure multiparty computation (MPC)\u00a0<cit.> has a long history\u00a0<cit.>.\nThe goal of MPC is more ambitious:\nin addition to keeping the plaintext confidential,\nwe want to calculate an arbitrary function of the original plaintexts by touching on only the encoded data on multiple parties.\nThe original problem was solved by the so-called garbled circuits\u00a0<cit.>,\nwhose idea was pretty simple:\nwe can ask each party to encode the input with its private key,\nshuffle the encrypted ciphertexts,\nand then enumerate all the keys to decrypt the result.\nSince we assume the encryption scheme is secure,\nthe only way that the result can be revealed is that the correct combination of private keys is applied to one of the garbled outputs.\nThis is indeed a feasible solution, at least theoretically;\nin practice, the circuits may grow exponentially and result in efficiency issues.\nThere are many more efficient MPC solutions,\nsuch as\u00a0<cit.>.\n\nOne of the main limitations of PSI schemes lies in their scalability.\nIn fact, many existing PSI schemes support only two parties,\nsuch as\u00a0<cit.>.\nMore recent works\u00a0<cit.> emerged to focus efficient PSI schemes on more than two parties.\nThis work falls into the category of the latter:\nThe proposed Kaleido scheme supports an arbitrary of parties for the PSI operation.\n\n\n\n \u00a7.\u00a7 Secret Sharing\n\n\nThe idea of a secret sharing scheme (SSS) is straightforward:\na given plaintext pt is converted into a set of encoded bytes ct's such that only a specific subset of ct's can reconstruct the original pt.\nThe goal of SSS is to reduce the risk of disclosing the plaintext;\ninstead of compromising the holder of the plaintext,\nthe malicious adversary needs to subvert multiple entities before any of the shareholders detect the attack.\nEven for weaker attacks where only semi-honest adversaries are assumed, \ndispersing the secret shares to more parties raises the bar of a successful eavesdropping attack.\n\nIn practice, a SSS can be tuned by the subset size. \nFormally, a (t,n)-threshold SSS (TSSS) is defined as follows.\n\nA (t,n)-TSSS is comprised of two algorithms:\n\n    \n  * Share: a randomized algorithm that takes as input a plaintext pt and returns a sequence S = (s_1, \u2026, s_n) of shares.\n    \n  * Reconstruct: a deterministic algorithm that takes a set of at least t shares and returns the plaintext.\n\nThe number t is called the threshold of the TSSS.\nLet U of size t be a subset of n shares, |U| \u2265 t and U \u2286{s_1, \u2026, s_n},\nwe require that a TSSS holds the following property:\n\n    Reconstruct(U) = pt.\n\n\nAs we will see in the next section\u00a0<ref>, the definition of TSSS leads to a slightly different security definition compared with the conventional encryption schemes.\n\nThe canonical example of (t,n)-TSSS is due to Shamir\u00a0<cit.>,\nin which the secrets were revealed through a (t-1)-degree polynomial.\nIn essence, each share can reconstruct the coefficient of a specific degree of unknowns through the LaGrange polynomials.\nIn addition to Shamir's construction, \nother schemes exist.\nIto et al.\u00a0<cit.> proposed the replicated secret-sharing scheme,\nwhich was based on finite fields where each share is a vector.\nOne nice property of replicated secret-sharing is its linearity:\nthe addition and subtraction of local shares can be linearly transformed into the addition and subtraction of the plaintexts.\nA simpler variant of replicated secret-sharing is additive secret sharing,\nwhere each share is a scalar value and the threshold t is set to n.\n\n\n\n \u00a7.\u00a7 Probably Security\n\n\nWhen employing an encryption scheme in an application,\nit is highly desirable to demonstrate its security provably.\nFormally, we need to identify the following three important pieces for the provable security of a given encryption scheme:\nsecurity goal, threat model, and assumption.\nThe security goal spells out the desired effect when the application is under attack;\nthe threat model articulates what an adversary can do with the attack,\nsuch as what information of the plaintext/ciphertext can be collected and the resource/time limitation of the attack;\nthe assumption lists the presumed conditions of the cryptographic scheme (e.g., factoring a product of two big primes, finding the discrete logarithmic root).\nThe security goal and threat model are usually called security definition collectively.\n\nOne well-accepted security definition with a good balance between efficiency and security is that the adversary can launch a chosen-plaintext attack (CPA),\ndefined as follows.\n\nGiven a security parameter n,\ni.e., the bitstring length of the key,\nan adversary can obtain up to poly(n) of plaintext-ciphertext pairs (m, c),\nwhere m is arbitrarily chosen by the adversary and poly(\u00b7) is a polynomial function in n.\nWith such information, the adversary tries to decrypt a c' that is not included in the polynomial number of known ciphertexts.\n\n\nThe polynomial requirement mandates that the adversary should only be able to run a polynomial algorithm without unlimited resources.\nAccordingly, we want to design encryption schemes that are CPA secure: \neven if the adversary \ud835\udc9c can obtain those extra pieces of information, \n\ud835\udc9c should not be able to decode the ciphertext better than a random guess up to a very small probability.\nTo quantify the degree of this small probability,\nnegligible function is defined as below.\n\n\nA function \u03bc(\u00b7) is called negligible if for all polynomials poly(n) the inequality \u03bc(n) < 1/poly(n) holds for sufficiently large n's.\n\n\nFor completeness, we list the following lemmas for negligible functions that will be used in later sections.\nWe state them without proof, \nwhich can be found in introductory cryptography or complexity theory texts.\n\n\n\nLet \u03bc_1(n) and \u03bc_2(n) be both negligible functions.\nThen the following functions are all negligible:\n\u03bc_1(n) + \u03bc_2(n), \u03bc_1(n) - \u03bc_2(n), \u03bc_1(n) \u00d7\u03bc_2(n), and \u03bc_1(n)/\u03bc_2(n).\n\n\nThe canonical method to prove the security of a proposed encryption scheme,\nsuch as IND-CPA,\nis through reduction\u00a0<cit.>.\nUsually, breaking the scheme is reduced to solving a hard mathematical problem,\nwhich means that if an attack is possible for the scheme then the mathematical problem would be efficiently solved.\nThat is, the encryption scheme is at least as hard as the mathematical problem.\nThe scheme is modeled as a subroutine,\nwhose inputs are simulated such that the adversary cannot tell whether it is being involved in an attack or in a subroutine to help solve the hard problem. \nAlthough forward proof is possible,\nthe more commonly used technique is a contradiction:\nby assuming that the adversary could distinguish two ciphertexts in an experiment with a non-negligible advantage, \nthe reduction would lead to a non-negligible probably to efficiently solve the hard mathematical problem that is believed to be intractable,\nthus leading to a contradiction.\n\n\n\n\u00a7  PSI\n\n\n\nThis section discusses the potential security issues of Prism\u00a0<cit.>.\nWe start by describing the Prism PSI scheme\u00a0(<ref>),\nthen provide a security analysis\u00a0(<ref>),\nand finally, exemplify the security issues using a real-world example\u00a0(<ref>).\n\n\n\n \u00a7.\u00a7 Scheme Definition of Prism PSI\n\n\n\nThis subsection provides a brief introduction to Prism\u00a0<cit.>.\n\n\n\n  \u00a7.\u00a7.\u00a7 Assumptions\n\n\n\n\n  \nNon-colluding Servers\nPrism assumes that a cluster of non-colluding servers is available for storing secret shares generated from the original plaintext.\nIn practice, this assumption can be realized by, for example, acquiring virtual machines from distinct cloud computing vendors such as Google Cloud Platform and Amazon Web Services.\n\n\n\n  \nHardness of Discrete Logarithmic Problem\nLet \ud835\udd3e denote a (multiplicative) cyclic group and g as a generator.\nThat is, \u2200 y \u2208\ud835\udd3e, \u2203 x \u2208 [0, |\ud835\udd3e| - 1] such that y = g^x.\nInformally, the discrete logarithmic (DL) problem states that if the carnality of \ud835\udd3e is sufficiently large,\nthen it is infeasible to find x in polynomial time even if both y and g are given.\nThis is a well-accepted assumption in most modern cryptographic schemes,\nsuch as ECDSA\u00a0<cit.> and ElGamal\u00a0<cit.>.\n\n\n\n  \nKnowledge of Clients\nWe assume that the clients are aware of the domain of the attribute on which the PSI is carried on.\nIn the context of PSI,\nwe are mostly interested in the categorical or discrete data\u00a0<cit.>,\nimplying that each client can represent its local items with a boolean vector,\nwhere each element is a boolean value indicating whether a specific item exists on the client.\n\n\n\n  \u00a7.\u00a7.\u00a7 Architecture\n\n\nWhile the full-fledged Prism deployment comprises four subsystems:\nclients (i.e., database owners), non-colluding servers, the oracle (initiator), and the announcer,\nthe PSI functionality can be completed through the first three subsystems, i.e., without the announcer.\n\n\n\n  \nClients (Database Owners)\nThe clients are the owners of the sensitive data that should be kept confidential from other clients.\nWe expect the clients are honest during the PSI procedure:\n(i) clients do not have the incentive to lie about their local data items for PSI and are not interested in probing or analyzing any intermediate results;\n(ii) clients are not compromised by adversaries without being detected, \nwhich can be enforced by digital signatures\u00a0<cit.> and Byzantine fault-tolerant protocols\u00a0<cit.>.\n\n\n\n  \nServers\nIn the PSI scheme of Prism, two servers are available and they do not collude. \nThis implies that the servers cannot be active adversaries;\nthat is, both servers are not malicious. \nHowever, servers are not trusted in the sense that they may behave as passive adversaries,\nmeaning that they could be interested in learning about the plaintexts from its involvement in the outsourced databases.\nBecause the data touched on by each of the two servers are random due to the protocol of generating secret shares,\neach server has no way to probe the plaintext and is thus information-theoretically secure.\n\n\n\n  \nOracle\nThe oracle is also called an initiator,\nwhose job is to set up the initial parameters for both the clients and the servers.\nFor example, two groups are required for Prism and it is the oracle that specifies the group order and generator.\nThe oracle is useful only at the beginning of the PSI scheme;\nif the context is clear, we will skip the oracle's initialization step and assume it has been done in the offline stage.\nIt should be noted that the oracle in Prism is not a conventional oracle that has been widely used in cryptography:\nin the latter case, \nan oracle usually refers to an entity whose functionality is \u201cideal\u201d and does not reveal any internal machinery, i.e., as a black box.\n\nFigure\u00a0<ref> illustrate the system model of PSI over multi-owner outsourced databases.\nWe assume there are four clients {C_0, C_1, C_2, C_3} and two non-colluding servers {S_0, S_1}.\nBefore the clients start outsourcing the local data,\nthe oracle sends parameters to clients and servers.\nThe clients then apply additive secret-sharing primitives to the local data and send them to both servers through a secure communication channel, such as OpenSSL\u00a0<cit.>.\nBoth servers execute a protocol to encode the secret shares and broadcast the encoded values back to all clients.\n\n\n\n\n\n  \u00a7.\u00a7.\u00a7 Protocols\n\n\n\n\n\n  \nInitialization\nThe oracle picks the parameters of two cyclic groups and broadcasts them to servers and/or clients.\nSome of those parameters (e.g., generator of the multiplicative group) should be kept confidential to the servers only such that the clients cannot learn about any information beyond the PSI.\nIn addition to the parameters, the oracle is also responsible for configuring the platform such as the host names and other metadata information.\n\n\n\n  \nVectorization of Attribute Domain\nEach client C_i generates a local vector,\nV_i, such that \u2200 v \u2208 V_i  v \u2208{0, 1}.\nA value v = 1 in V_i if and only if the corresponding item exists on C_i;\notherwise v = 0.\nIndeed, here we assume that all clients agree upon the same order of items in the domain of the attribute, denoted by A_c.\nOn straightforward approach to agreeing on the order of domain values is to take the alphanumeric order.\n\n\n\n  \nSecret Sharing\nEach client C_i splits its local vector V_i into two secret vectors, denoted by V_i^0 and V_i^1 that are to be sent to S_0 and S_1, respectively.\nOne requirement for the splitting is that the secrets must be additive,\nmeaning that V_i^b, b \u2208{0, 1}, must be able to reconstruct V_i by the addition operation on the secrets.\nThe additive property exploited by Prism is the modular addition defined in an additive group \u2124_p = {0, 1, \u2026, p-1}, \nwhere p denotes a large prime.\nThat is, given a plaintext v \u2208{0, 1}[Recall that the elements of a vector are all boolean values, 0 or 1.], \nwe randomly pick the first share v^0 \u2208 [0, m) and calculate the second share v^1 as follows:\n\n    v^1 \u2261 v - v^0  (mod p).\n\nIf we apply the above splitting to all elements of a local vector V_i,\nwe can generalize the above equation from scalars to vectors,\nin an element-wise fashion,\nas the following:\n\n    V_i^1 \u2261 V_i - V_i^0  (mod p).\n\n\n\n\n  \nAggregating Shares\nAfter server S_b receives all the secret shares V_i^b,\nb \u2208{0, 1} and 0 \u2264 i < m,\nS_b carries out a local aggregation over the secret shares from all clients C_i.\nThat is, server S_b computes a new vector V^b as follows:\n\n    V^b \u2261 -[m^b] + \u2211_i = 0^m-1 V_i^b  (mod p),\n\nwhere [m^b] denotes the extended vector (with the same length of V^b) of a secret share generated from the number of clients m, b \u2208{0, 1},\nin the same way we previously compute for v^b.\nThe operand of -m^b is added because we want to in later steps cancel out the value \u201c1\u201d in a vector that represents the existence of a shared attribute value.\n\n\n\n  \nEncoding Shares\nThe server should not simply send the locally aggregated shares back to the client because doing so would reveal the exact number of shared items among clients.\nInstead, the servers must somehow encode the partial shares such that the client cannot learn about the shared items except for the intersection.\nThe encoding scheme used by Prism unsurprisingly leverages the algebraic property of a homomorphic function Hom between two cyclic groups \ud835\udd3e = (G, +) and \u210d = (H, \u00d7) such that:\n\n    Hom: G    \u2192 H \n    \n            x    \u21a6 g^x  (mod q),\n\nwhere g is a generator and q is the order of the multiplicative group \u210d.\nIt is obvious that the function Hom() is homomorphic,\n\u2200 x_0, x_1 \u2208 G:\n\n    Hom(x_0) \u00d7 Hom(x_1) = g^x_0\u00d7 g^x_1 = g^x_0 + x_1 = Hom(x_0 + x_1).\n\nWe can then apply Hom() to the elements of V^b on server S_b.\nLet U^b denote the encoded vector in which each element is applied with the Hom() function.\nServer S_b broadcasts U^b to all clients.\n\n\n\n  \nCalculating PSI\nEach client receives two vectors U^0 and U^1 from two servers S_0 and S_1, respectively.\nThe client calculates the element-wise product of U^0 and U^1 without knowing the value of g\u2014the generator of the multiplicative group.\nLet n denote the cardinality of A_c's domain;\nif U^0 = (u^0_0, u^0_1, \u2026, u^0_n-1) and U^1 = (u^1_0, u^1_1, \u2026, u^1_n-1),\nthen we define the element-wise product as follows:\n\n    U = U^0 \u2299 U^1 (u^0_0 \u00b7 u^1_0, u^0_1 \u00b7 u^1_1, \u2026, u^0_n-1\u00b7 u^1_n-1).\n\nEvidently, \u2200 i \u2208 [0, n), u_i  u^0_i \u00b7 u^1_i = 1 if and only if the summation of secret shares of all clients equals m. \nIndeed, this is the criterion for detecting the intersection of the attribute values:\nonly those values whose encoding is 1 from all m clients should be included in the PSI.\nOn the other hand, if not all boolean ciphertexts are 1,\nthen u_i cannot be 1 implying that the i-th value of the attribute domain is not in PSI.\nFurthermore, because g is visible only to the servers,\nclients cannot learn about the exact number of clients who share the i-th value of the attribute domain.\n\n\n\n \u00a7.\u00a7 Security Analysis of Prism\n\n\n\n\n\n  \u00a7.\u00a7.\u00a7 High-Level Intuition\n\n\nWhile Prism hides the exact number of clients who share the i-th value of the attribute domain unless every client holds it,\nthis section will show that there is other information leaked from the Prism scheme.\nThe key insight is that the function of Eq.\u00a0(<ref>) is deterministic,\nimplying that repeated inputs lead to the same output.\nAs a result, if the same number of clients share a specific attribute value,\nthen Prism would leak such information to an adversary.\n\n\n\n  \u00a7.\u00a7.\u00a7 Chosen-Plaintext Attacks\n\n\n\n\n  \nSecurity Notion\nInformally, a Chosen-Plaintext Attack (CPA) refers to an attack where the adversary can distinguish the ciphertexts of two arbitrarily chosen plaintexts with a non-negligible probability,\neven after running the attack algorithms polynomial times in the security parameter, usually the bitstring length of the problem size, e.g., the cardinality of the attribute domain.\nA negligible function of argument n is defined as \n\n    negl(n)  o(n^-c),\n\nwhere c denotes any constant.\nThat is equivalent to:\n\n    \u2200 c > 0 lim_n \u2192\u221enegl(n)/n^-c = 0.\n\nThe formal proof of indistinguishability under CPA (IND-CPA) for a scheme \u03a0 usually takes a form of a simulation,\nwhere we assume that \u03a0 is not IND-CPA and use \u03a0 to construct a protocol that would solve an intractable problem,\nthus leading to a contradiction.\nIn the context of PSI, IND-CPA implies that all elements in U should look random except for 1,\nwhich indicates a shared attribute value.\nAn adversary can trivially break the IND-CPA of Prism in two rounds:\n\n    \n  * The adversary inserts a new attribute value x_n to all but the first client and retrieves the corresponding element in U, say u_n, from any client.\n    \n  * The adversary inserts a new attribute value x_n+1 to all but the first client and another new attribute value x_n+2 to all but the first two clients.\n    Similarly to the first round, the adversary retrieves two ciphertexts in U: u_n+1 and u_n+2.\n\nThe adversary can win the IND-CPA game with a probability of one by comparing u_n with u_n+1 and u_n+2.\nWhile it can be argued that the practicality of allowing the adversary to insert new attribute values into database owners is debatable,\nthe CPA security does consider the \u201cworst-case\u201d scenario.\nEven if this IND-CPA may be thought of as theoretical interest only,\nthe following section constructs a more practical attack.\n\n\n\n  \u00a7.\u00a7.\u00a7 Inference beyond PSI\n\n\nSuppose that each client computes the encoded vector U = (u_0, u_1, \u2026, u_n-1) from C_i, i \u2208 [0, m),\nwhere n denotes the cardinality of the attribute domain.\nWithout loss of generality, let 0 \u2264 i \u2260 j < n and u_i = u_j \u2260 1.\nThis means the i-th and the j-th values of attribute A_c are shared by up to m-1 clients.\nLet [\u00b7] denote the positional element of an array,\na specific client C_k can infer the following information:\n\n    \n  * If V_k[i] = V_k[j], C_k knows that A_c[i] and A_c[j] are equally \u201cpopular\u201d on all database owners. \n    \n  * If V_k[i] < V_k[j], i.e., V_k[i] = 0 and V_k[j] = 1, \n    then C_k knows that there is exactly one additional client who holds A_c[i] rather than A_c[j].\n    Depending on the applications,\n    such information might introduce bias or unfairness,\n    e.g., in a market of competitors.\n    \n  * If V_k[i] > V_k[j], client C_k can infer similar information that is symmetric to the second case above.\n\nEvidently, any of the above three scenarios does reveal some information beyond the intersection of items among the clients.\n\n\n\n \u00a7.\u00a7 CPA Attack on Prism\n\n\n\nThis section demonstrates a running example of Prism's PSI protocol and attacks on it.\n\n\n\n  \u00a7.\u00a7.\u00a7 System Configuration\n\nWe assume m = 4,\ni.e., there are four clients, C_i, 0 \u2264 i < 4.\nIf not otherwise stated, let b {0, 1},\ni.e., b is assigned 0 or 1 with 50% probability[In the literature of cryptography, it is also common to use $, _R, or other varieties to denote the same thing.].\nThere are a fixed number of non-colluding servers;\nfor simplicity, two servers are available: S_0 and S_1.\nLet the additive group \ud835\udd3e = (\u2124_5, +) and the multiplicative group \u210d = (\u2124_11^*, \u00d7) and g=3 as a generator of a subgroup of \u210d.\nNote that the aforementioned parameters are taken for the sake of explanation;\nthey are usually much larger in practice to be resilient to brute-force attacks.\n\n\n\n  \u00a7.\u00a7.\u00a7 Schema and Data\n\n\n\n\n  \nSchema and Metadata\nFor simplicity, we assume that all of the four clients hold their local relations of a single-attribute schema.\nSince there is only a single attribute, \nwe can safely represent the column of the relationship as a vector.\nLet's also assume the data type of the single attribute is an integer in the semi-open interval [0, 5).\nWe use n to denote the cardinality of the attribute domain,\ni.e., n = 5 in our example.\nThis means that although each client could store an arbitrary number of values,\nthe length of each plaintext vector is 5, \ni.e., |V_i| = 5, 0 \u2264 i < 4.\n\n\n\n  \nData\nLet R_i denote the single-attribute relation on client C_i as a list:\n\n    R_0 = (0, 1, 3) \n    \n    R_1 = (1, 3, 4) \n    \n    R_2 = (3, 4, 4) \n    \n    R_3 = (1, 2, 3, 4)\n\nThe goal of PSI is for every C_i to find out the commonly shared item,\nin this case integer 3.\n\n\n\n  \u00a7.\u00a7.\u00a7 Vectorization\n\nThe plaintext data on four clients in Eq.\u00a0(<ref>) can be vectorized to the following:\n\n    V_0 = (1, 1, 0, 1, 0) \n    \n    V_1 = (0, 1, 0, 1, 1) \n    \n    V_2 = (0, 0, 0, 1, 1) \n    \n    V_3 = (0, 1, 1, 1, 1)\n\nThe elements that should be included in the PSI are those values whose positional vector elements are one.\nIn our example, the only element satisfying this is integer 3.\nIf we denote the PSI as a function over the set of relations, \nwe have\n\n    PSI(\u211b) = {3},\n\nwhere \u211b{R_i}, 0 \u2264 i < m.\nWe also introduce another parameterized function Card(\u00b7, k),\nwhich returns the set of attribute values that are shared by k clients:\n\n    Card: R^m \u00d7\u2124_m    \u2192 2^A_c\n    (\u211b, k)   \u21a6{y  |  y \u2286 A_c},\n\nwhere R denotes an arbitrary vector of integers between 0 and n and R^m denotes the cross-product m times over R.\nFor simplicity, we sometimes place the second parameter in the subscript,\ni.e., Card_k(\u00b7)  Card(\u00b7, k).\nBy definition, it is evident that PSI(\u211b) is a special case of Card_k(\u211b),\ni.e., PSI(\u211b) \u2261 Card_|\u211b|(\u211b).\nWith this notation, \nwe can write the following for our example:\n\n    Card_0(\u211b) = \u2205\n    \n    Card_1(\u211b) = {0, 2}\n    \n    Card_2(\u211b) = \u2205\n    \n    Card_3(\u211b) = {1, 4}\n    \n    Card_4(\u211b) = {3}\n\nWe notice that the cardinality of some Card_k() is equal,\nsuch as |Card_1(\u211b)| = |Card_3(\u211b)| = 2.\nAs we will see later, this will reveal information that can be exploited by the adversary.\n\n\n\n  \u00a7.\u00a7.\u00a7 Secret Sharing\n\n\nRecall that the client relies on the additive group \ud835\udd3e = (\u2124_5, +) for additive secret sharing, \nas discussed in\u00a0<ref>.\nTherefore, the V's in Eq.\u00a0(<ref>) can be split into the following:\n\n    V_0^0 = (3, 4, 1, 2, 0);   V_0^1 = (3, 2, 4, 4, 0)\n    \n    V_1^0 = (1, 2, 4, 3, 4);   V_1^1 = (4, 4, 1, 3, 2)\n    \n    V_2^0 = (0, 4, 2, 3, 1);   V_2^1 = (0, 1, 3, 3, 0)\n    \n    V_3^0 = (2, 3, 4, 1, 0);   V_3^1 = (3, 3, 2, 0, 1)\n\nIt can verified that V_i = V_i^0 + V_i^1 in \ud835\udd3e, 0 \u2264 i < 4.\nClient C_i then sends V_i^0 to server S_0 and V_i^1 to server S_1.\n\n\n\n  \u00a7.\u00a7.\u00a7 Server Encoding\n\nEach of the two servers receives m = 4 vectors of shares.\nThat is, server S_b receives V_i^b, b \u2208{0, 1}, 0 \u2264 i < m.\nAs specified in Eq.\u00a0(<ref>),\nm should be split as well on \ud835\udd3e.\nIn this example, let m^0 = 1 and m^1 = 3.\nTherefore, the first element of the aggregated vector V^0 on S_0 can be calculated as\n\n    V^0[0] = -m^0 + \u2211_i=0^3 V_i^0 = -1 + (3 + 1 + 0 + 2) \u2261 0  (mod 5).\n\nSimilarly, we can compute both aggregated vectors\n\n    V^0 = (0, 2, 0, 3, 4)\n    \n        V^1 = (2, 2, 2, 2, 0)\n\nThe two servers then apply Eq.\u00a0(<ref>) to V^b and generated two new vectors (note that q = 11 in our example):\n\n    U^0 = (1, 9, 1, 5, 4)\n    \n        U^1 = (9, 9, 9, 9, 1)\n\nBoth servers then broadcast U^b to all clients.\n\n\n\n  \u00a7.\u00a7.\u00a7 Client Decryption\n\n\nAll clients receive two vectors U^b from both servers.\nEach client computes the element-wise multiplication of U^b under group \u210d, i.e., modular 11.\nFor example,\n\n    U^0[1] \u00d7 U^1[1] = 9 \u00d7 9 = 81 \u2261 4  (mod 11),\n\nand \n\n    U^0[3] \u00d7 U^1[3] = 5 \u00d7 9 = 45 \u2261 1  (mod 11).\n\nThe final vector on each client is therefore \n\n    U = (9, 4, 9, 1, 4).\n\nAll clients at this point know that the fourth value of A_c is shared by all clients because U[3] = 1 and have no idea about how many other clients hold what other values because those encrypted values are meaningless due to Eq.\u00a0(<ref>).\n\n\n\n  \u00a7.\u00a7.\u00a7 Information Leakage\n\nAll clients learn that U[0] = U[2] = 9.\nLet's see what client C_0 can learn from this.\nRecall that client C_0 knows its local vector,\ne.g., V_0[0] = 1 and V_0[2] = 0.\nThis means that C_0 can infer the following fact:\nthere must be at least one client C_j, j \u2260 0, \nsuch that V_j[2] = 1,\nbecause otherwise U[0] cannot equal U[2].\nThat is, by following the Prism PSI scheme C_0 learns that the integer \u201c2\u201d exists on at least one of the other three clients, although \u201c2\u201d is not shared by all of the four clients (because U[2] = 9 \u2260 1).\n\n\n\n\u00a7  PSI\n\n\n\nTo fix the information leakage of Prism PSI, \nwe design a new PSI scheme called Kaleido for multi-owner databases.\nAs the name suggests, Kaleido introduces disorder to the PSI calculation among multi-owner databases and therefore is considered \u201cgarbled\u201d Prism.\nThe key idea of Kaleido is fairly simple:\ninstead of using a fixed generator,\nlet's randomize it such that the encoded shares on the server cannot be distinguished even for the same inputs.\nThe technical challenge of applying this idea is to ensure both the correctness and the security of PSI.\n\n\n\n \u00a7.\u00a7 Server Protocol of Kaleido\n\n\n\n\n\n  \nDescription\nWe elaborate on the randomness introduced by Kaleido servers in Algorithm\u00a0<ref>.\nLines 1 \u2013 7 simply aggregate the secret shares sent by all clients and subtract the secret share of the number of clients m.\nLine 10 ensures that \n(i) the output of the parameterized function is indistinguishable from a random string, and\n(ii) the output is identical on both S_0 and S_1 because the secret key k is agreed upon between both servers.\nIn practice, PRF_k(\u00b7) can be implemented by a block cipher,\nsuch as AES\u00a0<cit.>.\nKaleido then maps the randomized output to an element in the group \u210d,\nwhich is done in Line 11.\nAs in Line 10, both S_0 and S_1 generate the same g because \u210d is revealed to both servers.\nLines 12\u201314 ensure that g is a generator of a (sub)group of order p.\nNote that we use |g| (Line 12) to denote the order of g in the cyclic group rather than the absolute value of scalar g in arithmetic.\nOn Line 15, the elevated value in group \u210d replaces the element in the group \ud835\udd3e.\nLine 16 ensures that even the same elements in \ud835\udd3e map to distinct elements in \u210d due to different values of ct and g.\nServer S_b finally broadcasts its local encoding V^b to all clients,\nas shown in Line 18.\n\n\n\nFigure\u00a0<ref> illustrates a simple example where both servers take an initial vector (IV) to randomly encode the secret shares submitted by clients.\nIntuitively, because both servers parameterize the pseudorandom function PRF(\u00b7) with the same key k initialized by the oracle at the beginning of the execution,\nthe base number g (cf. Line 11, Alg.\u00a0<ref>) is identical on both servers and yet look random in different rounds.\n\n\n\n\n\n  \nComplexity\nSuppose the cost of computing PRF(\u00b7) is c.\nLines 2 \u2013 7 take \ud835\udcaa(nm).\nLines 9 \u2013 17 take \ud835\udcaa(nqc).\nTherefore, the overall computational complexity of Alg.\u00a0<ref> is \ud835\udcaa(nm+nqc).\nThe overall number of messages is straightforward:\nLine 18 incurs m messages.\nSince there are two servers,\nthe overall number of network messages is 2m.\nThe overall number of communication rounds is 1,\nalso incurred by Line 18 (assuming broadcasting is implemented as an asynchronous primitive).\n\n\n\n \u00a7.\u00a7 Correctness of Kaleido\n\n\nWe need to show that U[i] = 1, 0 \u2264 i < n, if and only if V_j[i] = 1, 0 \u2264 j < m.\n\n\n\n  \u00a7.\u00a7.\u00a7 V_j[i] = 1  U[i] = 1\n\n\nIf V_j[i] = 1,\nrecall that this means the j-th client holds the i-th positional value of attribute A_c.\nLet g_i denote the i-th base of elevation,\nas shown in Line 12 of Alg.\u00a0<ref>.\nAs discussed in\u00a0<ref>,\ng_i is identical for both S_0 and S_1.\nAccording to Eq.\u00a0(<ref>), the following holds\n\n    U[i]       \u2261 U^0[i] \u00d7 U^1[i]  (mod q)\n        = g_i^V^0[i]\u00d7 g_i^V^1[i]\n       \u2261 g_i^V^0[i] + V^1[i]  (mod p)\n        = g_i^ - m^0 - m^1 + \u2211_j=0^m-1 V_j[i]\n        = g_i^ - m + \u2211_j=0^m-1 1\n        = g_i^0\n        = 1.\n\n\n\n\n  \u00a7.\u00a7.\u00a7 U[i] = 1  V_j[i] = 1\n\n\nIf U[i] = 1, then according to Eq.\u00a0(<ref>),\nthe following equality must hold:\n\n    - m^0 - m^1 + \u2211_j=0^m-1 V_j[i] = 0,\n\nor equivalently:\n\n    \u2211_j=0^m-1 V_j[i] = m.\n\nRecall that V_j[i] \u2208{0, 1}, cf. Eq.\u00a0(<ref>).\nTherefore, the only way to satisfy the above equation is V_j[i] = 1, 0 \u2264 j <m,\nwhich is desired.\n\n\n\n \u00a7.\u00a7 Provable Security of Kaleido\n\n\nWe claim that the PSI scheme backed by Alg.\u00a0<ref> is IND-CPA except for the attribute values shared by all clients.\nThis means that the adversary is not allowed to query the servers to return the ciphertext of an attribute value that is shared by all clients.\nWe formulate the above in the following proposition.\n\n\nIf the PRF(\u00b7) function in Alg.\u00a0<ref> is indistinguishable from an ideal random number generator,\nthe elements of U generated by V^b in Alg.\u00a0<ref>, \nb \u2208{0, 1}, \nare provably secure in the IND-CPA security model.\n\n\n\nLet \ud835\udc9c denote the adversary who can break the security of Alg.\u00a0<ref>.\nWe write MOD^CPA_\ud835\udc9c,  Kaleido to denote the private-set-intersection (PSI) experiment in Multi-Owner Databases (MOD):\n\n    \n  * \ud835\udc9c outputs two attribute values x_0 and x_1 in \ud835\udd3e such that there exists at least one client that does not hold x_0 or x_1, respectively;\n    \n  * Kaleido servers agree upon a value b \u2208{0, 1}, run Alg.\u00a0<ref>, and send Enc(x_b) to \ud835\udc9c;\n    \n  * \ud835\udc9c outputs b' \u2208{0, 1};\n    \n  * The output of the experiment is defined to be 1 if b' = b, and 0 otherwise. We write MOD^CPA_\ud835\udc9c,  Kaleido = 1 if the output of the experiment is 1 and \ud835\udc9c is said to be successful.\n\n\n\n\n\n\n\nLet g_0 and g_1 denote the bases of x_0 and x_1, \nrespectively, as specified in Line 12 of Alg.\u00a0<ref>.\nWe consider two cases: (i) g_0 \u2260 g_1 and (ii) g_0 = g_1.\n\n    \n  * If g_0 \u2260 g_1, we have \n    \n    Pr[MOD^CPA_\ud835\udc9c,  Kaleido = 1  |  g_0 \u2260 g_1] = 1/2,\n\n    because the best \ud835\udc9c can do is a random guess of b.\n    According to elementary probability theory, \n    we also know that the following holds:\n    \n    Pr[MOD^CPA_\ud835\udc9c,  Kaleido = 1 \u2227 g_0 \u2260 g_1] \u22641/2.\n\n    \n    \n  * If g_0 = g_1, since PRF(\u00b7) is indistinguishable from a random generator,\n    the following equality holds:\n    \n    Pr[g_0 = g_1] = 1/2^\u03bb.\n\n    It follows that \n    \n    Pr[MOD^CPA_\ud835\udc9c,  Kaleido = 1 \u2227 g_0 = g_1] \u22641/2^\u03bb.\n\n\n    \nCombining Eqs.\u00a0(<ref>) and\u00a0(<ref>),\nwe have\n\n    Pr[MOD^CPA_\ud835\udc9c,  Kaleido = 1] \u22641/2 + 1/2^\u03bb = 1/2 + negl(\u03bb),\n\nimplying that \ud835\udc9c cannot succeed significantly better than a random guess,\nwhich completes the proof.\n\n\n\n\n \u00a7.\u00a7 Case Study of Kaleido\n\nWe revisit the example discussed before in\u00a0<ref> to illustrate the effectiveness of the proposed Kaleido PSI.\nRecall that the probability of having g_i = g_j, i \u2260 j, \nis negligible.\nLet's assume that g_i equals i+2  %  11.\nFor example, U^0[3] is calculated as\n\n    U^0[3] = (3+2  %  11) ^ V^0[3] %  11 = 5^3  %  11 = 4,\n\nand U^1[3] is calculated as\n\n    U^1[3] = (3+2  %  11) ^ V^1[3] %  11 = 5^2  %  11 = 3.\n\nFollowing the above algorithm, U^b can be calculated as:\n\n    U^0 = (1, 9, 1, 4, 9)\n    \n    U^1 = (4, 9, 5, 3, 1)\n\nConsequently, the Kaleido PSI U is:\n\n    U = (4, 4, 5, 1, 9).\n\nWe see that U[3] = 1 still implies that the fourth positional value of A_c is shared by all clients,\nwhich is desired.\nHowever, the equality or inequality between other values does not reveal the number of clients sharing the values.\nFor example, although U[0] = U[1] = 4,\nit does not indicate that integers \u201c0\u201d and \u201c1\u201d are shared by the same number of clients;\nin fact, \u201c0\u201d is hold only by C_0 and \u201c1\u201d is held by all clients but C_2.\nSimilarly, although U[0] \u2260 U[2] = 5, \nit does not mean that integers \u201c0\u201d and \u201c2\u201d are not shared by the same number of clients\u2014both are indeed shared by the same number of clients (a single client C_0 for \u201c0\u201d and a single client C_3 for \u201c2\u201d).\n\n\n\n\u00a7 EVALUATION\n\n\n\n\n\n \u00a7.\u00a7 System Implementation\n\n\nWe have implemented the proposed Kaleido scheme with about 1,000 lines of Python code and Bash script,\nwhich will be released at\n<https://github.com/>.\nWe choose the lightweight SQLite as the local database instance.\nNote that SQLite is a file-based database and does not support network access.\nWe thus implement a communication layer among remote SQLite instances through the paramiko library for secure data transfer and remote query invocation.\nSome of the most important libraries and dependencies include:\npython 3.8.0,\nsqlite 3.31.1,\nnumpy 2.21.0,\nparamiko 2.12.0,\nscp 0.14.4, \nand cryptography 39.9.0.\n\n\n\n \u00a7.\u00a7 Experimental Setup\n\n\n\n\n  \u00a7.\u00a7.\u00a7 Test Bed\n\n\nWe deploy Kaleido and other baseline schemes alone with SQLite\u00a0<cit.> on a 34-node cluster hosted at CloudLab\u00a0<cit.>.\nEach node is equipped with two 32-core Intel Xeon Gold 6142 CPUs, 384 GB ECC DDR4-2666 memory, and \t\ntwo 1\u00a0TB SSDs.\nThe operating system image is Ubuntu 20.04.3 LTS,\nand the page size is 4 KB.\nAll servers are connected via a 1 Gbps control link (Dell D3048 switches) and a 10 Gbps experimental link (Dell S5048 switches).\nWe only use the experimental links for our evaluation.\n\nSpecifically, we name the 34 nodes in the cluster as node0\u2013node33.\nThe two servers run on node0 and node1,\nand the database owners (i.e., clients) are deployed on node2\u2013node33.\nAll 34 nodes are enabled with password-less SSH connection for convenient communication since our evaluation focuses on performance metrics rather than security measurement. \n\n\n\n\n\n\n\n\n\n\n\n  \u00a7.\u00a7.\u00a7 Systems under Comparison\n\n\nFor all the systems under comparison, the orders of the additive and multiplicative groups are 113 and 227, respectively.\n\n\n\n  \nPrism\nPrism\u00a0<cit.> assigns a static generator during the server encoding.\nAs discussed in prior sections, \nPrism can leak information other than the PSI,\nsuch as which items are shared by the same number of clients.\nHowever, because the generator is fixed,\nPrism incurs no extra cost for randomizing the ciphertext,\nwhich leads to the highest performance compared with the schemes proposed in this paper.\n\n\n\n  \nKaleido-RND (Naive Randomness)\nOne straightforward way to resolve static generators in Prism is to randomly pick a generator,\nwhich we refer to as Kaleido-RND.\nThis requires that both servers synchronize the random seeds and therefore incur server-to-server communication,\nwhich is against the assumption that the PSI servers should be non-colluding.\nMoreover, we are unaware of an effective model to formally prove the security of this scheme.\n\n\n\n  \nKaleido-AES (Provably Secure)\nWe chose AES-128\u00a0<cit.> to implement the pseudorandom function in our Kaleido prototype system.\nPKCS7 is used for padding the plaintext data and the cipher block chaining (CBC) mode is adopted for the AES cipher.\nThe initial vector (IV) is set to 1234.\n\n\n\n\n  \u00a7.\u00a7.\u00a7 Workloads\n\n\n\n\n  \nTPC-H Benchmark\nThe synthetic data set is TPC-H version 3.0.0\u00a0<cit.>, a standard database benchmark.\nThere are overall eight tables in TPC-H;\nin our evaluation, we select the LineItem table\u2014the same one used in Prism\u00a0<cit.>,\nwhich comprises 6,001,215 tuples.\nThe attribute that we will focus on is L_ORDERKEY,\nwhich consists of 1,500,000 distinct values.\nEach database owner, i.e., the client, \nrandomly select 5,000,000 values from the L_ORDERKEY attribute,\nand the PSI goal is to find out those L_ORDERKEY values shared by the set of clients.\n\n\n\n  \nCOVID-19 Patient Record\nThe first application is the U.S. national COVID-19 statistics from April 2020 to March 2021\u00a0<cit.>.\nThe data set has 341 days of 16 metrics, such as death increase, positive increase, and hospitalized increase.\nEach client randomly selects 300 days of data as their local data.\n\n\n\n  \nBitcoin Trade History\nThe second application is the history of Bitcoin trade volume\u00a0<cit.> since it was first exchanged in the public in February 2013.\nThe data consists of the accumulated Bitcoin exchange on a 3-day basis from February 2013 to January 2022,\ntotaling 1,086 large numbers.\nEach client randomly selects 1,000 trade data points in their local database.\n    \n\n\n  \nHuman Gene #38 Sequence\nThe third application is the human genome reference 38\u00a0<cit.>, \ncommonly known as hg38,\nwhich includes 34,424 rows of singular attributes,\ne.g., transcription positions, coding regions, and number of exons, last updated in March 2020.\nEach client randomly selects 30,000 rows in its local data set.\n    \n\n\n \u00a7.\u00a7 Performance\n\n\n\n\n  \u00a7.\u00a7.\u00a7 TPC-H Benchmark\n\n\n\n\n  \nServer Encoding\nFigure\u00a0<ref> reports the encoding performance of various schemes.\nWe compare the server processing time of all three schemes when serving different numbers of clients ranging from 2 to 32.\nUnsurprisingly, Prism achieves the highest performance because of the fixed generator g.\nKaleido-RND is slightly slower than Prism because of the communication between the two servers and the randomization cost on both servers.\nKaleido-AES introduces about 500 seconds overhead for encoding five million tuples;\nthis is the cost for ensuring the semantic security of PSI over multi-owner databases.\nPlease note that the overhead is a computational cost,\nwhich can be reduced by parallel processing that has not been explored in this work.\n\n\n\n\n\n  \nClient Computation\n\nIn our implementation, the work on the client can be broken into four stages:\n(i) Load the data from the local SQLite database,\n(ii) Hash the raw value and map it to a binary flag,\n(iii) Split the binary flag into two additive secret shares,\nand (iv) Recover the PSI result from two encoded vectors from servers.\nTable\u00a0<ref> reports the time consumption for each of the above four stages.\nWe observe that the most costly stage is Split,\nwhich takes almost 10 seconds.\nAgain, this can be parallelized with multiple CPU cores because the elements in the vector are independent,\nwhich we will explore in our future work.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \nI/O Cost\n\nTable\u00a0<ref> reports the local I/O cost on both clients and servers.\nNote that the numbers are for individual clients or servers,\ne.g., each client persists a vector of 15 MB in size\u2014the total I/O overhead of the entire system is thus 15 \u00d7 m MB, \nwhere m denotes the number of database owners (clients).\n\n\n\n\n\n  \nCommunication Cost\nFigure\u00a0<ref> reports the communication time spent on different numbers of clients.\nWe observe that the upstream communication is almost constant when scaling out the number of clients;\nhowever, the downstream traffic takes proportionally more time when more clients are involved.\nWhen the number of clients is sufficiently large,\ne.g., 32,\nserver-to-client communication takes more time than the other direction.\n\n\n\n\n\n  \u00a7.\u00a7.\u00a7 Applications\n\n\nDue to limited space, we only report the performance of these three applications on client scales: \ntwo, four, and eight.\nWe observe that in these real-world applications,\nthe performance overhead lies in communication:\nboth the client and the server spend most of their time sending the vectors,\norders of magnitude more than other stages.\n\n\n\n  \nCOVID-19\n\nFigure\u00a0<ref> reports the stage-wise performance of Kaleido and Prism on the COVID-19 data.\nFor clients, we observe that the communication from clients to serves dominates the cost.\nFor servers, again, the communication from servers to clients takes the majority of the overall cost,\nand the portion increases when more clients are involved.\nAs a result, although the cryptographic cost introduced by Kaleido is significant from the computational perspective,\nthe real bottleneck of the entire system lies in communication.\nIn fact, the computational cost of the cryptographic component can be further reduced (not explored in this work). \n\n\n\n\n\n  \nBitcoin\n\nFigure\u00a0<ref> reports the performance of the Bitcoin trade history.\nWe observe a similar pattern to the COVID-19 data.\nEven more evidently, the numbers show that server communication dominates the overall cost on the server side:\nWhen working with only two clients, \nthe communication time of the servers takes 10x more time than the cryptographic component (i.e., AES\u00a0<cit.>).\nThese results reaffirm the practicality of the proposed Kaleido scheme:\nAlthough the cost is significantly more than the naive random method,\nthe cost is an order of magnitude lower than the communication time.\n\n\n\n\n\n  \nHuman Gene #38 Sequence\n\nFigure\u00a0<ref> reports the performance on a larger data set\u2014over 30,000 human gene #38 sequence.\nWe observe that the server exhibits roughly the same performance as the previous two data sets;\nhowever, the clients are more occupied this time.\nThis is understandable as the clients in this case must work on more data items regarding their local databases.\n\n\n\n\n\n\u00a7 RELATED WORK \n\n\nThis section reviews three other important techniques for ensuring the confidentiality of outsourced databases.\nAll of these techniques are orthogonal to the secret-share-based schemes (e.g., Prism, Kaleido).\n\n\n\n \u00a7.\u00a7 Encrypted Storage\n \nThe database instance from the cloud vendor is considered as storage of encrypted data and the client is responsible for nontrivial queries.\nThis solution is viable only if (i) the relations touched on by the query are small enough that the network overhead of transmitting those relations is acceptable, and (ii) the user has the capability (both computation and storage) to execute the query locally.\nWe stress that this solution might defeat the purpose of outsourcing the database service to the cloud.\n    \n\n\n \u00a7.\u00a7 Encrypted Tuples\n \n\nEvery tuple of the original relation R is encrypted into a ciphertext that is stored in column T of a new relation R^s.\nFor each attribute A_i in R, there is a corresponding attribute A_i^s in R^s, whose value is the index of R.A_i.\nThe index is usually assigned by a random integer based on some partitioning criteria and can be retrieved with the metadata stored on the client, i.e., the user's local node.\nAs a result, the schema stored at the cloud provider is R^s(T, A_1^s, \u2026, A_i^s, \u2026).\nWhen the user submits a query Q, the client splits Q into two subqueries Q_s and Q_c.\nQ_s serves as a filter to eliminate those unqualified tuples based on the indices in R^s and transmits the qualified tuples (in ciphertexts) to the client.\nQ_c then ensures that those false-positive tuples are eliminated after the encrypted tuples are decrypted using the secret key presumably stored on the client.\nThis approach involves both the client (i.e., the user) and the server (i.e., the cloud provider) when completing a query, often referred to as information hiding approaches\u00a0<cit.>.\n    \n\n\n \u00a7.\u00a7 Encrypted Fields\n \n\nThe third approach aims to minimize the involvement of clients when processing the query over the encrypted data stored at the cloud vendor.\nThe idea is to encrypt the relations at a finer granularity\u2014each attribute of a relation is separately encrypted.\nThe key challenge of this approach lies in its expressiveness,\ne.g., how to apply arithmetic or string operations over the encrypted fields.\nWhile fully homomorphic encryption (FHE)\u00a0<cit.> can support a large set of computing problems,\nthe performance of current FHE implementations cannot meet the requirements of practical database systems\u00a0<cit.>.\nAn alternative solution is a partially homomorphic encryption (PHE) schemes\u00a0<cit.>,\nwhich are orders of magnitude faster than FHE but only support a single algebraic operation.\nTraditional PHE schemes are designed for public-key (asymmetric) encryption,\nwhich is desirable for straightforward key distribution over insecure channels but significantly more expensive than secret-key (symmetric) encryption.\nHowever, in the context of outsourced databases, \nthe user usually serves as both the sender and the receiver and there is no need to distribute the key.\nTo this end, symmetric (partially) homomorphic encryption, was proposed\u00a0<cit.>.\n\n\n\n\n\n\n\n\n\n\n\n\n\u00a7 CONCLUSION AND FUTURE WORK\n\n\nThis paper first demonstrates a security vulnerability of a state-of-the-art PSI scheme, Prism, in outsourced databases.\nThe paper then proposes a series of new primitives, namely Kaleido, to extend Prism such that the new PSI scheme is semantically secure.\nBoth the correctness and security are formally proven,\nand the intuition is explained with a running example.\nA system prototype of Kaleido is implemented and deployed to two servers and 32 database owners hosted at CloudLab\u00a0<cit.>.\nExtensive experiments on the TPC-H benchmark and three real-world applications confirm the effectiveness of the proposed Kaleido schemes.\n\nOur future work is two-fold.\nFirst, we will leverage the underlying multiple/many CPU cores to parallelize the costly cryptographic operations in Kaleido.\nThe challenge lies in how to ensure the multiple (non-colluding) servers do not communicate and yet stay synchronized regarding the randomized group generators.\nSecond, we will adopt some compression schemes to reduce the vectors,\ngenerated by both the clients and the servers,\nsuch that the communication cost can be reduced.\nThe challenge of the second research direction lies in the balance between the computational cost for compressing and decompressing the vectors and the communication saving out of the compressed vectors.\n\n\nplain\n\n\n\n\n\n"}