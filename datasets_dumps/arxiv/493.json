{"entry_id": "http://arxiv.org/abs/2303.13531v1", "published": "20230312110540", "title": "Discovering Hierarchical Process Models: an Approach Based on Events Clustering", "authors": ["Antonina K. Begicheva", "Irina A. Lomazova", "Roman A. Nesterov"], "primary_category": "cs.AI", "categories": ["cs.AI"], "text": "\nFrequency-dependent Discrete Implicit Monte-Carlo Scheme for the Radiative Transfer Equation\n    Shay I. Heizler0000-0002-9334-5993\n    \n============================================================================================\n\n\n\n\n\nProcess mining is a field of computer science that deals with  discovery and analysis of process models based on automatically generated event logs. \nCurrently, many companies use this technology for  optimization and improving their processes. \nHowever, a discovered process model may be too detailed, sophisticated and difficult for experts to understand. \nIn this paper, we consider the problem of discovering a hierarchical business process model from a low-level event log, i.e., the problem of automatic synthesis of more readable and understandable process models based on  information stored in  event logs of information systems. \n\nDiscovery of better structured and more readable process models is intensively studied in the frame of process mining research from different perspectives. \nIn this paper, we present an algorithm for discovering hierarchical process models represented as two-level workflow nets. The algorithm is based on  predefined event clustering  so that the cluster defines a sub-process corresponding to a high-level transition at the top level of the net. \nUnlike existing solutions, our algorithm does not impose  restrictions on the process control flow and allows for concurrency and iteration.\n\n\n\nKeywords:\n\nprocess mining; Petri nets; workflow nets; process discovery; hierarchical process model; event log\n\n\n\n\n\n\n\n\n\n\n\u00a7 INTRODUCTION\n\n\nOver the past decade, companies whose processes are supported by various information systems have become convinced of the need to store as much potentially useful information about the execution of processes within the system as possible. This was facilitated by the qualitative development of areas related to the extraction of valuable information from recorded data, which helps to correct the work of organizations in time and, thus, save and increase their resources. Process mining is a field of science that provides a palette of tools for extracting the logic of system behavior, as well as modeling and optimizing the processes occurring in it. In particular, process mining methods allow you to find inconsistencies between the planned and actual behavior of the system, and also timely track the appearance of inefficient or incorrect behavior.  \n\n\nDespite the fact that more and more attention is being paid to preserving the optimal amount of necessary information about the execution of processes, process execution data is not always available in a convenient format and with the necessary degree of detail, since system logs are generated automatically. Process discovery is aimed at extracting processes from event logs and their representation in the form of a model.  Most of the available process discovery methods provide a model with the same level of detail as a given event log <cit.>. \n\n\nBecause of this, a promising area for research is the task of discovering a more readable process model from a detailed event log, while preserving important information about the process execution for experts. Readability can be provided in various ways. The most commonly used methods are filtering rare behavior from the original event log, skipping \"minor\" events (the significance of an event is assessed according to the chosen methodology), and abstraction, where some events are considered indistinguishable from each other. In our study, we consider the latter approach, when more readable models are the result of model abstraction \u2014 they are more compact and have an optimal level of detail for the work of experts than what could be obtained by  direct discovery methods.\nIn order not to lose important information, we are dealing not only with abstract (high-level) models, but also with hierarchical models that store low-level information in the form of sub-processes.\n\nThus, in this paper, we propose an algorithm for discovering hierarchical process models from event logs. Processes are modeled with workflow nets <cit.>, a special subclass of Petri nets for modeling a control flow of business processes. This study continues our previous study \n<cit.>, in which we have proposed an approach to discover abstract models for processes without cycles.\nHere we provide a more general solution by overcoming the prohibition of  cyclic behavior. \n\nHierarchical models allows us to have a high-level view of the model by \u201cfolding\u201d  the behavior of an individual  sub-process  into a high-level transition  with the ability to unfold it back. \nSo, at the top level there is a high-level model, in which each individual transition corresponds to a sub-process built from low-level events.\nThe history of the detailed behavior of the process is recorded in a low-level log. \nRegarding the number of levels in the hierarchy, we will only use two levels \u2014 high and low, but the algorithm can naturally be extended to any number of levels.\n\nThe paper is structured as follows. Section 2 presents the review of related research. \nSection 3 gives theoretical preliminaries and definitions used in the text. \nIn Section 4, we discuss the basics of the hierarchical process discovery algorithm. \nSection 5 presents the main discovery algorithm and the proof of its correctness. \nSection 6 reports the outcomes from the experimental evaluation. \nIn Section 7, we conclude the paper and discuss the possible future work directions. \n\n\n\n\n\n\n\u00a7 RELATED WORK\n\n\nResearch connected with our paper can be classified into approaches to abstracting event logs and process models and approaches to discovering hierarchical process models from event logs.\n\nThe recent work <cit.> gives a comprehensive review of approaches and methods that can be applied for low-level events abstraction.\nThe authors divide the methods according to: the learning strategy (supervised or unsupervised), the structure of the process models (strictly sequential or with interleaving), the low-level events grouping approach (deterministic or probabilistic), the nature of the processed data (discrete or continuous data). \nFor instance, the method presented in <cit.> is a supervised method that converts a low-level event log into its high-level representation using detected behavioral patterns, such as sequence, selection, parallelism, interleaving and repetition.\n\nA supervised approach to event abstraction was also presented in <cit.>.\nThis method takes a low-level event log and transforms it to an event log at the desired level of abstraction, using behavioral patterns: sequence, choice, parallel, interleaving and repetition of events.\nThis technique allows us to obtain a reliable mapping from low-level events to activity patterns automatically and construct a high-level event log using these patterns.\nAnother supervised event abstraction method was discussed in <cit.>. \nThe nature of this method is as follows.\nWe annotate a low-level event with the correct high-level event using the domain knowledge from the actual process model by the special attribute in an event log. \nIn addition, this paper assumes that multiple high-level events are executed in parallel. \nThis allows us to interpret a sequence of identical values as the single instance of a high-level event. \n\nA general approach to the representation of multi-level event logs and corresponding multi-level hierarchical models was studied in <cit.>.\nThe authors especially note that this approach can combine multiple formalisms for representing different levels in a multi-level process models.\n\nThere are many ways of abstracting process models by reducing their size in order to make them more convenient to work with. \nEach method may be useful depending on a group of interrelated factors: the abstraction purposes, the presence of certain patterns and constructs, and the specifics of modeling notation. \nReducing the size of the model by abstraction can be done as the \u201cconvolution\u201d of groups of elements, or implemented by throwing some parts away (insignificant in a particular case). \nThe importance of the low-level event log abstraction is emphasized, among the others, in <cit.>. \n\nThe researchers determine, which level of abstraction is appropriate for a particular case in different ways, but the main criterion is that the model should be readable and understandable. \nIn <cit.>, the abstraction of a process model occurs through \u201csimplification\u201d automatically: a user determines only the desired degree of detail, but not the actual correctness of identifying high-level events.\nConversely, the paper <cit.> stressed the importance of the abstraction level dependence on the domain expert knowledge.\n\nPetri nets <cit.> can also be extended by adding the hierarchy as, e.g., in Colored Petri nets (CPN) <cit.>.\nHierarchy also allows one to construct more compact, readable and understandable process models. \nHierarchy of CPN models can be used as an abstraction, in the case of two levels: a high-level abstract model and a low-level refined model. \nIn our paper the high-level model is a model with abstract transitions. \nAn abstract transition refers to a Petri net subprocess, which refines the activity represented by this high-level transition. \nThe complete low-level (\u201cflat\u201d) process model can be obtained from a high-level model by substituting subprocesses for high-level transitions.\n\n\u201cFlat\u201d synthesis (when process model and log are at the same-level) is a standard process discovery problem, which has been extensively studied in the literature.\nA wide range of process discovery algorithms supports the automated flat process model synthesis <cit.>.\nInductive miner <cit.> is one of the most widely used process discovery algorithm that produces well-structured process models recursively built from building blocks for standard behavioral patterns.\nThey can be potentially used for constructing high-level process models.\nHowever, this technique does not take the actual correspondence between low-level events and subprocesses.\nIn <cit.>, the authors also used the recognition of behavioral patterns in a process by a structural clustering algorithm and then define a specific workflow schema for each pattern. \n\nIn <cit.>, a two-phase approach to mining hierarchical process models was presented. \nProcess models here were considered as interactive and context-depen\u00addent maps based on common execution patterns. \nOn the first phase, an event log is abstracted to the desired level by detecting relevant execution patterns. \nAn example of such pattern is the maximal repeat that captures typical sequences of activities the log. \nEvery pattern is then estimated by its frequency, significance, or some other metric needed for accurate abstraction. \nOn the second phase, Fuzzy miner discovery algorithm <cit.> adapted to process maps discovery is applied to  the transformed log.\n\nFlexHMiner <cit.> is a general algorithm based on process trees implemented in ProM software. \nThe authors stresses the flexibility of this approach: to identify the hierarchy of events, the method supports both supervised methods and methods using the general knowledge on a process. \nThe limitations of this method include the fact that each of the sub-processes can be executed only once, which means that the method is not suitable for processes with cycles. \n\nDetecting high-level events based on the patterns of behavior in an event log does not make it possible to refine the accuracy of abstraction based on the general knowledge of the system or provide it only partially.\nPatterns provide only the ability to change the scale, but not to participate in the selection of correct high-level events. \nThis could be useful only for a superficial analysis.\nHowever, there is a real risk of combining unrelated low-level events into a single high-level event only because they are executed sequentially, but not because they belong to the same logical component of a system.\n\nA large amount of literature is devoted to the problem of discovering structured models from event logs.\nResearchers offer different techniques to improve the structure of discovered models, e.g., in <cit.>, and to produce already well-structured process models <cit.>.\nDifferent ways of detecting subprocesses in event logs using low-level transition systems were discussed in <cit.>.\nThese papers do not consider mining hierarchical process models from event logs.\n\nIn our previous paper <cit.>, we presented an algorithm for the discovery of a high-level process model from the event log for acyclic processes. \nThe method takes the initial data about abstraction in the form of a set of detailed events grouped into high-level ones, which means that any method of identifying abstract events can potentially be used, including those based on expert knowledge. \nMoreover, the algorithm is based on event logs pre-processing.\nThis includes converting an initial event log into a high-level form and improving a target high-level process model\nAfter pre-processing, we can use any of the existing process discovery algorithms suitable for the same-level (flat) process discovery. \nBoth possibilities of using existing approaches as components make the earlier proposed algorithm flexible.\n\nThis paper expands the conditions of the applicability of the algorithm from <cit.> since  it only works for acyclic models. \nFor the algorithm to find and process potential cycles in the event log, we will reuse the method for detecting the repetitive behavior in a event log proposed in <cit.>, which partially covers the general solution of the cycle detection problem. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u00a7 PRELIMINARIES\n\n\nBy   we denote the set of non-negative integers.\n\nLet X be a set. A multiset m over a set X is a mapping: m : X \u2192, where  \u2013 is the set of natural numbers (including zero), i.e., a multiset may contain several copies of the same element. \nFor an element x\u2208 X, we write  x\u2208 m , if m(x) >0.\nFor two multisets m,m' over X we write m\u2286 m'  iff \u2200 x\u2208 X: m(x) \u2264 m'(x) (the inclusion relation). \nThe sum, the union and the subtraction of two multisets m and m' are defined as usual:\n\u2200 x\u2208 X: (m+m')(x)=m(x)+m'(x), (m\u222a m')(x)=max(m(x),m'(x)), (m-m')(x)=m(x) - m'(x), if  m(x) - m'(x) \u2265 0, otherwise (m-m')(x)= 0.\nBy \u2133(X) we denote the set of all multisets over X.\n\n\n\nFor a set X, by X^* with elements of the form \u27e8 x_1,\u2026, x_k \u27e9 we denote the set of all finite sequences (words) over X, \u27e8\u27e9 denotes the empty word, the word of zero length. Concatenation of two words w_1 and w_2 is denoted by w_1\u00b7 w_2.\n\nLet  Q \u2286 X be a subset of X. The \n projection _Q : X^*  \u2192 Q^* is  defined recursively as follows: \n \u27e8\u27e9_Q  = \u27e8\u27e9,  and for \u03c3\u2208 X^* and x \u2208 X: \n\n    (\u03c3\u00b7\u27e8 x\u27e9) _Q= \n        \u03c3_Qif x\u2209 Q \n    \u03c3_Q\u00b7\u27e8 x \u27e9if x \u2208 Q\n\n\n\n\nWe say that X = X_1 \u222a X_2 \u222a\u2026\u222a X_n is a partition of the set X if for all 1\u2264i,j\u2264n such that \ni\u2260 j we have X_i \u2229 X_j = \u2205. \n\n\n\n \u00a7.\u00a7 Petri Nets\n\n   \n\n\nLet P and T  be two disjoint finite sets of places and transitions respectively, and F : (P \u00d7 T) \u222a (T \u00d7 P) \u2192 be an arc-weight function. \nLet also A be a finite set of event names (or activities) representing observable actions or events, \u03c4 \u2014 a special label for silent or invisible action, \u03bb : T \u2192 A\u222a{\u03c4} is a transition labeling function. \nThen N = (P,T,F, \u03bb) is a labeled Petri net. \n\nGraphically, a Petri net is designated as a bipartite graph, where places are represented by circles, transitions by boxes, and the flow relation F by directed arcs.\n\n\n\n\n\nA marking in a Petri net N = (P,T,F, \u03bb) is a function m : P \u2192  mapping  each place to some  number of tokens (possibly zero). Hence, a marking in a Petri net may be considered as a multiset over its set of places.  \nTokens are graphically designated by filled circles, and then a current marking m  is  represented by putting m(p) tokens into each place p \u2208 P.\nA marked Petri net (N,m_0) is a Petri net N together with its initial marking m_0.\n\nFor  transition t \u2208 T, its preset  (denoted t)  and its postset (denoted t) are defined as  sets of its input and output places respectively, \nt = {p | F(p,t)\u2260 0} and t= {p | F(t,p)\u2260 0}.\n\n\nA transition t \u2208 T is enabled in a marking m, if for all p \u2208t, m(p)  \u2265 F(p,t). An enabled transition t may fire yielding a new marking m', such that m'(p) = m(p) - F(p,t) + F(t,p) for each p \u2208 P (denoted m\u03bb(t) m', or just m\u2192 m').\nA marking m' is reachable from a marking m, if there exists a sequence of firings m=m_0 \u2192 m_1 \u2192\u2026 m_k=m'. By \nNm we denote the set of all markings reachable from marking m in a net N.\n\nLet (N,m_0) be a marked Petri net with transitions labeled by activities from A\u222a{\u03c4}, and let m_0 a_1 m_1 a_2\u2026 be a finite or infinite sequence of firings in N, which starts from the initial marking m_0 and cannot be extended. Then a sequence of observable activities \u03c1, such that \u03c1 = \n\u27e8 a_1, a_2,\u2026\u27e9_A, is called a run, a run is a sequence of observable activities representing a variant of Petri net behavior. For a finite run \u03c1, which corresponds to a sequence of firings m_0a_1\u2026a_km_k, we call m_0 and m_k its initial and final markings respectively.\n\nA transition t\u2208 T is called dead for a marked net (N,m_0), if for each reachable marking m\u2208Nm_0, t is not enabled in m.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\nIn our study we consider  workflow nets \u2014 a special subclass of Petri nets \n<cit.> \nfor workflow modeling. A workflow net is a (labeled) Petri net with two special places: i and f. These places mark the beginning and the ending of a workflow process.\n\n\nA (labeled) marked Petri net N = (P,T,F,\u03bb, m_0) is called a workflow net (WF-net) if the following conditions hold:\n\n\n  * There is one source place i\u2208 P and one sink place f\u2208 P, such that  i = f = \u2205.\n\n  * Every node from P \u222a T is on a path from i to f.\n\n  * The initial marking m_0 in N contains the only token in its source place.\n\n\n\nGiven a WF-net, by [i] we denote its initial marking with the only token in place i, and by [f] \u2014 its final marking with the only token in place f.\n\n An example of a workflow net that simulates a simple process of handling ticket refund requests, is shown in Fig.\u00a0<ref> <cit.>. Here p_0 is the source place, and p_6 \u2014 the sink place. \n\n\n\nSoundness <cit.> is the main correctness property for workflow nets.\n\nA WF-net N = (P,T,F,\u03bb, [i]) is called sound, if \n\n    \n  * For any marking m \u2208 R (N,[i]), [f]\u2208Nm;\n    \n  * If for some m \u2208 R (N,[i]), [f]\u2286 m, then m=[f];\n    \n  * There are no dead transitions in N.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \u00a7.\u00a7 Event Logs\n\n\nMost information systems record  history of their process execution into event logs. An event record usually contains case ID, an activity name, a time step, and some information about resources, data, etc. For our study, we use case IDs for splitting an event log into  traces, timestamps \u2014 for ordering events within each trace, and abstract from event information different from event names (activities).\n\n\nLet A be a finite set of activities. A trace \u03c3 is a finite sequence of activities from A, i.e., \u03c3\u2208 A^*. By # a(\u03c3) we denote the number of occurrences of activity a in  trace \u03c3. \n\nAn event log L is a finite multi-set of traces, i.e., L \u2208\u2133(A^*). \nA log L' is called  a sub-log of L, if L'\u2286 L.\nLet X \u2286 A. We extend projection _X to event logs, i.e., for an event log L \u2208 M(A^*), its projection is a sub-log L_X, defined as the multiset of projections of all traces from L, L_X(\u03c3_X) = L(\u03c3) for all \u03c3\u2208 L.\n\nAn important question is whether the event log matches the behavior of the process model and vice versa. There are several metrics to measure  conformance between a WF-net and an event log. Specifically, fitness defines to what extend the log can be replayed by the model. \n\n  Let N be a WF-net with transition labels from A, an initial marking [i], and a final marking [f]. Let \u03c3 be a trace over A. We say that trace \u03c3 = \u27e8 a_1, \u2026 , a_k\u27e9 perfectly fits N, if \u03c3 is a run in N with initial marking [i] and final marking [f].\nA log L perfectly fits N, if every trace from L perfectly fits N.\n\n\n\n\u00a7 DISCOVERING HIERARCHICAL WF-NETS\n\n\n\n \u00a7.\u00a7 Hierarchical WF-Nets\n\n\n\n\n\n\n\n\n\n\nLet A denote the set of low level process activity names.\nLet A = {\u03b1_1, \u03b1_2, \u2026, \u03b1_k} denote the set of sub-process names, which represent high-level activity names, respectively.\n\nHere we define hierarchical workflow (HWF) nets with two levels of representing the process behavior.\nThe high level is a WF-net, whose transitions are labeled by the names of sub-processes from A.\nThe low level is a set of WF-nets corresponding to the refinement of transitions in a high-level WF-net.\nTransitions in a low level WF-net are labeled by the names of activities from A.\n\nBelow we provide the necessary definitions and study the semantics of HWF-nets.\n\nAn HWF-net is a tuple \ud835\udca9 = (N, N_1, N_2, \u2026, N_k,\u2113), where:\n\n    \n  * N = (P, T, F, \u03bb, [i]) is a high-level WF-net, where \u03bbT\u2192A is a bijective transition labeling function, which assigns sub-process names to transitions in N;\n    \n  * N_i = (P_i, T_i, F_i, \u03bb_i, [i]_i) is a low-level WF-net for every i \u2208 [1, k] with a transition labeling function \u03bb_i  T_i \u2192 A_i, where A_i \u2286 A is a  subset of low level activities for N_i;\n    \n  * \u2113A\u2192{N_1, N_2, \u2026, N_k} is a bijection which establish the correspondence between a sub-process name (transition in a high-level WF-net) and a low-level WF-net.\n\n\nAccordingly, every transition in a high-level WF-net \ud835\udca9 has a corresponding low-level WF-net modeling the behavior of a sub-process.\nThe example of an HWF-net is shown in Figure <ref>.\nWe only show the refinement of two transitions t_1 and t_2 in the high-level WF-net N with two low-level WF-nets N_1 and N_2.\nThey represent the detailed behavior of two sub-processes \u03b1_1 and \u03b1_2 correspondingly.\n\n\n\nWe next consider the operational semantics of an HWF-nets by defining its run.\nFor what follows, let \ud835\udca9 = (N, N_1, N_2, \u2026, N_k, \u2113) be an HWF-net.\n\nLet m be a reachable marking in a high-level WF-net of an HWF-net \ud835\udca9 and T_m be a set of transitions enabled at m.\nIntuitively, a set of transitions enabled in a high-level WF-net m corresponds to a set of sub-processes for which we can start to fire their low level transitions.\n\nIf some transitions in a high-level WF-net enabled at m share common places, then there is a conflict, and we can choose, which sub-process to start, while the other sub-rocesses corresponding to conflicting transitions in a high-level WF-net will not be able to run.\n\nIf some transitions in a high-level WF-net enabled at m do not share common places, then they are enabled concurrently, and we can start all sub-processes corresponding to these concurrently enabled transitions using the ordinary interleaving semantics.\n\nThe firing of a transition in a high-level WF-net will be complete when the corresponding sub-process reaches its final marking.\n\nFor instance, let us consider the HWF-net shown in Figure <ref>.\nAfter firing  high-level transition t_3 and executing a corresponding sub-process \u03b1_3 (not provided in Figure <ref>), two high-level transitions t_1 and t_2 become enabled.\nThey do not share common places, i.e.,  high-level transitions t_1 and t_2 are enabled concurrently.\nThus, the corresponding sub-processes \u03b1_1 (low-level WF-net N_1) and \u03b1_2 (low-level WF-net N_2) can also be executed concurrently.\nWe can obtain a sequence \u03c1 = \u27e8\u03b1_3, e_1, e_5, e_2, e_6, \u03b1_4 \u27e9, which will represent a possible run of an HWF-net from Figure <ref>.\nHigh-level activities \u03b1_3 and \u03b1_4 should also be replaced with corresponding sub-process runs.\n\nLastly, we give a straightforward approach to transforming an HWF-net \ud835\udca9 = (N, N_1, N_2, \u2026, N_k, \u2113) to the corresponding flat WF-net denoted by \ud835\udc1f\ud835\udc25(\ud835\udca9) = (P, T, F, \u03bb, [i]).\nWe need to replace transitions in a high-level WF-net with their sub-process implementation given by low-level WF-net corresponding by \u2113.\nWhen a transition t in a  high-level WF-net N is replaced by a low-level WF-net N_i, we need to fuse a source place in N_i with all input places of t and to fuse a sink place in N_i with all output places of t.\n\nFor instance, the flat WF-net \ud835\udc1f\ud835\udc25(\ud835\udca9) constructed for the HWF-net, shown in Figure <ref>, is provided in Figure <ref>.\nWe replaced transition t_1 with N_1 and transition t_2 with N_2 as determined by the labels of low-level WF-nets.\nThis figure also shows the double-line contours of corresponding  high-level transitions.\n\n\n\nProposition <ref> gives the main connection between an HWF-net and its flat representation. \n\n\n    Let \ud835\udca9 = (N, N_1, N_2, \u2026, N_k, \u2113) be a HWF-net, and \ud835\udc1f\ud835\udc25(\ud835\udca9) be the corresponding flat WF-net.\n    A sequence \u03c1 is a run in \ud835\udca9 if and only if \u03c1 is a run in \ud835\udc1f\ud835\udc25(\ud835\udca9).\n\n\nIn other words, the set of all possible runs of a HWF-net is exactly the same as the set of all possible runs of the corresponding flat WF-net.\nProof of this proposition directly follows from the construction of the flat WF-net and from the way we define the sequential semantics of a hierarchical WF-net.\n\nTo sum up, the constructive representation of the HWF-net sequential semantics fully agrees with the ordinary Petri net firing rule and the definition of a run discussed in Section 3.\n\n\n\n \u00a7.\u00a7 Problem Statement\n\nLet L be a log over a set A of activities, and let A=A_1\u222a A_2 \u222a\u2026\u222a A_k be a partition of A. Let also A = {\u03b1_1, \u03b1_2,\u2026\u03b1_k} be a set of high-level activities (sub-process names).\n\nThe problem is to construct a HWF-net \ud835\udca9= (N,N_1,N_2,\u2026,N_k,l), where for each i\u2208 [1, k], N_i is a sub-process (WF-net) labeled by \u03b1_i  over the set of activities A_i. Runs of \ud835\udca9 should conform to traces from L.\n\nWe suppose that partitioning A into subsets A_1, \u2026 A_k is made either by an expert, or automatically based on some information contained in extended action records, such as resources or data. In Section\u00a0<ref> we give two examples of partitioning activities for a real log. Then we consider that a sub-process is defined by its set of activities, and we suppose that sets of activities for two sub-processes do not intersect. If it is not the case and two sub-processes include some common activities like 'close the file', one can easily distinguish them by including resource or file name into activity identifier.\n\nOne more important comment concerning partitioning activities: we suppose that it does not violate the log control flow. Specifically, if there are iterations in the process, then for a set of iterated activities B and for each sub-process activities set A_i, we suppose that either B\u2229 A_i = \u2205, or B\u2286 A_i, or A_i\u2286 B. Note that this is a reasonable requirement, taking into account the concept of a sub-process. If still it is not true, \nonly a part of A_i activities are iterated, then the partition can be refined,  exactly A_i can be splitted into two subsets, within and out of iteration.\n\n\n\n \u00a7.\u00a7 Basics of the Proposed Solution\n\nNow we describe the main ideas and the structure of the algorithm for discovery of hierarchical WF-net from event log.\n\nLet once more L be a log with activities from A, and let A=A_1\u222a A_2 \u222a\u2026\u222a A_k be a partition of A. Let also A = {\u03b1_1, \u03b1_2,\u2026\u03b1_k} be a set of high-level activities (sub-process names).\nA hierarchical WF-net \ud835\udca9 consists of a high-level WF-net N with activities from A= {\u03b1_1,\u2026,\u03b1_k}, and k  sub-process WF-nets N_1,N_2,\u2026,N_k, where for each N_i, all its activities belong to A_i.\n\nSub-process WF-nets N_1,N_2,\u2026,N_k can be discovered directly. To discover N_i we filter log L to L_i = L_A_i.\nThen we apply one of popular algorithms (Inductive Miner) to discover WF-model from the log L_i. Fitness and precision of the obtained model depend on the choice of the discovery algorithm.\n\nDiscovering high-level WF-model is not so easy and is quite a challenge. Problems with it are coursed by possible interleaving of concurrent sub-processes and iteration. A naive solution could be like follows: in the log L replace each activity a\u2208 A_i by \u03b1_i \u2014 the name of the corresponding sub-process. Remove 'stuttering', replace wherever possible several sequential occurrences of the same high-level activity by one such activity. Then apply one of popular discovery algorithms to the new log over the set A of activities. However, this does not work.\n\n\n\nConsider examples in Fig.\u00a0<ref>. Fragment (a) in Fig.<ref> shows two concurrent sub-processes \u03b2 and \u03b3, going after sub-process \u03b1, which consists of just one transition. After replacing of low level activities with the corresponding sub-process names and removing stuttering, for the fragment (a), we get runs \u27e8\u03b1,  \u03b2,  \u03b3, \u2026\u27e9,  \u27e8\u03b1, \u03b3, \u03b2, \u2026\u27e9, \u27e8\u03b1, \u03b2,\u03b3, \u03b2, \u03b3, \u2026\u27e9,\n\u27e8\u03b1, \u03b3, \u03b2, \u03b3,  \u03b2,\u2026\u27e9, etc.  \nFragment (b) in Fig.\u00a0<ref> shows a cycle. The body of this cycle is the sequence of two sub-processes \u03b2 and \u03b3. Among runs for the fragment (b) we also have \u27e8\u03b1,  \u03b2,  \u03b3, \u2026\u27e9,  \u27e8\u03b1, \u03b2,\u03b3, \u03b2, \u03b3, \u2026\u27e9. So, iterations should be considered separately. \n\nDiscovering high-level WF-nets for acyclic models (logs without iteration) was studied earlier in <cit.>, where all details can be found. Here we call  this algorithm as Algorithm \ud835\udd04_0 and illustrate it with the  example in Fig.\u00a0<ref>(a). The algorithm \ud835\udd04_0 to discover a high-level WF-model from a log L without iterations reduces this problem to the classical discovery problem, which can be solved by many popular algorithms, such as e.g. Inductive Miner.  Therefore, we parameterize Algorithm \ud835\udd04_0 with Algorithm\u00a0\ud835\udd07 for solving classical discovery problem.\n\n\n\n\n\nAlgorithm \ud835\udd04_0(\ud835\udd07):\n\n\n    \n  Step 1. For all traces in L, replace low level activities with the corresponding sub-process names and remove stuttering.\n    \n  Step 2.  For each trace \u03c3 with more than one occurrence of the same activity  replace \u03c3 with the set of all possible clones of \u03c3 by removing for each activity \u03b1, all its multiple occurrences except one, and by removing (newly formed) stuttering. For example, the trace \u27e8\u03b1, \u03b2,\u03b3, \u03b2, \u03b3, \u2026\u27e9 will be replaces by two traces \u27e8\u03b1, \u03b2,\u03b3, \u2026\u27e9 and \u27e8\u03b1, \u03b3, \u03b2, \u2026\u27e9 obtained by keeping the first occurrences of \u03b2 and \u03b3, and correspondingly by keeping the first occurrence of \u03b3 and the second occurrence of \u03b2. In this example, constructing clones by keeping other occurrences of \u03b3 does not generate new traces.\n    \n  Step 3.  Let L be the log resulting from executing two previous steps.  To obtain a high-level WF-net N, apply a popular algorithm \ud835\udd07 to discover a WF-net from event log L.\n\n\nIt was proved in\u00a0<cit.> that if an algorithm used in Step\u00a03 of the Algorithm \ud835\udd04_0 for each input log L discovers  a WF-net  perfectly fitting L, then the Algorithm \ud835\udd04_0, given a log L without repetitive behavior, produces a HWF-net \ud835\udca9, such that \ud835\udc1f\ud835\udc25(\ud835\udca9) perfectly fits L.\n\n\n\nNow we come to logs with repetitive behavior. The main idea here is to represent a loop body as a subset of its activities. Then a body of a loop can be considered as a sub-process with a new loop sub-process name.\n\nTo discover repetitive behavior we use  methods from <cit.>, which allow  to determine causal, concurrency, and repetitive relations between events in an event log.\nActually, for our purpose we need only repetitive relations and based on them loop discovery. The algorithm in <cit.> (we call it here as  Algorithm \ud835\udd05) allows us to discover elementary loop bodies as sets of their activities and process them recursively, starting with inner elementary loops.  Thus, at every iteration we deal with a loop body without inner loops. To obtain a sub-trace, corresponding to a loop body with a set of activities B from a log trace \u03c3 we construct the projection \u03c3_B. After filtering all current traces this way, we get an event log for discovering a WF-net modeling the loop body behavior by applying Algorithm \ud835\udd04_0.\n\nThen the result high-level WF-net is built recursively by substituting discovered loop bodies for loop sub-process  names, starting from inner loops.\n\n\n\n\u00a7 ALGORITHM FOR DISCOVERING  HWF-NETS FROM LOW LEVEL EVENT LOGS\n\n\nHere we describe  our discovery algorithm  in more details.\n\nLet A be a set of activities and L \u2014 a log over A. Let then A=A_1\u222a\u2026\u222a A_k be a partition of A, where for i\u2208 [1, k], A_i is a set of activities of a sub-process \u03b1_i and A= {\u03b1_1, \u2026, \u03b1_k} \u2014 a set of sub-process names.\n\nThen Algorithm \ud835\udd04(\ud835\udd07)  constructs a HWF-net \ud835\udca9 = (N, N_1, N_2, \u2026, N_k,\u2113) with  high-level WF-net N = (P, T, F, \u03bb, [i]), where\n\u03bbT\u2192A and for each \u03b1_i\u2208A, \u2113(\u03b1_i) = N_i, sub-process name \u03b1_i corresponds to  low-level WF-net N_i in \ud835\udca9.\n\n\n\n\nAlgorithm \ud835\udd04(\ud835\udd07): \n\nBy B we denote a  set of loop body names with elements {\u03b2, \u03b2',\u2026} and by \u2113_B \u2014 a function which maps a name from B to a WF-net that implements the loop body. For a WF-net N, denote by (N)  a WF-net that is a loop with  body N.\n\n \n\n  Step 0. Set B= \u2205 and \u2113, \u2113_B to be two functions with  empty domains. \n\n  Step 1.\n    Apply Algorithm \ud835\udd05 to L to find a set B of activities of some inner elementary loop body. If there is no repetitive behavior in L, go to Step 2, otherwise do the following.\n    \n  \n    Construct the projection L_B and apply Algorithm\u00a0\ud835\udd04_0(\ud835\udd07) to it (with respect to the partition A=A_1\u222a\u2026\u222a A_k). \n    \n    Let N be the result high level WF-net over the set A of sub-process names,  N_i_1,\u2026, N_i_j \u2014 result WF-nets for sub-processes with names \u03b1_i_1,\u2026, \u03b1_i_j respectively (for each \u03b1_i, such that A_i\u2286 B, for sub-processes  within the loop body), and let \u03b2  be a new name. Then\n    \n        \n  * For each \u03b2'\u2208B, if there is a transition labeled by \u03b2' in some of \n        N_i_1,\u2026, N_i_j or N, replace this transition with  sub-process (\u2113_B(\u03b2')), as was done when constructing  a flat WF-net in Subsection\u00a0<ref>, substitute inner loops in the loop body. Remove \u03b2' from A, B and from the domains of \u2113 and \u2113_B.\n        \n  * Add \u03b2 to B and extend \u2113_B by defining \u2113_B(\u03b2) = N.\n    Extend also \u2113 by defining \u2113(A_i_1) = N_i_1, \u2026, \u2113(A_i_j) = N_i_j.\n        \n  * Replace by \u03b2 all occurrences of activities from B in L and remove stuttering.\n        \n  * If for some i\u2208 [1\u2026 k], B\u2286 A_i, then add \u03b2 to A_i (and respectively to A) as one more activity. Otherwise, add \u03b2 to A, as well as add  {\u03b2} to partition of A. (Thus, \u03b2 is both an activity and a process name, which  should not be confusing.)\n    \n    \n    Repeat Step 1.\n     \n\n  Step 2. \nApply Algorithm\u00a0\ud835\udd04_0(\ud835\udd07) to  current log L with respect to the current partition of activities. Let N be a result high level WF-net.\n\n\n  Step 3. \nWhile B is not empty, for each \u03b2\u2208B,\n replace a transition labeled by \u03b2 in N with the sub-process (\u2113_B(\u03b2)), as it is done in Step 1.\n    \nThe resulting net N is a high-level WF-net for the HWF-net constructed by the Algorithm. Its low-level WF-nets are defined by function \u2113, also built during the Algorithm operation. \n    \n\n   \n \n\n\n\nCorrectness of the Algorithm\u00a0\ud835\udd04(\ud835\udd07) is justified by the following statement.\n\n\nLet A be a set of activities and L \u2014 a log over A. Let also A=A_1\u222a\u2026\u222a A_k be a partition of A, \nand A= {\u03b1_1, \u2026, \u03b1_k} \u2014 a set of sub-process names.\n\nIf Algorithm \ud835\udd07 for any log L' discovers a WF-net N', such that N' perfectly fits L',\nthen Algorithm \ud835\udd04(\ud835\udd07)  constructs a HWF-net \ud835\udca9 = (N, N_1, N_2, \u2026, N_k,\u2113), such that \n\n\ud835\udc1f\ud835\udc25(\ud835\udca9) perfectly fits L.\n\n\n\n\nTo prove that the HWF-net built using Algorithm \ud835\udd04(\ud835\udd07) perfectly fits the input log, provided that Algorithm \ud835\udd07 discovers models with perfect fitness, we use three previously proven assertions.  Namely, \n\n    \n  * Theorem in <cit.> states that when \ud835\udd07 is an discovery algorithm with perfect fitness, Algorithm\u00a0\ud835\udd04_0(\ud835\udd07) discovers a high-level WF-net, whose refinement perfectly fits the input log without repetitions (the log of an acyclic process).\n    \n  * In <cit.> it is proved  that, given a log  L, Algorithm \ud835\udd05 correctly finds in L all repetitive components that correspond to supports of T-invariants in the Petri net model for L.\n    \n  * Proposition\u00a0<ref> in Subsection\u00a0<ref> justify correctness of refining a high-level WF-net by substituting sub-process modules for high-level transitions.\n\n\nWith all this, proving the Theorem is straightforward, though quite technical. So, we informally describe the logic of the proof here.\n\nLet \nAlgorithm\u00a0\ud835\udd07 be a discovery algorithm, which discovers a perfectly fitting WF-net for a given event log.\n\nAt each iteration of Step\u00a01, an inner elementary repetitive component in the log is discovered  using Algorithm \ud835\udd05. Activities of this component are activities of an inner loop body, which itself does not  have repetitions. Then a WF-net N for this loop body is correctly discovered using Algorithm\u00a0\ud835\udd04_0(\ud835\udd07), the  loop itself is folded into one high-level activity \u03b2, and N is kept as the value \u2113_B(\u03b2). WF-nets for sub-processes within the body of this loop are also discovered by Algorithm\u00a0\ud835\udd04_0(\ud835\udd07) and accumulated in \u2113.\nIf  loop activity \u03b2 is itself within  an upper loop body, then with one more iteration of Step 1, the upper loop N' is discovered, the transition labeled with \u03b2 in it is replaced with N, and N' is itself folded into a new activity. \n\nAfter processing all loops, the Algorithm proceeds to Step 2, where after reducing all loops to high-level activities, Algorithm\u00a0\ud835\udd04_0(\ud835\udd07) is applied to a log without repetitions.\n\nIn Step 3 all transitions labeled with loop activities in a high-level and low-level WF-nets are replaced by WF-nets for these loops, kept in \u2113_B.\n\nSo, we can see that while Algorithm\u00a0\ud835\udd04_0(\ud835\udd07) ensures perfect fitness between acyclic fragments of the model (when loops are folded to transitions), Algorithm \ud835\udd05 ensures correct processing of cyclic behavior, and Proposition\u00a0<ref> guarantees that replacing loop activities by corresponding loop WF-nets does not violate fitness, the main algorithm provides systematic log processing and model construction.\n\n\n\n\n\u00a7 EXPERIMENTAL EVALUATION\n\n\n\nIn this section, we report the main outcomes from a series of experiments conducted to evaluate the algorithm for discovering two-level hierarchical process models from event logs.\n\nTo support the automated experimental evaluation, we implemented the hierarchical process discovery algorithm described in the previous section using the open-source library PM4Py <cit.>.\nThe source files of our implementation are published in the open GitHub repository <cit.>.\nWe conducted experiments using two kinds of event logs:\n\n    \n  * Artificial event logs generated by manually prepared process models;\n    \n  * Real-life event logs provided by various information systems.\n\n\nEvent logs are encoded in a standard way as XML-based XES files.\n\nConformance checking is an important part of process mining along with process discovery <cit.>.\nThe main aim of conformance checking is to evaluate the quality of process discovery algorithm by estimating the corresponding quality of discovered process models.\nConformance checking provides four main quality dimensions.\nFitness estimates the extent to which a discovered process model can execute traces in an event log. \nA model perfectly fits an event log if it can execute all traces in an event log.\nAccording to Theorem 1, the hierarchical process discovery algorithm yields perfectly fitting process models.\nPrecision evaluates the ratio between the behavior allowed by a process model and not recorded in an event log. \nA model with perfect precision can only execute traces in an event log. The perfect precision limits the use of a process model since an event log represents only a finite \u201csnapshot\u201d of all possible process executions. \nGeneralization and precision are two dual metrics. \nThe fourth metric, simplicity, captures the structural complexity of a discovered model.\nWe improve simplicity by the two-level structure of a discovered process models.\n\nWithin the experimental evaluation, we estimated fitness and precision of process models discovered from artificially generated and real-life event logs.\nFitness was estimated using alignments between a process model and an event log as defined in <cit.>.\nPrecision was estimated using the complex ETC-align measures proposed in <cit.>.\nBoth measures are values in the interval [0, 1].\n\n\n\n \u00a7.\u00a7 Discovering HWF-Nets from Artificial Event Logs\n\nThe high-level source for generating artificial low-level event logs was the Petri net earlier shown in Figure <ref>.\nIn this model, we refined its transitions with different sub-processes containing sequential, parallel and cyclic executions of low-level events.\nThe example of refining the Petri net from Figure <ref> is shown in Figure <ref>, where we show the corresponding flat representation of an HWF-net.\n\n\n\nGeneration of low-level event logs from the prepared model was implemented using the algorithm presented in <cit.>.\nAfterwards, we transform a low-level event log into a high-level event log by grouping low-level events into a single high-level event and by extracting the information about cyclic behavior.\n\nThe corresponding high-level WF-net discovered from the artificial low-level event log generated from the WF-net shown in <ref> is provided in Figure <ref>.\nIntuitively, one can see that this high-level WF-net is rather similar to the original Petri net from Figure <ref>.\n\n\n\nAs for the quality evaluation for the above presented high-level model, we have the following:\n\n    \n  * The discovered high-level WF-net perfectly fits the high-level event log obtained from a low-level log, where we identified cycles and grouped activities correspondingly.\n    \n  * The flat WF-net obtained by refining transitions in a discovered high-level WF-net almost perfectly fits (0.9534) a low-level log. The main reason for this is the combination of the coverability lack and the straightforward accuracy indicators of the algorithm.\n    \n  * Precision of the flat WF-net is 0.3729, which is the result of identifying independent sub-processes generalizing the behavior recorded in an initial low-level event log.\n\n\nOther examples of process models that were used for the artificial event log generation are also provided in the main repository <cit.>. \n\n\n\n \u00a7.\u00a7 Discovering HWF-Nets from Real-Life Event Logs\n\n\nWe used two real-life event logs provided by BPI (Business Process Intelligence) Challenge 2015 and 2017 <cit.>.\nThese event logs were also enriched with the additional statistical information about flat process models.\n\nThe BPI Challenge 2015 event log was provided by five Dutch municipalities.\nThe cases in this event log contain information on the main application and objection procedures in various stages.\nA flat low-level WF-net for case f1 discovered using the Inductive miner is shown in Figure <ref>.\nIt is easy to see that this model is absolutely inappropriate for the visual analysis.\n\n\n\nThe code of each event in the BPI Challenge 2015 event log consists of three parts: two digits, a variable number of characters, and three digits more. \nFrom the event log description we know that the first two digits and the characters indicate the sub-process the event belongs to, which allows us to assume an option of identifying the sub-processes. \nWe used the first two parts of the event name to create the mapping between low-level events and sub-proces names. \nAfter applying our hierarchical process discovery algorithm in combination with the Inductive Miner, we obtained a high-level model presented in Figure <ref> that is far more comprehensible than the flat model mainly because of its size.\n\n\n\nThe BPI Challenge 2017 event log pertains to a loan application process of a Dutch financial institute. \nThe data contains all applications filed trough an online system from 2016 till February of 2017. \nHere, as a base for mapping low-level events to sub-proces names, we used the mark of the event type in its name \u2014 application, offer or workflow.\nThus, a mapping could be based on various features of event data dependint on the expert's needs. \nThe flat model for this data is presented in Figure <ref>, which is also difficult to read because of  its purely sequential representation.\n\n\n\n\nApplying the  principle of mapping low-level events in the BPI Challenge 2017 event log  described above, we obtained the high-level WF-net shown in Fig.\u00a0<ref>, which clearly demonstrates sub-processes (if necessary, they can be expanded) and their order.\n\n\n\n\nTable <ref> shows fitness and precision evaluation for flat and high-level WF-nets discovered from real-life BPI Challenge 2015 and 2017 event logs.\n\n\n\n\n\nFitness 1 shows the fitness evaluation between the flat WF-net constructed from the high-level WF-net by refining transitions with low-level subprocesses.\nFitness 2 shows the fitness evaluation between the high-level WF-net and an event log with low-level events grouped into sub-processes.\nThis confirms the formal correctness results of the hierarchical process discovery algorithm.\nSimilar to the experimental results for artificial event logs, here we also observe a decrease in the precision for the identification of sub-processes, therefore, generalizing traces in an initial low-level event log.\n\n\n \n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u00a7 CONCLUSION AND FUTURE WORK\n\n\n\nIn this research, we provide a new process discovery technique for solving the problem of discovering a hierarchical WF-net model from a low-level event log, based on \u201cfolding\u201d sub-processes into high-level transitions according to event clustering. Unlike the previous solutions, we allow cycles and concurrency in process behavior. \n\nWe prove that the proposed technique makes it possible to obtain hierarchical models, which fit event logs perfectly. The technique was also evaluated on artificial and real event logs. Experiments show that fitness and precision of obtained hierarchical models are almost the same as for the standard \u201cflat\u201d case, while hierarchical models are much more compact, more readable and more visual.\n\nTo implement our algorithm and check it on real data we used Python and one of the most convenient instruments for process mining at the moment \u2014 the PM4Py <cit.>. The implementation  is provided in the public GitHub repository <cit.>.\n\nIn further research, we plan to develop and evaluate various event clustering methods for automatic discovery of hierarchical models.\n\n\n\n\n elsarticle-num \n \n\n\n\n\n\n\n\n\n\n\n\n\n"}