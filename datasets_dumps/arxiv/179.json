{"entry_id": "http://arxiv.org/abs/2303.07104v1", "published": "20230313134213", "title": "xASTNN: Improved Code Representations for Industrial Practice", "authors": ["Zhiwei Xu", "Min Zhou", "Xibin Zhao", "Yang Chen", "Xi Cheng", "Hongyu Zhang"], "primary_category": "cs.SE", "categories": ["cs.SE", "cs.AI"], "text": "\n\n\n\n\n\n  KLISS, BNRist, School of Software\n  Tsinghua University\n  Beijing\n  China\n\nxu-zw21@mails.tsinghua.edu.cn\n\n\nCorresponding author.\n\n  KLISS, BNRist, School of Software\n  Tsinghua University\n  Beijing\n  China\n\nmzhou@tsinghua.edu.cn\n\n\n\n  KLISS, BNRist, School of Software\n  Tsinghua University\n  Beijing\n  China\n\nzxb@tsinghua.edu.cn\n\n\n\n  School of Computer Science\n  Fudan University\n  Shanghai\n  China\n\nchenyang@fudan.edu.cn\n\n\n\n  VMware\n  Beijing\n  China\n\nchengxi@vmware.com\n\n\n\n  School of Information and Physical Sciences\n  The University of Newcastle\n  Newcastle\n  Australia\n\nhongyu.zhang@newcastle.edu.au\n\n\n\nThe application of deep learning techniques in software engineering becomes increasingly popular. One key problem is developing high-quality and easy-to-use source code representations for code-related tasks. The research community has acquired impressive results in recent years. However, due to the deployment difficulties and performance bottlenecks, seldom these approaches are applied to the industry. In this paper, we present xASTNN, an eXtreme Abstract Syntax Tree (AST)-based Neural Network for source code representation, aiming to push this technique to industrial practice. The proposed xASTNN has three advantages. First, xASTNN is completely based on widely-used ASTs and does not require complicated data pre-processing, making it applicable to various programming languages and practical scenarios. Second, three closely-related designs are proposed to guarantee the effectiveness of xASTNN, including statement subtree sequence for code naturalness, gated recursive unit for syntactical information, and gated recurrent unit for sequential information. Third, a dynamic batching algorithm is introduced to significantly reduce the time complexity of xASTNN. Two code comprehension downstream tasks, code classification and code clone detection, are adopted for evaluation. The results demonstrate that our xASTNN can improve the state-of-the-art while being faster than the baselines.\n\n\n\n\n\n\n\n\n<ccs2012>\n   <concept>\n       <concept_id>10011007.10011006.10011008.10011024</concept_id>\n       <concept_desc>Software and its engineering\u00a0Language features</concept_desc>\n       <concept_significance>500</concept_significance>\n       </concept>\n   <concept>\n       <concept_id>10010147.10010257.10010293.10010319</concept_id>\n       <concept_desc>Computing methodologies\u00a0Learning latent representations</concept_desc>\n       <concept_significance>500</concept_significance>\n       </concept>\n </ccs2012>\n\n\n[500]Software and its engineering\u00a0Language features\n[500]Computing methodologies\u00a0Learning latent representations\n\n\n\n\n\n\n\nxASTNN: Improved Code Representations for Industrial Practice\n    Hongyu Zhang\n    March 30, 2023\n=============================================================\n\n\n\n\n\n\n\n\u00a7 INTRODUCTION\n\n\nCode representations (a.k.a., embeddings) is of great importance in deep learning-based software engineering techniques. A high-quality representation model can significantly improve the performance of many downstream tasks, such as code search <cit.>, code clone detection <cit.>, and bug localization <cit.>. Recently, code representation learning has aroused much interest in both academia <cit.> and industry <cit.>.\n\nDespite advancement, there are still restrictions that prevent the widespread adoption of existing code representation approaches in industry. Effectiveness, efficiency, and applicability are of particular concern. A recent study <cit.> has shown that the state-of-the-art approach ASTNN <cit.> incurs much computation time to embed the source code as vectors for code clone detection (e.g., 5.48 \u00d7 over SCDetector <cit.> and 3.09 \u00d7 over RtvNN <cit.>). Kang et al. <cit.> conduct an empirical study to demonstrate that the popular code representation approach code2vec <cit.> lacks generalizability and cannot be readily leveraged for downstream tasks. GNN-CDFG <cit.>, GGNN <cit.>, and HPG+HGT <cit.> require their elaborate graphs to represent code segments, leading to a strong dependency on the characteristics of programming languages. flow2vec <cit.>, inst2vec <cit.>, and DeepSim <cit.> are designed based on specific compilers such as LLVM <cit.> and WALA <cit.>. The above restrictions hinder the industrial applications of existing code representation approaches.\n\nIn the industrial practice of neural code representation, we are often involved in a variety of production issues, such as constrained computing resources, limited response time, abnormal data inputs, etc. Therefore, the code representation approaches are supposed to address the following three imperative challenges: (1) Design a model with notable effectiveness. The quality of code representations can directly influence the effectiveness of the model on downstream tasks. (2) Build a model that is as fast and lightweight as possible. It is unacceptable in the industry that the software services have severe runtime delays or memory overflow problems. (3) The model should be applicable in various scenarios, e.g., be independent of parsers to cater for different programming languages, and be able to handle code segments of various sizes so as not to be trapped in gradient problems.\n\nTo this end, we propose an eXtreme abstract syntax tree (AST)-based neural network (xASTNN) for neural code representations in industrial practice. xASTNN is entirely based on common ASTs, which are always accessible and available with the source codes. To guarantee the effectiveness of xASTNN, we first perform a preorder traversal upon the AST to convert it into a statement subtree sequence. Further, we present gated recursive unit (GRvU) for capturing the syntactical information of each subtree and gated recurrent unit (GRtU) for capturing the sequential information of the subtree sequence. The introduction of gating mechanism not only improves the generalizability of our approach, but also prevent our approach from gradient problems encountered by the previous approach <cit.>. To optimize the computation time of our xASTNN, we describe a novel and high-efficient dynamic batching algorithm for the processing of subtrees, which enables parallel operations at the contents of the same tree depth within a batch of data samples. Under the above designs, our xASTNN is thus effective, efficient, and can be widely used in industrial practice.\n\nExtensive experiments have been carried out to validate the performance of our xASTNN. Two comprehension downstream tasks including code classification and code clone detection are applied for evaluation. The results demonstrate that our xASTNN is highly competitive as a code representation model for practical usage. Specifically, our xASTNN improves the state-of-the-art performance and achieves superb efficiency at the same time. For example, our xASTNN achieves an accuracy of 0.985 for the POJ dataset in the code classification task. The computation time of our xASTNN for representing one code segment is over 10\u00d7 faster than the previous approach ASTNN. \n\nTo summarize, we have made the following contributions:\n\n\n    \n  * (Applicability) Based on easily accessible ASTs, we present an innovative neural code representation approach named xASTNN for industrial practice. \n    \n  * (Effectiveness, Applicability) We introduce gating mechanism to effectively capture the syntactical and sequential information of statement subtree sequence while avoiding gradient problems encountered by the previous approach. \n    \n  * (Efficiency) We describe a high-efficient dynamic batching algorithm that greatly optimizes the time complexity of operations over trees.\n    \n  * Our representation approach is evaluated on two common comprehension tasks: code classification and code clone detection. The results demonstrate that the proposed approach can outperform the state-of-the-art approaches and is more practical.\n\n\nThe remainder of the paper is organized as follows. Section <ref> introduces the related work. Section <ref> presents the proposed approach, including statement subtree sequence, gated recursive unit, gated recurrent unit, and dynamic batching algorithm. Section <ref> validates the competing approaches. Section <ref> illustrates the threats to validity. Section <ref> discusses the lessons learned from the practice and we conclude in Section <ref>.\n\n\n\n\u00a7 RELATED WORK\n\n\n\nThe emergence of code representation learning mainly borrows the concepts from natural language processing (NLP), and the source code are treated as a sequence of tokens. Raychev et al. <cit.> describes a recurrent neural network (RNN) and N-gram model for code completion. Allamanis et al. <cit.> train an N-gram model on the GitHub Java corpus for mining source code repositories. Further, they <cit.> propose a neural context model to suggest class and method names. CODE-NN <cit.> exploits LSTM <cit.> and neural attention to summarize code. However, the above approaches ignore the inherent syntactical features of programming languages, thus failing to produce good code representations.\n\nTo capture syntactical information of programming languages, recent researches introduce ASTs as input to the representation models. AutoenCODE <cit.> adopts a recursive autoencoder over ASTs to learn the unsupervised program embeddings. TBCNN <cit.> proposes a tree-based convolution over the AST to represent the code segment. CDLH <cit.> introduces TreeLSTM <cit.> to generate the embeddings for code clone detection. Different from previous work that directly captures the syntactical information from ASTs, code2vec <cit.> first extracts a bag of leaf-to-leaf paths from the AST and aggregates these paths using the attention mechanism. code2seq <cit.> improves code2vec by introducing LSTM <cit.> to encode paths, which is applied in code summarization. A similar approach to ours is ASTNN <cit.>, which encodes the source code by capturing both the lexical and syntactical knowledge of statements. Since code naturalness is well modeled, ASTNN achieves superb performance in code tasks. Nevertheless, ASTNN is proven to be inefficient when applying to practical scenarios <cit.>.\n\nThere are also many code representation approaches based on pre-training techniques. CodeBERT <cit.> considers the source code as token sequence and applies the successful BERT <cit.> to pre-train the model. GraphCodeBERT <cit.> improves CodeBERT by introducing the data flow of the source code. InferCode <cit.> describes a self-supervised pre-training approach by predicting subtrees of ASTs. Mastropaolo et al. <cit.> pre-train a T5 model based on a dataset composed of natural language English and source code for code-related tasks. SPT-Code <cit.> presents a sequence-to-sequence pre-training pipeline for source code representations. However, recent evidence <cit.> points out that existing pre-training code representation approaches may fail in some code tasks and even achieve worse performance than BERT <cit.>. Besides, the pre-training techniques require a large-scale dataset and a large amount of computing resources, which can be a huge challenge for industrial practice.\n\nTherefore, an effective, efficient, and general-purpose code representation approach is urgently needed. In this work, we propose xASTNN, aiming to resolve the challenges to existing approaches in practical scenarios.\n\n\n\n\n\n\u00a7 APPROACH\n\n\n\nIn this section, we present the proposed approach xASTNN. As shown in Figure <ref>, xASTNN consists of two phases. In the first phase, the code fragment is first transformed into an AST by using a common AST parser. A preorder traversal over AST is applied to obtain a statement subtree sequence, in which each subtree corresponds to a statement of the code fragment. The first phase can be computed in advance when training xASTNN. In the second phase, we first adopt the popular word2vec <cit.> to embed the subtree sequence into a distributed space. To ensure the effectiveness and applicability of xASTNN, gating mechanism is introduced to incorporate the syntactical information of subtrees and sequential information of subtree sequence. Lastly, we exploit a max pooling layer to combine the subtree embeddings into the code vector. \n\n\n\n \u00a7.\u00a7 Statement Subtrees for Code Naturalness\n\nThe code naturalness is a hypothesis stating that software corpora have similar statistical properties to natural language corpora since the software is a form of human communication <cit.>. To capture the code naturalness, we first consider the source code as an AST and then transform it into a combination of statement subtrees as input to the neural network. AST is a widely used structure in the field of code representation approaches and can be easily accessed by common AST parsers. In this work, we exploit javalang <cit.> and pycparser <cit.> for the experiments of Java and C, respectively. Based on our empirical study, we opt to extract the subtrees at the statement level for the following two reasons.\n\n\n    \n  * Previous work <cit.> has shown that statement subtree sequence can effectively capture code naturalness, thereby improving the quality of code representations. Besides, subtree at the statement level is a good trade-off between the size of subtree and the richness of syntactical information.\n    \n  * The size of statement subtrees is approximately equal in comparison to subtrees of other granularities. For example, subtree at the block level is made up of a varying number of statement subtrees, which can easily lead to an unstable size of subtree and thus introduces efficiency concerns in practice (see Section <ref>).\n\n\nAlgorithm <ref> illustrates how we transform an AST into a statement subtree sequence. This algorithm takes the root of an AST head and the set of subtree root identifiers R as input, and outputs the subtree sequence extracted from the AST. The subtree root identifiers target to help the preorder traversal process to recognize statements, which generally are logical tokens in programming languages such as if, while, for, switch, FunctionDeclaration, VariableDeclaration, FuncCall, etc. They can be easily obtained when it comes to other programming languages.\n\n\n\n\n\nThe main body of Algorithm <ref> consists of three procedures. It starts with initializing an empty sequence for storing subtrees (line 10) and then applying a preorder traversal to generate the statement subtree sequence (line 11) that is finally returned (line 12). In function , it accepts the root node of an AST as input (line 1). When this root node belongs to subtree root identifiers (line 2), we construct a statement subtree based on this root (line 3) and append this statement subtree to the subtree sequence (line 4). Then, for each child node of this root that does not belong to the statement subtree (line 6), we recursively perform  (line 7) to generate the other statement subtrees, i.e., statements inside program branches.\n\nTo help understand how the source code is transformed into a statement subtree sequence, we present an example as shown in Figure <ref>. We can observe that every subtree in the sequence corresponds to a statement in the code segment, which is obtained by preoreder traversal and is in the order of: While, If, Compound, Assign(3), Assign(4), Assign(5), End, Else, Assign(8), Assign(9). \n\n\n\n \u00a7.\u00a7 Gated Recursive Unit over Tree Structures\n\nThrough the statement subtree sequence extracted from the AST, the code naturalness is incorporated. To better capture the syntactical information of the subtrees, we propose gated recursive unit (GRvU) based on previous work <cit.>. In contrast, we simplify the complicated components of their mechanisms and make the recursive neural network sufficiently efficient for industrial practice. That is, the position-aware fully connected layer is removed to reduce time complexity and enable full parallelization. \n\n\n\nFigure <ref> introduces the workflow of the proposed GRvU. GRvU assigns each node of the subtree a hidden state, which records the bottom-up information of it child nodes. We further apply gating mechanism to incorporate the information of hidden states and inputs. Specifically, given a subtree node j, its hidden state is the interpolation of the previous calculated hidden states h_jk of its k-th child out of N total children and the candidate hidden state h_j. It is calculated as follows:\n\n    h_j = z_j * \u2211_k = 1^N h_jk + (1 - z_j) * h_j\n\nwhere z_j is the update gate, which keeps a part of the hidden states of children and the other part of its candidate hidden state. The calculation of the update gate is as follows:\n\n    z_j = \u03c3(U_z * x_j + \u2211_k = 1^N W_z * h_jk)\n\nwhere U_z \u2208\u211d^d \u00d7 d and W_z \u2208\u211d^d \u00d7 d represent fully-connected layer, and \u03c3 represent sigmoid function that can map the inputs to the interval from 0 to 1. Besides, we also introduce a reset gate to selectively filter hidden states of children, which is computed as follows:\n\n    r_j = \u03c3(U_r * x_j + \u2211_k = 1^N W_r * h_jk)\n\nThe reset gate is applied to choose important elements from the hidden states of children, which is also activated by the sigmoid function. Combining the input of the current root and gated hidden states of children, we obtain the candidate hidden state of node j. It contributes to generating the final hidden state of node j. The candidate hidden state h_j is computed as:\n\n    h_j = f(U_h * x_j + \u2211_k = 1^N W_h * (h_jk * r_j))\n\nwhere f represents the hyperbolic tangent function that activates the input. We consider the hidden state of the subtree root as its distributed representation. Therefore, by applying the proposed GRvU over each subtree of the subtree sequence, we can acquire the representation of the subtree sequence:\n\n    O = [o_1, o_2, ..., o_M] = (S)\n\nwhere O preserves the effective syntactical information of each statement, which can significantly improve the generalizability of our xASTNN.\n\n\n\n \u00a7.\u00a7 Gated Recurrent Unit for Subtree Sequence\n\n\nWe also adopt the well-acknowledged gated recurrent unit (GRtU or GRU) <cit.> to capture the sequential information of subtree sequence, which constitutes the code naturalness together with the aforementioned syntactical information. Given the outputs from GRvU, we adopt a standard bidirectional GRtU to learn the relation between these subtrees. The calculation of GRtU is as follows:\n\n\n    V = [v_1, v_2, ..., v_M] = concat((O), (O))\n\nwhere concat represents the concatenation of two vectors, which combines the subtree representations of two directions. Finally, both syntactical information and sequential information have been introduced into the subtree embeddings, thereby ensuring that code naturalness is well modeled. To obtain the final code representation, we feed the enhanced subtree embeddings into a max pooling layer:\n\n\n    c = max([v_1, v_2, ..., v_M]) = max(V)\n\nwhere c is the code representation produced by our xASTNN. max is utilized to choose the most important semantics of enhanced subtree representations.\n\n\n\n\n\n \u00a7.\u00a7 Dynamic Batching Algorithm\n\n\n\nIn order to make our xASTNN competent in industrial practice, we propose an acceleration method named dynamic batching algorithm for GRvU, aiming to greatly improve the efficiency of the proposed approach. This algorithm allows completely parallel computation on subtree nodes of the same depth in a batch of data samples. Previous approach <cit.> also makes efforts to speed up the recursive network, however, it still suffers from the incomplete parallel computation. Figure <ref> illustrates the comparison between the previous study <cit.> and ours. Given a batch of data samples, the previous approach <cit.> processes the children of subtrees one by one. However, our dynamic batching algorithm supports full parallelism even in the width dimension, which is much faster than the previous approach.\n\n\n\nThe workflow of dynamic batching algorithm is shown in Algorithm <ref>. It takes a batch of subtree sequences as input, and outputs the corresponding batch of subtree embedding sequences that contain syntactical information. The main body of Algorithm <ref> starts from line 14. We first initialize two empty lists for storing length of each subtree sequence (line 14) and all subtrees of the batch (line 15), respectively. For each subtree sequence (line 16), we cache the amount of subtrees within the subtree sequence (line 17) and flatten all subtrees into the list batch (lines 18-20). Through performing  function (lines 1-13), we enhance the subtree embeddings with syntactical information (line 22) and recover them to the original form of a batch (lines 23-29). The recovery procedure starts with the initialization of a list to store final result (line 23) and a record variable (line 24). Then, we extract the corresponding subtree embeddings (lines 26-29) according to length of each subtree sequence (line 25).\n\nThe function  is designed for processing a batch of subtrees simultaneously. It accepts a list of subtrees as input (line 1) and outputs their embeddings learned by GRvU (line 13). This function initializes two lists for storing root (line 2) and children (line 3) of each subtree. For each subtree in the list of subtrees (line 4), we extract the root (line 5) and its children (lines 6-8), which enables the algorithm to process the contents of the same tree depth within a batch of data samples. We apply  to produce the embeddings of roots (line 10) and  to acquire the hidden state of subtrees (line 11). At last, the hidden states of current roots can be calculated using  (line 12). This recursion ultimately returns the embeddings of the subtrees that initially provided to the function  (line 13).\n\nThe overall time complexity of dynamic batching algorithm is O(BLWD), where B is the batch size, L is the average length of subtree sequence, W is the average width of subtrees, and D is the average depth of subtrees. It comes from three parts: O(BL) for flattening subtrees, O(BLWD) for bottom-up recursion, and O(BL) for recovering a batch of subtree sequences. Further, given a fact that the AST size O(A) is basically equal to the product of L, W, and D, we can conclude that the overall time complexity of the proposed algorithm is linear to the batch size B and the AST size A. Here, the batch size B is a hyperparameter set by developers, but the AST size L, W, and D is influenced by the data and the granularity to transform AST into subtrees. A smaller L may lead to a larger W and D in the experiments. In our empirical analysis, we found that transforming AST into statement subtrees can advance the generalizability while guaranteeing the efficiency. The rationale might be that statement subtree sequences can well capture the code naturalness and have stable subtree depth. Moreover, the computation time is also affected by a few exceptional circumstances. When some subtrees within a batch have a significantly large depth, our dynamic batching algorithm should conduct extra executions for these subtrees. In practice, we could put the processing of these subtrees together to make the subtree depth as balanced as possible, which we leave for future work.\n\n\n\n \u00a7.\u00a7 Differences from ASTNN\n\n\nOur xASTNN spares no efforts to improve the previous code representation approach for industrial practice. The differences between the previous ASTNN and our xASTNN is as follows.\n\nWe adopt gating mechanism throughout the encoding pipeline. Specifically, a child-sum gated recursive unit named GRvU is proposed to encode the syntactical information of statement subtrees. We artificially let the gates position-insensitive, alleviating the computational complexity of space and time for industrial practice. The gates refine the latent information of the code segment, consequently guaranteeing the effectiveness of our xASTNN.\n\nWe introduce the gating mechanism also for applicability. The previous approach simply leverages fully-connected layer to capture the information of subtrees, which can be easily trapped in gradient problems. Their feedforward computation is as follows.\n\n    h_j = \u03c3(W x_j + \u2211_k=1^N h_jk + b)\n\nWhen we perform the back propagation for training the model, the gradient of the parameter W in fully-connected layer is as follows.\n\n    \u2202 J/\u2202 W = \u2202 J/\u2202 h_0\u2202 h_j/\u2202 x_j + \u22ef + \u2202 J/\u2202 h_j\u2202 h_j/\u2202 h_jk\u2202 h_jk/\u2202 h_jkl\u22ef\u2202 h_jkl \u22ef p/\u2202 h_jkl \u22ef pq\u2202 h_jkl \u22ef pq/\u2202 x_jkl \u22ef pq\n\nwhere h_jk denotes the k-th child of the node j, h_jkl denotes the l-th child of the node jk, and so on. J denotes the loss function. We can observe that the gradient is composed by multiplications of many terms due to the recursive processing of child nodes. The accumulation of these terms may easily lead to a gradient of 0 or infinity, making it hard to train the model. In our scenarios, when the length of code segment is large (e.g., 100), the gradient problems of ASTNN becomes obvious. By contrast, the introduction of gating mechanism in our approach can relieve the gradient problems. The proof can be referred to <cit.>. \n\nBesides, we spare no efforts to optimize the time and space efficiency of our xASTNN. We implement a high-efficient and memory-friendly model compared with the previous approach. That is, our model can still achieve time acceleration and space reduction in the absence of any algorithm. To further accelerate our approach, in this work, we present a dynamic batching algorithm for the processing of subtrees. It adopts more parallel operations and can speed up the model when we feed a batch of data samples. \n\n\n\n\n\u00a7 EVALUATION\n\n\n\nWe validate the proposed approach in three aspects.\n\n\n    \n  * How effective is the proposed approach? In industrial applications, the effectiveness of code representation is of importance. A high-quality representation can lead to better performance in code-related downstream tasks. By comparing metrics of our approach and the baselines with two program comprehension tasks, we evaluate the effectiveness of the proposed approach.\n    \n  * What is the efficiency of our approach? When applying the representation model in practice, the efficiency is a huge challenge. From the perspective of time and space efficiency, we measure the practical usability of each approach.\n    \n  * What are the effects of different designs for the proposed xASTNN? This research aspect plays a key role in the refinement of the model. We explore the performance of alternative designs of our approach by ablating or adjusting some designed modules. The results are organized and analyzed.\n\n\n\n\n\n\n \u00a7.\u00a7 Experimental Setup\n\n\n\n  \u00a7.\u00a7.\u00a7 Datasets\n\n\nWe conduct two downstream tasks including code classification and code clone detection for evaluation. The code classification measures the fundamental ability to comprehend the programs. And the code clone detection measures the ability to compare two code segments. Table <ref> illustrates the detailed description of used datasets, with the statistics of code segments, categories, tokens, AST depth, and AST nodes.\n\nIn the code classification task, we adopt a widely used <cit.> public dataset named POJ[<https://sites.google.com/site/treebasedcnn>] <cit.> to measure the quality of code representations. This dataset is collected from a pedagogical programming open judge system, which consists of a large number of programming problems. Students submit their source codes as solutions; the judge system will automatically validate the correctness of the solutions. POJ contains 104 programming problems, which are considered as categories predicted by approaches. Each problem contains 500 C programs, which are considered to belong to the same class. We randomly divide the total 52,000 programs into training, validation, and testing sets with a proportion of 3:1:1. \n\nWe exploit two widely used datasets for the code clone detection tasks: BigCloneBench[<https://github.com/clonebench/BigCloneBench>] <cit.> and OJClone, which are also used in <cit.>. BigCloneBench is a handcrafted dataset that consists of known true and false positive clones. It was built by mining at first and then manually checking clones of ten common functionalities, with 3 judges over 216 hours of manual validation efforts. BigCloneBench is collected from 25,000 systems, covers 10 functionalities including 6,000,000 true clone pairs. Similar to previous work <cit.>, we randomly select 100 thousand samples for the convenience of evaluation. We have manually checked that most of the code segments within BigCloneBench are methods, which is different from another code clone detection dataset, OJClone, where code segments are generally functionalities implemented by multiple methods. OJClone derives from POJ automatically. As <cit.> did, we choose the first 15 programming problems from POJ, which produces 15 \u00d7 500 = 7500 code segments. In OJClone, the two segments from the same programming problems form a clone pair; otherwise, they belong to a non-clone pair. This will provide us with 28 million clone pairs, making it immensely time-consuming to conduct experiments. Likewise <cit.>, we randomly select 50 thousand samples instead. The OJClone dataset is generated completely automatically, without the manual checking of experts. Most of the clone pairs within OJClone are syntactically dissimilar so that the comparative ability of the competing approaches can be well measured.\n\n\n\n  \u00a7.\u00a7.\u00a7 Metrics\n\nIn the code classification task, we choose accuracy in test set as the evaluation metric. It represents the proportion that how many data samples are correctly classified. \n\nIn the code clone detection task, we apply precision, recall, and F1 score as the metrics. Precision indicates how many of the predicted clone pairs are really clone pairs. Recall indicates how many of the clone pairs are correctly predicted. F1 score is the harmonic mean of the precision and recall.\n\n\n\n  \u00a7.\u00a7.\u00a7 Baselines\n\n\nWe consider the following approaches as the baselines for code classification. Some of them can also be applied in the code clone detection task.\n\n\n    \n    \n    \n    \n    \n  * SVM+N-gram <cit.>: A machine learning-based approach that incorporates SVM and N-gram for code classification.\n    \n  * Transformer <cit.>: A recent popular approach that introduces the parallel attention mechanism and deep residual block to encode the tokens. \n    \n  * CodeBERT <cit.>: A bimodal pre-training approach for natural language and programming language based on Transformer neural architecture.\n    \n  * TreeLSTM <cit.>: A novel approach that applies LSTM over ASTs to produce code representations.\n    \n  * TBCNN <cit.>: A novel approach that applies convolutions over ASTs to produce code representations.\n    \n  * code2vec <cit.>: A recent popular code representation approach that extracts AST paths from the AST at first and applies attentional aggregation upon these paths to produce the code representation. \n    \n  * ASTNN <cit.>: A novel superior approach that follows a similar pipeline compared with ours, with lower generalizability and serious efficiency problem.\n    \n  * InferCode <cit.>: A self-supervised pre-training approach, which pre-trains a TBCNN model by predicting subtrees. \n    \n  * inst2vec <cit.>: A novel approach that first constructs the conteXtual flow graph and applies RNN to produce the code representation.\n    \n  * GGNN <cit.>: A well-designed graph neural approach, which first adds edges to ASTs and adopts GGNN <cit.> to represent the source code.\n    \n  * GraphCodeBERT <cit.>: A upgraded version of CodeBERT that considers data flows of programs.\n\n\nWe also select three representative approaches designed for code clone detection particularly.\n\n\n    \n  * Deckard <cit.>: A traditional approach that utilizes subtrees to identify code clones efficiently.\n    \n  * SourcererCC <cit.>: A traditional token-based code clone detection approach, which can detect exact and near-miss clones efficiently.\n    \n  * CDLH <cit.>: A deep learning-based clone detector that adds a hash function to TreeLSTM for code clone detection.\n\n\nAll the experiments are conducted on a 64-bit platform equipped with 12-core Intel(R) i7-12700KF CPU@3.60GHz, 128GB of RAM, and a 24GB RTX 3090 GPU. \n\n\n\n\n\n \u00a7.\u00a7 Effectiveness Assessment with Two Tasks\n\n\n\n  \u00a7.\u00a7.\u00a7 Code Classification\n\nWe exploit the code classification task to measure the fundamental ability of the models to comprehend the programs. In this task, three categories of baselines are considered, including two token-based approaches, five AST-based approaches, and two graph-based approaches. Among them, CodeBERT and InferCode are representative pre-training techniques designed for programming languages. Table <ref> reports the accuracy in test set of competing approaches.\n\nIt can be seen that our xASTNN outperforms all baselines, achieving the highest accuracy of 0.985. Its advantages in accuracy over baselines are significant, improving token-based approaches 1.03% to 16.29%, AST-based approaches 0.31% to 14.42%, and graph-based approaches 0.31% to 3.6%. This validates that our approach is effective in learning program semantics and can produce good code representations.\n\nWe find that the performance of the token-based approaches differs in test accuracy. SVM+N-gram achieves the lowest accuracy in comparison with other approaches, showing that the use of tokens is not sufficient for code representations. Transformer has a very strong fitting ability among token-based approaches, achieving an accuracy of 0.907. Further, by pre-training the Transformer neural architecture based on a large-scale bimodal task, CodeBERT improves the accuracy of the vanilla Transformer to 0.975.\n\nTo improve the comprehension ability of models, many approaches incorporate ASTs for capturing the syntactical information of the source codes. As three representative code feature learning approaches, the accuracy of TreeLSTM, TBCNN, and code2vec is not high, with an accuracy of 0.860, 0.940, and 0.913, respectively. This is because they do not have well-designed modules for processing ASTs and simply incorporate the syntactical information by LSTM, convolutions, and leaf-to-leaf paths. In contrast, the accuracy achieved by ASTNN and InferCode is high. ASTNN is an AST-based approach that introduces code naturalness by statement subtree sequence and InferCode extensively pre-trains their TBCNN model by predicting subtrees.\n\nAs for the graph-based approaches, it can be seen that both inst2vec and GGNN achieve relatively high accuracy. They both represent the source codes by constructing flow graphs. The difference is that inst2vec adopts RNN to encode flow graphs while GGNN uses a graph neural network. The pre-trained approach GraphCodeBERT achieves a high accuracy of 0.982, showing that the introduction of syntactical information can improve the performance of the token-based CodeBERT.\n\n\n\n  \u00a7.\u00a7.\u00a7 Code Clone Detection\n\n\n\n\nTo sufficiently evaluate the effectiveness of approaches, we also introduce code clone detection, a task that is widely used in code refactoring and vulnerability detection. We consider two lines of approaches as baselines, including code representation approaches and specialized clone detectors. The results are shown in Table <ref>.\n\nComparing with eight baselines, we can find that the effectiveness of our xASTNN is the most superior on two datasets. xASTNN achieves an F1 score of 0.966 on BigCloneBench and 0.992 on OJClone, improving the leading baseline GraphCodeBERT by 1.68% on BigCloneBench and 0.40% on OJClone. \n\nTwo traditional approaches, Deckard and SourcererCC, are unable to handle syntactically dissimilar code clones, as revealed in their recall. But their precision is high, which illustrates that they can precisely distinguish syntactically similar code clones. As for deep learning-based approaches, we note that code2vec, TBCNN, and CDLH all achieve relatively high F1 score compared with the traditional approaches. The advantages of these approaches come from the deep learning features. Nevertheless, it can be observed that ASTNN, CodeBERT, and GraphCodeBERT have a remarkable performance in this task. This shows that their fitting ability is superior compared to the other deep learning-based approaches. An interesting phenomenon is that ASTNN, CodeBERT, and GraphCodeBERT have high precision and low recall in most cases, suggesting that they tend to make confident predictions. \n\n\n\n[colback=gray!10,\n                  colframe=black,\n                  width=8.5cm,\n                  arc=1mm, auto outer arc,\n                  boxrule=0.75pt,\n                 ]\nConclusion 1: Through evaluating our approach and the baselines in two code comprehension tasks, we can find that our xASTNN is very generalized and effective.\n\n\n\n\n\n\n\n\n \u00a7.\u00a7 Efficiency of Models\n\nTo evaluate the time efficiency of models, we measure their computation time from the acceptance of a code segment to the output of its representation. The reciprocal of this metric is known as prediction rate, which reflects the number of data samples a model can process in one second. This experiment is conducted on a broad corpus of real-world programming languages. A batch of data samples is fed into the code representation model and the average computation time for representing one code segment is reported.\n\nFigure <ref> shows the computation time of baselines along with our approach and its variants (batch size is set to 64). It can be observed that our approach costs 0.23 ms to represent a code segment, faster than all the baselines. It accelerates code2vec 1.8\u00d7, CodeBERT 2.2\u00d7, GraphCodeBERT 2.7\u00d7, ASTNN 9.3\u00d7, and TreeLSTM 21.9\u00d7. \n\nThe computation time of baselines is high, ranging from 0.41 ms to 5.02 ms. code2vec is fast because it represents source code by parallelly encoding a bag of AST paths. CodeBERT parallelly processes tokens of source code and GraphCodeBERT adds the processing of data flows to CodeBERT. The computation time of ASTNN and TreeLSTM is long. The reason is that they involve syntactical information processing but no efficient algorithms are particularly designed. \n\nTwo variants with different subtree granularity perform differently in computation time. Here, we consider the two most special cases, i.e., the largest subtree based on the whole AST named xASTNN (AST) and the smallest subtree based on all AST nodes named xASTNN (token). It can be noted that when the size of subtree gets smaller, the computation time for representing one code segment gets smaller. The reason is that smaller subtrees need fewer recursive operations and these operations are exactly taking up a large portion of the overall computation time.\n\n\n\n\nIn addition to the experiment of average computation time, we conduct another experiment to measure the effect of batch size on the time and space efficiency of the previous approach and our approach, aiming to validate the performance of the proposed dynamic batching algorithm. Figure <ref> illustrates the results. Note that when the batch size is larger than 128, the previous approach ASTNN will suffer from a memory overflow problem. Hence, we do not report the corresponding results.\n\nIn the aspect of time efficiency, we can observe that our approach is faster than the previous approach at all batch sizes, indicating the superiority of our dynamic batching algorithm. As the batch size increases, the computation times of two approaches both decrease. However, their rates of decline are different. We note that the speedup ratio first increases and then decreases as the batch size goes. The peak value of speedup ratio (i.e., 10.5\u00d7) occurs when the batch size is around 32. The rationale for this phenomenon can be inferred from their time complexity (see Figure <ref>). With the increase of batch size, many subtrees of different depths will appear in the batch and dominates the time complexity. This requires our approach to cost plenty of time for these special subtrees, thus resulting in the attenuation of the speedup ratio. Theoretically, if similar-sized subtrees are processed together, this problem will be significantly alleviated. We leave it for future work.\n\nIn the aspect of space efficiency, we can see that our approach uses less memory at all batch sizes compared with the previous approach. The GPU usage of both two approaches increases quickly as the batch size increases. When the batch size is equal to 1, our approach still has the advantage in GPU usage, showing its superiority in the processing of single data sample. Similar phenomenon can be found in terms of time efficiency. This is because we optimize the implementation of our xASTNN to make it as lightweight as possible for industrial practice. Hence, when the batch size is set to be large, the improvement in GPU usage of our approach becomes more pronounced. Additionally, an interesting phenomenon is that the GPU usage does not change obviously when the batch size is less than 4. The model size is the main influencing factor for GPU usage at this point.\n\n\n\n\n[colback=gray!10,\n                  colframe=black,\n                  width=8.5cm,\n                  arc=1mm, auto outer arc,\n                  boxrule=0.75pt,\n                 ]\nConclusion 2: The efficiency of our xASTNN is promising, which is reflected in both time and space. The computation time on the order of 10^-4 seconds allows our approach to be used in a wide range of industrial applications.\n\n\n\n\n\n\n\n\n \u00a7.\u00a7 Effect of Alternative Designs\n\n\n\nIn this experiment, we investigate the effect of alternative designs for the proposed approach xASTNN, aiming to give explanations about the efficacy of each designed components. We consider POJ as the representative dataset, on which all the results are produced.\n\nAt first, we evaluate the alternative designs from the following three perspectives: program subtree or token subtree from the perspective of subtree granularity, removing or replacing GRvU from the perspective of syntactical information, and removing or replacing GRtU from the perspective of sequential information. The performance of these variants are reported in Table <ref>.\n\nIt can be observed that our approach outperforms all the variants, showing that the current design of our approach is effective. When we adjust the subtree granularity, the accuracy decreases by 0.033 to 0.952 for program subtree and by 0.014 to 0.971 for token subtree. This result exhibits that an appropriate subtree granularity is of importance in capturing code naturalness. If the granularity of the subtree is too large or too small, the syntactical or the sequential information will be lost during the modeling process.\n\nWhen we modify the encoder for syntactical or sequential information, the performance of these variants are different. When we replacing GRvU with RvNN or replacing GRtU with RtNN, the accuracy drops by 0.004 to 0.981. Nevertheless, if we remove one of the encoders, the accuracy will decline drastically, resulting in a decrease in accuracy of 0.158 or 0.009 respectively. This demonstrates that both syntactical information and sequential information introduced by our xASTNN plays a key role in code representations.\n\n\n\nIn addition, we introduce another alternative design, namely xASTNN of different sizes, to investigate the effect of model size on performance. We vary the embedding dimension in xASTNN and the results are reported in Table <ref>. It shows the correlation of GPU usage, time, and accuracy with embedding dimension. \n\nFrom the results, it can be noted that the GPU usage quickly increases as the dimension increases, from 1.4 GB to 9.3 GB. The GPU usage grows slowly at first, which is because the running buffer takes up a large amount of space. When the embedding dimension reaches to a certain degree (e.g., 64), its impact on GPU usage becomes significant. As for the computation time, a similar phenomenon appears when the embedding dimension reaches 512. The accuracy is strongly influenced by the embedding dimension. It starts at 0.065, increases rapidly to over 0.976, and converges. This demonstrates that the quality of code representations is highly related to the model size. Therefore, we should consider balancing space, time, and accuracy in practice.\n\n\n\n\n[colback=gray!10,\n                  colframe=black,\n                  width=8.5cm,\n                  arc=1mm, auto outer arc,\n                  boxrule=0.75pt,\n                 ]\nConclusion 3: The design of our xASTNN is reasonable. Each module of our approach has a different effect on its performance, requiring the developers to carefully tune the parameters according to the production requirements.\n\n\n\n\n\n\n\n\u00a7 THREATS TO VALIDITY\n\n\n\nIn this section, we discuss the threats to our work. The first limitation is that some of our experiments are not based on real-world programming language corpus. For convenience of extensive evaluations on the performance of baselines and our approach, we choose to adopt the widely-used benchmark datasets instead of our non-public data. Additionally, recent study <cit.> suggests that BigCloneBench are considered harmful for evaluating machine learning approaches. Despite these defects, we believe that our experiments are still worthy to be used as a reference for the superiority of our xASTNN. The second limitation is that the insufficient investigation of the robustness of the competing approaches. The results reported in this work are in the common form of the average or maximum performance. Nevertheless, the stability of model performance is not measured. This measurement can illustrate whether a model has performance jitter and makes abnormal predictions. We leave this to future work.\n\n\n\n\u00a7 LESSONS LEARNED\n\n\n\nFrom the work of developing code representation for industrial practice, we have learned three significant lessons: \n\nMaking the code representation model applicable to various scenarios is an important issue. Developing high-quality source code representations have aroused many interests recently. Some approaches borrow complicated characteristics of programming languages to improve the effectiveness of their models, making them hard to be applied in practice. Besides, an inappropriate model design and implementation can also introduces many practical problems, such as memory overflow, runtime delay, and difficult objective fitting.\n\nReaching a trade-off between effectiveness and efficiency is very high priority for industrial practice. In different industrial scenarios, the application of code representation model may encounter different computing environments and business requirements. Our experiment results show that the effectiveness of our approach can be improved by increasing the model size, while sacrificing the time and space efficiency. Hence, adjusting the model in terms of the actual needs is advisable in industry.\n\nUnusual data inputs have a dramatic impact on the model performance. There are few extremely long or short code segments in practice, which are often deleted by most of academic experiments. These data samples can easily lead to gradient vanishing or explosion problems. Moreover, a batch of size-unbalanced data samples costs more time to process. The approach should spare computing resources for those special data samples. Hence, if we do not pay attention to these unusual data in industry, the performance of the model will be weakened.\n\n\n\n\u00a7 CONCLUSION\n\n\n\nIn this paper, we propose an eXtreme AST-based neural network named xASTNN for producing code representations in industry. The design of xASTNN concentrates on unlocking the potential of AST-based neural network. Our approach is completely based on common ASTs, which is easily accessed by AST parsers. Besides, we introduce techniques such as gating mechanism and dynamic batching algorithm to advance the performance, reduce the computation time, and alleviate the gradient problems. Extensive experiments on two code comprehension tasks have been conducted to demonstrate the effectiveness and efficiency of our xASTNN. According to the results, we can see that our xASTNN outperforms the state-of-the-art while achieving an acceleration of over 10\u00d7 than the previous approach ASTNN. Therefore, the proposed approach is lightweight, effective, and efficient, with the promising possibility of being applied in a wide range of industrial applications.\n\n\nACM-Reference-Format\n\n\n"}