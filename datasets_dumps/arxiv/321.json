{"entry_id": "http://arxiv.org/abs/2303.06890v1", "published": "20230313063041", "title": "Scalable Program Implementation and Simulation of the Large-Scale Quantum Algorithm: $1024\\times 1024$ Quantum Linear Solver and Beyond", "authors": ["Zhao-Yun Chen", "Cheng Xue", "Xi-Ning Zhuang", "Tai-Ping Sun", "Huan-Yu Liu", "Ye Li", "Yu-Chun Wu", "Guo-Ping Guo"], "primary_category": "quant-ph", "categories": ["quant-ph"], "text": "\n\nAPS/123-QED\n\n\n\n\n\n chenzhaoyun@iai.ustc.edu.cn\n\n\u00a0Institute of Artificial Intelligence, Hefei Comprehensive National Science Center, Hefei, Anhui, 230026, P. R. China\n \n\u00a0CAS Key Laboratory of Quantum Information, University of Science and Technology of China, Hefei, Anhui, 230026, P. R. China  \n\u00a0Origin Quantum Computing Company Limited, Hefei, Anhui, 230026, P. R. China\n\n\n\u00a0CAS Key Laboratory of Quantum Information, University of Science and Technology of China, Hefei, Anhui, 230026, P. R. China\n\u00a0CAS Center For Excellence in Quantum Information and Quantum Physics, University of Science and Technology of China, Hefei, Anhui, 230026, P. R. China\n\u00a0 Hefei National Laboratory, Hefei, Anhui, 230088, P. R. China\n \n\u00a0Origin Quantum Computing Company Limited, Hefei, Anhui, 230026, P. R. China\n\n\u00a0wuyuchun@ustc.edu.cn\n\u00a0Institute of Artificial Intelligence, Hefei Comprehensive National Science Center, Hefei, Anhui, 230026, P. R. China\n\u00a0CAS Key Laboratory of Quantum Information, University of Science and Technology of China, Hefei, Anhui, 230026, P. R. China\n\u00a0CAS Center For Excellence in Quantum Information and Quantum Physics, University of Science and Technology of China, Hefei, Anhui, 230026, P. R. China\n\u00a0Hefei National Laboratory, Hefei, Anhui, 230088, P. R. China\n\n \u00a0gpguo@ustc.edu.cn \n\u00a0Institute of Artificial Intelligence, Hefei Comprehensive National Science Center, Hefei, Anhui, 230026, P. R. China\n\u00a0CAS Key Laboratory of Quantum Information, University of Science and Technology of China, Hefei, Anhui, 230026, P. R. China\n\u00a0CAS Center For Excellence in Quantum Information and Quantum Physics, University of Science and Technology of China, Hefei, Anhui, 230026, P. R. China\n\u00a0 Hefei National Laboratory, Hefei, Anhui, 230088, P. R. China\n\u00a0Origin Quantum Computing Company Limited, Hefei, Anhui, 230026, P. R. China\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n             \n\n\nProgram implementation and simulation are essential for research in the field of quantum algorithms. However, complex and large-scale quantum algorithms can pose challenges for existing quantum programming languages and simulators. Here, we present a scalable program implementation of the quantum walk on a sparse matrix and the quantum linear solver based on the quantum walk. Our implementation is based on a practical scenario in which the sparse matrix is stored in the compressed-sparse-column format in quantum random access memory. All necessary modules are implemented unitarily and are ensured to be decomposed at the quantum gate level, including implementing a quantum binary search and a modification of the original algorithm. The program is validated using a highly efficient quantum circuit simulator which is based on the register level and sparse state representation. With only a single core, we simulate the quantum walk on a 16384-dimensional matrix with 582 qubits in 1.1 minutes per step, as well as a quantum linear solver up to 1024 dimensions and 212245 steps in 70 hours. Our work narrows the gap between the simulation of a quantum algorithm and its classical counterparts, where the asymptotic complexity of our quantum linear solver simulation approximates a classical linear solver. These program implementation and simulation techniques have the potential to expand the boundary of numerical research for large-scale quantum algorithms, with implications for the development of error-correction-era quantum computing solutions.\n\n\n\n\n\n\n\n\n\n\n                              \nScalable Program Implementation and Simulation of the Large-Scale Quantum Algorithm: 1024\u00d7 1024 Quantum Linear Solver and Beyond\n    Guo-Ping Guo\n    March 30, 2023\n================================================================================================================================\n\n\n\n\n\n\n\n\u00a7 INTRODUCTION\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOver the past few decades, there has been significant development in the field of quantum algorithms. One notable example is the quantum walk, which has shown itself to be a powerful tool with a wide range of applications<cit.>. In particular, the quantum walk on a sparse matrix can be used to implement Hamiltonian simulation and the quantum linear solver<cit.>. As a follow-up, the quantum linear solver is often utilized as the fundamental \"quantum speedup\" subprocess for many other quantum algorithms, including quantum machine learning<cit.> and quantum accelerated equation solvers<cit.>, which are promising to achieve the quantum advantage in real-world tasks.\n\nWhen these algorithms claim to achieve quantum speedup in terms of asymptotic complexity, it is essential to implement programs and conduct classical simulations to assess their actual performance. However, implementing the quantum walk with existing quantum programming languages and simulators<cit.> can be difficult. One major challenge is that the unitary implementation of the quantum walk has not been fully clarified in previous works<cit.>, particularly in terms of how to implement all required oracles. Other difficulties include a lack of support for quantum random access memory (QRAM)<cit.>, the implementation of quantum arithmetics, management of ancilla resources, and the inability to simulate a large-scale quantum program with more than 100 qubits and a sufficiently large depth. \n\n\n\n\n\n\n\n\n\n\nIn this study, we propose a practical and scalable program implementation method for the quantum walk. To increase practicality, we store the sparse matrix in the QRAM using the compressed-sparse-column (CSC) format<cit.>, which is a common format in classical scientific computing<cit.>. The access of the matrix is completely based on the QRAM queries. To extract the sparsity information of the matrix, the quantum computer must find the position of a column in the compressed storage providing the column indices<cit.>. When the column indices are stored in sorted order, we choose the quantum binary search to implement this oracle. We introduce how a while loop of \u201cquantum data, quantum control\u201d<cit.> can be performed coherently in a quantum computer<cit.> and the method for automatic management of ancilla registers. Based on the quantum binary search, we propose a modified version of the original quantum walk. This version unitarily implements the sparsity oracle by adding two extra registers, which adapts to the cases where the oracle receives unexpected inputs.\n\nThe program is scalable and can adapt to inputs of various sizes, including the dimensions of the matrix, its sparsity, and the size of the matrix elements. We execute the quantum walk program using a quantum circuit simulator on randomly generated band matrices with dimensions ranging from 16 to 16384. These problems require a circuit size that exceeds the limit of all existing simulators, so we propose a novel method called the sparse state simulator to simulate the quantum circuit on the register level and only store the nonzero components of the quantum state. The basic operations of this simulator include quantum arithmetic<cit.>, QRAM queries, conditional rotation, and other essential operations, which can all be simulated as a whole on the register level. The complexity of the simulation is mainly based on the number of nonzero states and is not limited by the number of qubits. On a single core, each quantum walk step uses 1.1 minutes for a 16384\u00d7 16384 matrix and 1.2 seconds for a 1024\u00d7 1024 matrix, with a maximum of 582 working qubits. We also program and test Chebyshev's approach of the CKS (Childs, Kothari, Somma) quantum linear solver<cit.> on matrices up to 1024 dimensions. As a result, the 1024\u00d7 1024 linear solver takes 70 hours to simulate on a single core.\n\nAll techniques developed in this paper can be a reference for future research on large-scale quantum algorithms, including but not limited to quantum machine learning, and quantum differential equation solvers which may use hundreds of, even thousands of qubits. \n\nThis paper is organized as follows. Section\u00a0<ref> overviews our work, and introduces some fundamentals about the quantum walk and the sparse storage in the QRAM. Section\u00a0<ref> firstly implements a quantum version of the binary search algorithm, then construct a modified version of O_s, an input oracle required by the quantum walk algorithm. Section\u00a0<ref> scalably implements the remaining parts of the quantum walk. Section\u00a0<ref> introduces a novel quantum circuit simulator and shows the numerical results on various sizes of matrices. Later on, we also analyze the reason why we can simulate a quantum algorithm with such a number of qubits. Section\u00a0<ref> summarizes the results and outlooks for future works including the scalable implementation of other algorithms, and also the classical simulation on the quantum register level.\n\n\n\n\u00a7 PRELIMINARIES\n\n\n\n\n\n\n \u00a7.\u00a7 Overview\n \n\nThe quantum walk on a sparse matrix holds great potential for achieving quantum speedup on practical problems such as solving linear systems. If one hopes to apply this algorithm to real-world problems, it is crucial to consider how the input matrix is provided. In this study, we focus on the practical scenario, in which the sparse matrix is stored in the sparse form in the quantum random access memory. This means that all the subprocesses required for a quantum walk, also known as oracles, can only be obtained by accessing the QRAM. Therefore, our quantum program implementation is based on QRAM access and arithmetic operations to process data in quantum parallel. With all the subprocesses implemented in a standard manner, we ensure that this program can be reproduced on future quantum computers and that its time complexity is consistent with the original quantum walk theory.\n\nTo implement the sparsity oracle by accessing the CSC sparse matrix, we designed a quantum binary search subroutine, which can find the corresponding sparse number according to the column number of a non-zero element. However, the quantum binary search may produce garbage when the input is not included in the search list, which is common in walking multiple steps. Therefore, we also adjusted the form of the quantum walk operator by increasing two extra registers to accept all inputs.\n\nFinally, we show the results of this program executed in a new quantum circuit simulator, including the quantum walk of a 16384-dimensional matrix and the linear system solving of the 1024-dimensional matrix. By comparing with the theoretical quantum walking results, we verify the correctness of the program.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \u00a7.\u00a7 Quantum walk on a sparse matrix\n\n\n\nA sparse matrix is a kind of matrix whose zeros occupy most positions, which is very common in various fields. Many works proposed methods to achieve quantum speedup in the solution of sparse linear systems. A formal problem statement was proposed in <cit.> and we will follow these definitions throughout this paper. To input the matrix A, two oracles are required. One is O_A, named as \u201cmatrix element oracle\u201d, which is \n\n    O_A|j\u27e9|k\u27e9\u21a6 |j\u27e9|k\u27e9|A_jk\u27e9,\n\nwhere A_jk is the matrix element in row j and column k, and |A_jk|\u2264 1. The other is O_s, named as \u201csparsity oracle\u201d, which is\n\n    O_s|j\u27e9|k\u27e9\u21a6 |j\u27e9|l_j,k\u27e9,\n\nwhere the l_j,k-th nonzero element is at column j. It is worth mentioning that O_s is an in-place operation, which means the inverse function (from l_j,k to k) is also available.\n\nThe quantum walk is acted on four quantum registers, that is \u210b^N\u2297\u210b^2\u2297\u210b^N\u2297\u210b^2. The walk operator is a unitary\n\n    U=S(2 T T^\u2020-1),\n\nwhere T is an isometry T=\u2211_j \u2208[N]|\u03c8_j\u27e9\u27e8 j| and S the swap between the first two and the last two registers. And we have \n\n\n    |\u03c8_j\u27e9=|j, 0\u27e9   \u2297   1/\u221a(d)\u2211_k \u2208[N]: A_j k\u2260 0\n          (\u221a(A_j k^*)|k, 0\u27e9+\u221a(1-|A_j k|)|k, 1\u27e9) .\n\nRepeating U to extract the information in A is the essential process of the quantum walk.\n\n\n\n \u00a7.\u00a7 Sparse matrix storage model in the quantum random access memory\n\n\n\n\nA sparse matrix is a matrix where zero occupies most positions. More specifically, a matrix is called s-sparse if each column has at most s nonzero elements. There are many formats for storing a sparse matrix, among which the compressed-sparse-column (CSC) format is widely applied in various scenarios and is more intuitive in the quantum walk task. The CSC format compresses each row and only stores the nonzero entries for every row. Meanwhile, the format also stores the column indices of each element correspondingly. \n\nIn Fig.\u00a0<ref>, we demonstrate how a sparse matrix is stored in the QRAM, which includes two continuous segments: the matrix element segment and the sparsity segment. The matrix element segment stores the nonzero data entries a_j,l = A_jk in each row, and the sparsity segment stores the column indices k_j,l of the corresponding data entries. We specify the number of nonzero elements per row as a constant s and fill zeros when the number of nonzeros is less than s. To enable the binary search on the sparsity segment, the column indices in the same row are in sorted order.\n\n\n\n\n\n\n\n\u00a7 IMPLEMENTING O_S VIA THE QUANTUM BINARY SEARCH\n\n\n\n \u00a7.\u00a7 Quantum binary search\n\nUnitary implementation of O_s is an in-place computation from |l\u27e9 to |k_j,l\u27e9, which implies that the out-of-place computation |j,l\u27e9\u21a6 |j,l\u27e9|k_j,l\u27e9 and its inverse |j,k_j,l\u27e9\u21a6 |j,k_j,l\u27e9|l\u27e9 are both required. The former mapping is straightforward with the CSC format, but the inverse requires the search from k to l. <cit.> explicitly pointed out that the quantum search is necessary to implement O_s, either the quantum binary search in O(log s) steps when the nonzero column is stored in sorted order, or Grover's search in O(\u221a(s)) steps.\n\nIn this section, we show the unitary implementation of the quantum binary search. First, we define the task.\n\n\nGiven a unique sorted list d_i (i=0,1,...,N-1) compactly stored in the QRAM, quantum binary search (QBS) is a unitary such that\n\n    QBS|a\u27e9|d\u27e9|j\u27e9 = |a\u27e9|d\u27e9|j\u2295 i(d)\u27e9,\n\nwhere |a\u27e9 is the address of d_0, |d\u27e9 the target, |j\u27e9 any input, \u2295 the bitwise XOR, and\n\n    i(d)={[                         0 if  d  is not in the list;                         i              if  d[i] = d ]..\n\n\n\nQuantum binary search is a semi-quantum process, which means that it is a quantum circuit implementation of the classical binary search. However, it is nontrivial to convert the recursive process in the binary search to its quantum version. This is called the quantum recursion of the \u201cquantum data, quantum control\u201d model<cit.>, where the recursion process is determined coherently by a quantum variable. \n\nLet us start with a simple and classic model of reversible programming<cit.>, the computation-uncomputation model, shown in Fig.\u00a0<ref>(a). The computation is usually not reversible, therefore some ancillae will be allocated during the computation and be left as the garbage after computation finishes. Later, a reverse uncomputation is performed, returning the garbage to the initial state and discarding them safely. This model is also applied to quantum computing languages such as <cit.>.\n\nFor the quantum recursion, we extend the computation-uncomputation model and propose the push-pop model which is inspired by the classical reversible programming language<cit.>, shown in Fig.\u00a0<ref>. The model contains a garbage stack, which has \u201cpush\u201d and \u201cpop\u201d operations. Each push operation will move the immediate value of a variable to the top of the garbage stack. This happens when the state of the ancilla should be overwritten by a new value, such as starting a new loop cycle and all variables are refreshed. The pop operation reverses the push operation, resuming the value in the computation stage. Consequently, garbage stack records the snapshot of variables whenever their value has to be discarded. \n\nWith the push-pop model, now we can implement the quantum binary search, displayed in Alg.\u00a0<ref>. The quantum loop, as shown from step 4 to step 14 in Alg.\u00a0<ref>, runs different steps depending on the input size, thus creating different numbers of ancilla registers. During the quantum loop, some branches have terminated while others may go further. We let the flag control the termination of a branch. In line 9, the flag register flips when compareEqual is true, which represents the loop breaks when the target is found. While terminated branches copy the target to the output register (line 8), other branches have gone to the next loop. In line 13, at end of the loop body, all old variables are pushed to the garbage stack. The original mid should be regarded as the temporal garbage used to record the branches route for the uncomputation. In line 15, the loop body reverses, such that all ancilla registers return to the |0\u27e9 state, and thus can be discarded safely. Finally, we implement the quantum binary search without creating any garbage, and only output registers are changed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \u00a7.\u00a7 Implementing a modified O_s\n\n\n\n\n\n\n\n\nUsing the QRAM query, one can implement\n\n    QRAM|j\u27e9|l\u27e9|z\u27e9 = |j\u27e9|l\u27e9|z\u2295 k_j,l\u27e9,\n\nwhere k_j,l is the l-th column index of row j. Using the quantum binary search, one can implement\n\n\n    QBS|j\u27e9|k_j,l\u27e9|z\u27e9 = |j\u27e9|k_j,l\u27e9|z\u2295l\u0303\u27e9,\n\nwhere l\u0303=l if k_j,l is a valid column index of row j, and l\u0303 =0 if the input k_j,l does not exist in row j. With Eqn.\u00a0(<ref>) and Eqn.\u00a0(<ref>) and some valid input j and l, we can implement O_s with the following step:\n\n    |j\u27e9|l\u27e9\n    \n        (Allocate)\u27f6   |j\u27e9|l\u27e9|0\u27e9\n    \n        (QRAM)\u27f6   |j\u27e9|l\u27e9|k_j,l\u27e9\n    \n        (QBS)\u27f6   |j\u27e9|0\u27e9|k_j,l\u27e9\n    \n        (Swap)\u27f6   |j\u27e9|k_j,l\u27e9|0\u27e9\n    \n        (Deallocate)\u27f6   |j\u27e9|k_j,l\u27e9.\n\nThis process is reversible, indicating that |j\u27e9|k_j,l\u27e9\u2192 |j\u27e9|l\u27e9 is accepted for valid input j and k_j,l.\n\nDespite the valid inputs, one should notice that there are also some invalid inputs in the computing process. For example, k_j,l may not correspond to any l. Also, there may have l\u2265 s, where s is the maximum number of nonzero entries in a row. This will cause the ancilla register introduced in the first step of Eqn.\u00a0(<ref>) cannot be disentangled in general. If O_s is implemented unitarily and in place, one has to create a bijection mapping that any input 0\u2264 l<N must correspond to a unique 0\u2264 k<N. An intuitive example is shown in Fig.\u00a0<ref>(a), demonstrating a matrix with s=4, and the nonzero column is located in 2, 5, 8, and 10. These valid inputs are marked as blue blocks, where the invalid inputs are marked as green. The red arrows represent the mapping of l\u2265 s, which map input l=4 to k=0, l=5 to k=1, l=6 to k=3, and so forth. Here, the mapping target for l\u2265 s is continuously inserted into the space excluded the indices for nonzero columns. \n\nHowever, we show that the unitary implementation of this intuitive mapping consumes at most O(s) extra time and space, see Appendix Section\u00a0<ref>. To optimize, we propose a method that only consumes O(1) extra space, and O(log s) time to implement the same mapping as required by the quantum walk. Our method is to keep the last register as a working register, and modify the original O_s to a 3-register version O_s' with the following steps:\n\n    |j\u27e9|l\u27e9|z\u27e9\n    \n        (QRAM)\u27f6   |j\u27e9|l\u27e9|z\u2295 k_j,l\u27e9\n    \n        (QBS)\u27f6   |j\u27e9|l\u2295 y(z\u2295 k_j,l)\u27e9|z\u2295 k_j,l\u27e9\n    \n        (Swap)\u27f6   |j\u27e9|z\u2295 k_j,l\u27e9|l\u2295 i(z\u2295 k_j,l)\u27e9,\n\nwhere i(x) denotes the search result produced by the quantum binary search. When z=0 and l<s, this process is identical to the original O_s. The schematic diagram for this mapping is shown in Fig.\u00a0<ref>(b). Alike the above example, we mark the valid inputs as blue blocks and invalid as green, and the mapping is marked as the red arrow. For the first arrow, when O_s'^\u2020 takes k=0 and z=0 input, the QBS cannot find a result and will output l=z=0. Then the QRAM process will read from address 0 and outputs column number 2. The final output will be l=2 and k=0. \n\nBecause the whole process is always closed in these three registers, this bijection mapping is naturally implemented. Instead of mapping from \u211d^N to \u211d^N, this method implements the mapping from \u211d^N^2 to \u211d^N^2. The extra space is the ancilla register used in the QBS, which is an ignorable overhead. Because no extra search is needed, the time cost is mainly due to the QBS, which is O(log s).\n\n\nNext, we show how to use this modified O_s' in the implementation of the quantum walk. Based on O_s', we add two n-qubit registers j_c and k_c, expanding the row and column register j and k correspondingly. Now we rewrite O_s as a mapping between |j\u27e9|l\u27e9|z\u27e9 and |j\u27e9|k\u27e9|k_c\u27e9. \n\nExpanding the original matrix A\u2208\u211d^N\u00d7 N to A'\u2208\u211d^N^2\u00d7 N^2, where A' has the following property: in row j_cj, the index of zl-th column is k_ck, where xy means Nx+y. For the expanded matrix and this mapping, column index and its position index are a bijection, which means that it is reversible implementation of O_s' in A'. When j_c=0, l<s and z=0, we can write its output as k=k_j,l and k_c=0. Therefore, A is exactly located in the left-upper corner of the matrix A', which forms a block encoding of A\n\n    A'=[ A *;   * ].\n\nAs a consequence, the modified quantum walk of A is the walk on the matrix A'.\n\nTo be simple enough, we let the original O_A'|j\u27e9|l\u27e9 controlled by the two newly-added registers' with |j_c\u27e9=|k_c\u27e9=|0\u27e9. Hence, any A'_j_cj,k_ck=0 except for j_c=k_c=0. This simplifies the structure of A' to \n\n    A'=[ A 0; 0 0 ].\n\nAnd it is straightforward to see that any walk operators acting on A' is equivalent to a block operation on A.\n\nFinally, we show the quantum circuit for implementing O_s' in Fig.\u00a0<ref>.\n\n\n\n\n\n\n\n\u00a7 A SCALABLE IMPLEMENTATION OF THE QUANTUM WALK\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \nImplementation of T\u0303\nThe unitary T\u0303 can be treated as a state preparation process controlled by the first register to mark its row index. For simplicity and without loss of generality, we assume constant s is a power of 2. From |j\u0303\u27e9 and concerning the first, third and fourth register, we perform Hadamard on the third register to create the superposition\n\n\n    1/\u221a(s)\u2211_l=0^s-1|j, l, 0\u27e9_j,k,k_c .\n\n\nWe make a tiny modification to the given oracle by defining O_A'|j, l, z\u27e9 = |j, l, z\u2295 a_i,l\u27e9. Note that O_A' and O_A are equivalent because O_A' = O_s^\u2020 O_A O_s. The benefit is that O_A' can be directly implemented with one QRAM query in the CSC format. By applying O_A' and O_s we obtain\n\n    1/\u221a(s)\u2211_k: A_j k\u2260 0|j, k, 0\u27e9|A_jk\u27e9 .\n\n\nFinally, we perform a conditional rotation[Here, the conditional rotation is controlled by the row and column indices to deal with the negative element.] and uncompute |A_jk\u27e9, we can prepare the wanted |\u03c8_j\u27e9. To summarize, we show the circuit in Fig.\u00a0<ref> and the pseudocode of implementing T\u0303 in Alg.\u00a0<ref>.\n\n\n\n\n\n  \nImplementation of O_A'\nO_A' makes access to the QRAM and queries the matrix element with the given input. The QRAM can be written as the following unitary\n\n    U_ QRAM|i\u27e9|j\u27e9\u21a6 |i\u27e9|j\u2295 d[i]\u27e9.\n\nwhere i is the address, d[i] its corresponding data entry and \u2295 denotes the bitwise XOR. Implementing O_A' is straightforward. First, we compute the address from two input registers and the offset, then we call the QRAM and finally uncompute the first step. The circuit is shown in Fig.\u00a0<ref>.\n\n\n\n\n\n\n\n\n\n\n\n  \nImplementation of the quantum walk\n\n\n\n\nWith the modified O_s based on the QBS, now the quantum walk is defined on six registers. Four registers are required by the original quantum walk theory, naming as j, b_1, k, and b_2, each has n, 1, n, and 1 qubit correspondingly. Besides these four, we also extend two more n qubits registers, naming as j_c and k_c. \n\nThen we define |j\u0303\u27e9=|0,j,0,0,0,0\u27e9_j_c, j,b_1,k_c,k,b_2. Also, we expand the |\u03c8_j\u27e9 to |\u03c8\u0303_j\u27e9 by filling zero state similarly. After expansion, we implement a unitary T\u0303 which prepares from |j\u0303\u27e9 to |\u03c8\u0303_j\u27e9, which corresponds to the process where the extended registers begin from |0\u27e9 and return to |0\u27e9 after the preparation finishes, that is\n\n    T\u0303 = \u2211_j \u2208[N]|\u03c8\u0303_j\u27e9\u27e8j\u0303|+\u2211_j^\u22a5|\u03c8\u0303_j^\u22a5\u27e9\u27e8j\u0303^\u22a5|.\n\nNote that \n\n    T\u0303( 2\u2211 _j\u2208 [N] |j\u0303\u27e9\u27e8j\u0303 |-1)T\u0303^\u2020\n    \n    =   (2TT^\u2020 -1 )_j\u2297 |0\u27e9\u27e8 0|_j_c,b_1,k_c,k,b_2\n       +\u2211 _m\u2260 0,n\u2260 0V^mn_j\u2297 |m\u27e9\u27e8 n|_j_c,b_1,k_c,k,b_2\n       =[ 2TT^\u2020 -1;                 * ],\n\nforms a block encoding of the wanted operator 2TT^\u2020-1 where 2TT^\u2020 -1 is defined in the orthogonal subspace of |0\u27e9\u27e8 0|. 2 \u2211_j \u2208[N]|j\u0303\u27e9\u27e8j\u0303|-1 will conditionally occur a phase flip if the state is not |j\u0303\u27e9, and we name it after P.\n\nTo prove that T\u0303 can effectively represent the T, note that\n\n    T\u0303ST\u0303^\u2020 = [ A/s   *;       * ]\n\nforms a block encoding of H=A/s where S swaps j_c,j,b_1 with k_c,k,b_2. This block encoding form is compatible with the theoretical analysis of the walk operator, and we display it in the Supplementary Material. Roughly speaking, we extend the matrix size from N to N^2, where the extended registers j_c and k_c are now considered as the higher digits of the row and column indices, namely j_cj,k_ck, and A exists in the block where j_c=k_c=0.\n\nNow we have a unitary implementation of the walk operator W=ST\u0303PT\u0303^\u2020. To summarize, we show the circuit in Fig.\u00a0<ref>. \n\n\n\n\n\n  \nImplementation of the CKS quantum linear solver\n\nThe CKS quantum linear solver is based on the quantum walk, and is nearly optimal for all parameters. In theory, walking n steps correspond to the n-th order Chebyshev polynomial of the first kind, namely\n\n    T^\u2020 W^nT|\u03c8\u27e9|0\u27e9 = \ud835\udcaf_n(A/d)|\u03c8\u27e9|0\u27e9 + |\u03a8^\u22a5\u27e9.\n\n|\u03a8^\u22a5\u27e9 is some garbage output where the second flag register does not output |0\u27e9. Additionally, A^-1 can be O(\u03f5) approximated by f(A) where\n\n    f(x)   =1-(1-x^2)^b/x\n       =4 \u2211_j=0^j_0(-1)^j[\u2211_i=j+1^b[  2b; b+i ]/2^2 b] \ud835\udcaf_2 j+1(x),\n\nand eigenvalues of A lie in [-1,-1 / \u03ba] \u222a[1 / \u03ba, 1], \u03ba the condition number of matrix A, j_0=\u221a(blog(4b/\u03f5)) and b=\u03ba^2log(\u03ba/\u03f5). Hence, f(A)|b\u27e9 is the weighted sum of a series of \ud835\udcaf_2 j+1(A)|b\u27e9. Using the linear combination of unitaries (LCU) technique, we can compute the weighted sum of different orders of the Chebyshev polynomial to implement f(A)|b\u27e9, which is \u03f5-close to the A^-1|b\u27e9.\n\n\n\n\u00a7 CLASSICAL SIMULATION OF THE QUANTUM WALK PROGRAM\n\n\n\n\n\nTo validate the implementation, we run our quantum walk program on a quantum circuit simulator. The quantum circuit simulator is not built on any existing quantum programming language or simulation program because the simulation here often requires more than hundreds of qubits, exceeding the capabilities of nearly all well-known existing algorithms. We build a novel quantum circuit simulator, which only stores nonzero entries in a quantum state, and each quantum state represents a series of quantum registers. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \u00a7.\u00a7 Classical simulation of the quantum circuit on the quantum register level\n\n\n\n\n  \nMain idea\nThe classical simulation of the quantum circuit is a computationally hard task. This is generally because the representation of the Hilbert space grows exponentially with the number of qubits. This property usually forbids the simulation of over 100 qubits, which also limits the ability to conduct numerical research on large-scale quantum algorithms, such as the quantum walk used in this paper. To overcome this difficulty, we make two changes to the current classical simulation algorithms. \n\nFirst, we observe that in most of the quantum algorithms, the nonzero entries of the quantum state do not always fill the entire Hilbert space. When there are n working qubits, the quantum state is often not 2^n. In the quantum walk, the maximum number of nonzero entries usually grows polynomially with the dimension of the matrix and the sparsity number. This property allows the compression of the quantum state and greatly reduces the storage space. Also, a sparse state is more efficient to compute, where the time complexity is also polynomial dependent on the number of nonzero entries. \n\nSecond, the basic unit of the computation is raised to the quantum register level instead of the qubit level. In large-scale quantum algorithms, quantum arithmetics are performed on the register level. When the error is small enough to support running such algorithms, a quantum arithmetic operation can be packed and simulated as a whole. This also benefits the programming of quantum algorithms, where a more natural description of the quantum program is allowed, such as instructions like \u201cADD\u201d, \u201cSUB\u201d, or \u201cMUL\u201d.\n\nThe idea of leveraging the sparsity of the quantum state is not initially proposed in our work, but applying the sparse simulation on the register level can dramatically increase the scale of the quantum algorithm that a classical computer can simulate. The programming and simulation of the quantum walk are based on these two changes, so we design a novel simulation program that supports these ideas. Suppose a quantum state that can be written as \n\n    |\u03c8\u27e9 = \u2211_i a_i|v^1_i\u27e9|v^2_i\u27e9|v^3_i\u27e9...,\n\nwhere v^j_i is a computational basis state of register j in the branch i. Define the number of registers as K, and the number of branches as N. This quantum state can be represented by a K\u00d7 N array that stores every v_i^j, and a N-sized vector that stores every a_i. In Fig\u00a0<ref>(a), a schematic of the data structure is shown. We name the K\u00d7 N array as the state array, and the vector that stores the amplitude as the amplitude vector.\n\n\n\nA state array's element can be stored as a plain binary string whose length corresponds to the number of qubits of the register. In practice, all elements are represented by a fixed 64-bit binary string, and the register metadata is recorded to track the size of all registers. Creating a new register is to append a row to the state array as well as the corresponding metadata, and removing a register is to remove the row. \n\n\n\nWhen performing arithmetic computations, the data in registers are often processed with some data type. Generally, this data structure does not limit any certain kind of data type, but we still provide some typical types (integer, unsigned integer, fixed-point number, boolean, etc.) and enable the runtime type check.\n\nThe operations can be divided into two types, as demonstrated in Fig.\u00a0<ref>(b) and (c). The first type is the semi-quantum operation, which processes each branch in parallel and will not change the number of branches, such as quantum arithmetics and QRAM. The second type is the interference operation. This operation will cause quantum interference among several branches, where some branches may be added or deleted. In the quantum walk, Hadamard and conditional rotation is of this type. Detailed descriptions of the simulation algorithm are listed in the Supplementary Material. \n\n\n\n\n\n  \nClassical simulation of the quantum arithmetic\n\nA quantum arithmetic operation is usually a semi-quantum process that satisfies the following properties:\n\n    \n  * All branches are computed independently (in parallel). No branch will be created or deleted.\n    \n  * It is applied on several registers, and the other registers remain unchanged.\n    \n  * It is usually reversible and creates no garbage. If not, then we can extend the input register set with the garbage registers to make it reversible.\n\n\nThe register-level simulation of the quantum arithmetic basically follows these steps. First, iterate over all branches, and for each branch, extract the contents (binary strings) of the input registers. Then use type conversion to process the binary strings into certain data types and directly perform the computation. Finally, change the content in the registers.\n\nThe most vital problem is that one should guarantee the change of contents of the registers is reversible. Here we introduce a simple protocol for out-of-place arithmetics. Suppose a classical function y=f(x_1,x_2,...,x_n) where x_i is the input and y is the output, and the following operation U is guaranteed reversible:\n\n    U_f|x_1\u27e9|x_2\u27e9...|x_n\u27e9|z\u27e9 = |x_1\u27e9|x_2\u27e9...|x_n\u27e9|z\u2295 y\u27e9,\n\nwhere \u2295 is the bitwise XOR. With this protocol, simulating the quantum arithmetic only has to extract all input x_i, compute y, and finally change the content in the output register. \n\nFor the in-place operation, there are two possible methods. One is to manually compute the mapping and guarantee it to be a bijection mapping. Another is to implement the out-of-place version of the function and the inverse function. For example, if the output of y overwrites x_1, such that \n\n    U_f^in-place|x_1\u27e9|x_2\u27e9...|x_n\u27e9 = |y\u27e9|x_2\u27e9...|x_n\u27e9.\n\nThen it is equivalent to implementing U_f and U_f^-1 such that \n\n    U_f^-1|y\u27e9|x_2\u27e9...|x_n\u27e9|z\u27e9 = |y\u27e9|x_2\u27e9...|x_n\u27e9|z\u2295 x_1\u27e9,\n\nwhere x_1=f^-1(y,x_2,...,x_n).\n\n\n\n  \nClassical simulation of the quantum random access memory\n\nThe simulation of the quantum random access memory (QRAM) is similar to the simulation of quantum arithmetic operations. QRAM can implement a unitary U_QRAM such that\n\n    U_QRAM|i\u27e9_A|z\u27e9_D = |i\u27e9_A|z\u2295 d_i\u27e9_D.\n\nHere, QRAM manages a vector of memory entries d\u20d7 and has two variables to control the input: the address length and the word length. The address length n is the size of the address register |\u00b7\u27e9_A, and the word length is the size of data register |\u00b7\u27e9_D. The word length is also the effective size of a memory entry d_i. When the noise is not considered, the simulation of QRAM is to access the classical memory with the content of the address register.\n\n\n\n  \nClassical simulation of the interference operation\nThe simulation of the interference operation includes three major steps:\n\n    \n  * Grouping;\n    \n  * Computing;\n    \n  * Clearing zero elements.\n\n\nSuppose the interference operation is acted on a set of input registers, and we call remained registers idle registers. We should notice that any two branches are coherent if and only if the values of all idle registers are the same. The first step is to sort all branches, then split branches into groups in which all registers have the same value except input registers. \n\nIn each group, we can just calculate a small number of branches. If a group has branches the same number as the dimension of the operation (for example, a Hadamard on k-bit register, and a group with 2^k branches), then this group can be computed in-place. Otherwise, we may append some branches and perform operations on the full size.\n\nAfter the computation step, some branches may have zero amplitude due to the effect of quantum interference, and these branches will be removed from the branch list to reduce memory consumption.\n\n\n\n\n \u00a7.\u00a7 Numerical results\n\n\nWe randomly generate positive-valued symmetric band matrices, which is a typical type of matrix arising from realistic world tasks. Two variables control the generation of the matrix: the number of rows N, and the number of bands. Each matrix element is a fixed point number within [0,1), and the number of digit is called word length.\n\nBefore starting the solver program, we have to preprocess those sparse matrices with the following steps:\n\n\n    \n  * If \u2016 A\u2016_ max > 1, rescale it to be 1;\n    \n    \n  * Convert the sparse matrix to CSC format;\n    \n  * Count the maximum number of nonzeros in a row, recorded as s;\n    \n  * Fill zeros if any row does not have s nonzeros;\n    \n  * Calculate the minimum eigenvalue of A/s as \u03bb_ min, then \u03ba = 1/\u03bb_ min.\n\n \n\n\n\n\nThen we compute the output state |\u03c4_j\u27e9 for all j\u2264 j_0 where\n\n    |\u03c4_j\u27e9 = \ud835\udcaf_2j+1(A/s)|b\u27e9|0\u27e9_flag+|\u03c4^\u22a5\u27e9.\n\nTo avoid repetition, we compute them iteratively, that is |\u03c4_j\u27e9 = T\u0303^\u2020 W^2T\u0303|\u03c4_j-1\u27e9. The output state at step j is defined as\n\n    |T_j\u27e9 = \u2211_k=0^j a_k |\u03c4_k\u27e9.\n\n\nThe successful rate at step j, denoted as p_j, is defined by the probability that the flag register of |T_j\u27e9 is measured to |0\u27e9, namely \n\n    p_j = Tr( (I\u2297 |0\u27e9\u27e8 0|)|T_j\u27e9\u27e8 T_j|).\n\nAfter measurement, the state in the work register is used to evaluate the fidelity of the target state |x\u27e9 = A^-1|b\u27e9/A^-1|b\u27e9, that is \n\n    F_j = | \u27e8 x,0|T_j\u27e9|^2.\n\nThe final result of the CKS solver is the state at j=j_0, which has the successful rate p_succ=p_j_0 and fidelity F = F_j_0. \n\n  \n\nAll simulations are conducted on a single core of Intel Xeon E5-2680. We generate five matrices, whose row sizes ranged from 16 to 16384, whose metadata, related variables, and simulation resources are listed in Table\u00a0<ref>. The test method is the linear solver on the matrix A, B, and C with given input b\u20d7 as a random uniform vector, and their results are shown in Fig.\u00a0<ref>. The fidelity and the successful rate versus the iteration step j are plotted. In all three matrices, the curves match perfectly with the theory, which proves the correctness of our program implementation. The plotted j is less than expected j_0 because the computing converges and results do not change since then. For matrices D and E, the test method is to perform 50 steps of the quantum walk and their results also match perfectly with the theory.\n\nTo summarize, we calculate the quantum walk on 16384\u00d7 16384 matrix with s=64 with 1.1 minutes per step and calculate the linear solving on 1024\u00d7 1024 matrix with s=32 with 1.2 seconds per step. The number of walking steps for the 1024\u00d7 1024 is 212245 (=2j_0+1), and the total time is approximately 70 hours.\n\nThe qubit number shown in the table is counted automatically by the simulator. We exclude qubits that are not used in the computation even though they are allocated. In the quantum walk, the maximum number of qubits is counted when it reaches the deepest recursion of the quantum binary search. We provide a way to estimate the number of qubits in the Supplementary Material. But we also have to mention that here the qubit number is not a good measure of the problem size. Instead, the maximum number of nonzero state components is more important. For reference, the average time per walk step and the maximum memory usage is also provided in the table. The time and memory usage affects greatly by the row size and the sparsity of the matrix.\n\n\n\n\n \u00a7.\u00a7 Complexity of the classical simulation\n\n\n\n\n  \u00a7.\u00a7.\u00a7 Qubit and register usage\n\n\nIn the main text, we list qubit numbers that are used in the quantum walk on different sizes of matrices, which are automatically counted by the quantum circuit simulator. During the computation, the maximum number of working registers and working qubits are maintained. When a register is allocated, the simulator will update the number of working registers if the system uses more registers than before. When a register is deallocated, the number will not shrink, which implies the recycling of the free space. The number of working qubits is the sum of the qubit number of each working register.\n\nHere we also show how to theoretically estimate the qubit number in the quantum walk. It is in the quantum binary search when the system requires the biggest number of registers. Each QBS loop cycle will push four interval variables: mid, midVal, compareLess, and compareEqual, which have n, k, 1, and 1 qubit number correspondingly. Here n and k are the sizes of the address and data which are the QRAM's input, where n=log N + 1 and k is a set value. The number of the loop cycles is log s+1 in order to locate every possible input. Then the qubit number used as the ancilla in the QBS is (log s+1)(n+k+2). The remaining part is the six registers used in the quantum walk, which have 4n+2 qubits. So that in total, the number of qubits is\n\n    (n+k+2)log s+5n+k+4.\n\n\n\n\n  \u00a7.\u00a7.\u00a7 The space complexity of simulating the quantum walk\n\n\nThe space complexity of this method can be written directly as O(K_maxM_max) where K_max is the maximum number of working registers, and M_max is the maximum number of branches. In the quantum walk scenario, K_max is logarithmic dependent on the problem size. In the quantum binary search, a constant number of ancilla registers will be added for each loop cycle, and the number of the loop cycle is O(log s). Except for this, the number of working registers is always a constant number. Therefore, K_max=O(log s).\n\nNext we estimate M_max. The nonzero entries are created during the preparation of |\u03c8\u0303_j\u27e9. In the first application of T\u0303 on the initial state |b\u27e9 = \u2211_j \u03b1_j|j\u27e9, we have\n\n    T\u0303|b\u27e9 = \u2211_j,k\u03b1_j\u221a(A_jk^*) |j,k\u27e9 + \u221a(1-|A_jk|)|j,k+N\u27e9,\n\nwhere M=O(Ns) because it includes all nonzero elements in the matrix, which is a lower bound for the M_max. After the first walk step, we will produce\n\n    T\u0303^\u2020 S T\u0303|b\u27e9.\n\nIn each application of T\u0303, two state preparation processes are applied, where each will maximumly create s-fold copies of the quantum state. Therefore, we will obtain at most O(Ns^3) nonzeros entries.\n\nIn the theory, the quantum walk operator is a rotation on the subspace span {T|\u03bb\u27e9, |\u22a5_\u03bb\u27e9}, where |\u03bb\u27e9 is the eigenstate of H with eigenvalue \u03bb, and |\u22a5_\u03bb\u27e9 is orthogonal to |\u03bb\u27e9 in the subspace. For any input |b\u27e9 = \u2211_\u03bb b_\u03bb|\u03bb\u27e9, the first walk step has already created a superposition over two states in the subspace, that is T\u0303^\u2020 S T\u0303|b\u27e9 = \u2211_\u03bb  b_\u03bb\n(\u03bb|\u03bb\u27e9 + \u221a(1-\u03bb^2)|\u22a5_\u03bb\u27e9). In the following steps, it only changes the coefficient without evidently changing the number of the nonzero entries on the computational basis. In conclusion, the maximum number of nonzero entries during the whole quantum walk process is upper-bounded by O(Ns^3).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere we plot the max size obtained from numerical experiments on various matrix configurations in Fig.\u00a0<ref>. In subfigure (a), the max size is approximately linear-dependent on the row number N in the case of s=4 or s=8. In subfigure (b), the dependence on sparsity constant s is nonlinear. To further investigate the relationship, we plot them with a log-log scale in subfigure (c) and compute the slope. From this result, we estimate that M_max is O(Ns) when s is significantly less than N, and between O(Ns^2) and O(Ns^3) when s approaches N.\n\n\n\n\n\n\n\n\n  \u00a7.\u00a7.\u00a7 The time complexity for simulating the quantum walk\n\n\nAfter determining the maximum number of nonzero entries in the quantum state, now we can estimate the time complexity of the simulation.\n\nIn each quantum walking step, there are two interference operations: one is the state preparation on the register k to create superposition, and another is to uncompute this preparation to achieve a reflection. Except for these two interference operations, the remaining are all semi-quantum operations.\n\nFor the semi-quantum operations, the time complexity can be computed by the number of nonzero entries M and the number of the operations, which is O(log s), mainly contributed by the quantum binary search. Considering the maximum number of nonzero entries estimated in the previous text, the time complexity for the semi-quantum operations is O(Ns^3log s).\n\nFor the interference operation, the time complexity is mainly contributed by the sorting of the quantum state that creates groups. Sorting requires O(Mlog M) time complexity, and the other part is proportional to M. Therefore, the time complexity should be O(Ns^3logNs).\n\nAdding up these two parts, we obtain an estimated time complexity for simulating each walking step, that is O(Nspolylog(Ns)). Finally, we consider the number of the walk step required for this simulation j_0, which is approximately proportional to \u03ba. In total, the time complexity for conducting the simulation for the entire quantum linear solver is \n\n    O(N\u03bapoly(s)log N ).\n\n\nA common knowledge is that simulating quantum computing will introduce many extra overheads, and the simulation ability is much weaker than using a classical algorithm and solving it directly. Surprisingly, the simulation of the quantum walk approaches the complexity of the classical computation, such as the conjugate-gradient method with O(N\u03ba s) time complexity. For Other quantum circuit simulation methods, the number of qubits and depth of the circuit can often be the restriction and they can hardly achieve a linear dependence on the size of the matrix. In our view, the improvement is mainly caused by only tracking the nonzero entries in the quantum state, and the size of the quantum state is often proportional to the intrinsic complexity of the problem itself.\n\n\n \n\n\n\n\n\n\n\u00a7 SUMMARY AND OUTLOOK\n\n\nWe believe that programming the quantum algorithm, as well as simulating it with realistic data, is one of the most convincing and concrete ways to study quantum algorithms. However, there is always a gap between the quantum algorithm and an executable quantum program. How to decompose each step of the quantum algorithm into a set of basic operations is the key to filling the gap.\n\nIn this article, we developed a series of techniques to program the quantum walk on a sparse matrix stored in the QRAM, including a unitary quantum binary search without side-effect and the implementation of the quantum walk on the expanded space. We execute this program on a quantum circuit simulator, test it on several matrices, and compare it with the theory.\n\n\n\nAll the techniques developed in this paper can also be used in the programming of other quantum algorithms, e.g. implementing a quantum while loop and dynamical allocation and deallocation of ancilla registers. Because the quantum walk operator also naturally generates the block encoding of a sparse matrix, we can expect the implementation and simulation of the quantum linear algebra<cit.> and grand unification of quantum algorithms<cit.>.\n\nWe would like to conduct two future works related to this paper. The first is to add errors to the simulation. The error should be the most critical factor that affects quantum computation. In fault-tolerant quantum computing, the required error rate determines the amount of error correction resources. A noisy simulation could be a key to discovering the minimum resource that a quantum computer requires to achieve quantum speedup in some real-world problems. The second is to estimate the execution time and T-count. It is possible to estimate these via a validated and detailed program implementation, and an automatic tool for the resource and time estimation of a large-scale quantum algorithm might be created in the future.\n\n\n\n\n\n\n\u00a7 ACKNOWLEDGEMENT\n\nThis work was supported by the National Natural Science Foundation of China (Grant No. 12034018), and Innovation Program for Quantum Science and Technology No. 2021ZD0302300.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u00a7 QUANTUM ARITHMETICS USED IN THIS PAPER\n\nQuantum arithmetics are often regarded as the circuit implementations of arithmetic logic units (ALU) in the quantum computer, including addition, subtraction, multiplication, square root, etc. Quantum arithmetics are semi-quantum circuits, which reversibly implement classical logic computations, and are very essential in many quantum algorithms like Shor's factorization. Many previous works have introduced the implementation and optimization of some quantum arithmetics.\n\n\nDifferent from many other works which explicitly implement all operations in the quantum circuit form, this paper terminates at some \u201cbasic operations\u201d including those quantum arithmetics. To ensure these operations can be fully decomposed into quantum gate level, we list all of them in Table\u00a0<ref>.\n\n\n\n\n\n\n\n\n\n\u00a7 THE INTUITIVE IMPLEMENTATION OF THE O_S\n\nIn this section, we introduce how to implement the original O_s completely in place without causing any side effects. First, we restate the definitions: the dimension of the matrix is N; sparsity is s; in row j, the index of the l-th nonzero column is k. When the matrix is stored in CSC format, it is efficient to compute k(j,l) when 0\u2264 l<s. Also, the quantum binary search can compute l(j,k) in O(log s) time when k is a correct column index. Now the task is to create a mapping from any 0\u2264 k<N to 0\u2264 l<N.\n\n\nThe in-place mapping from k to l is equivalent to defining two out-of-place operations, that is\n\n    |j,k\u27e9\u21a6 |j,k,l(j,k)\u27e9\n       |j,l\u27e9\u21a6 |j,l,k(j,l)\u27e9.\n\nThey can be achieved by first copying the register and then performing the in-place operation on the copied register.\n\n\nIn Fig.\u00a0<ref>, we again display an intuitive example version of O_s. For the given input l, there exist two domains: one is that l<s, called \u201csparsity mapping\u201d, and the other is l\u2265 s, called \u201cbijection filler\u201d. The first l in the bijection filler domain maps to the index of the first zero columns and so forth. This mapping can be represented by the following function\n\n\n    k(j,l) = {[ k\u0303(j,l)  0\u2264 l<s;   l-\u03b4_l  s\u2264 l<N ]..\n\nHere \u03b4_l is the difference between k and l. Even though it is straightforward to compute this difference from k, it is necessary to compute this difference with only the given input l for reversibility. Then the algorithm is as follows.\n\n\n\nThis algorithm sequentially finds the corresponding k belongs to which section. Therefore, the time complexity for this algorithm is O(s). While this algorithm also uses a for-loop that has to be run in quantum parallel, using the method that described in the main text, we can convert it to the quantum version and obtain the space complexity O(s).\n\n\n\n\u00a7 PSEUDOCODE OF THE IMPLEMENTATION\n\n\nHere we list the pseudocode for implementing each module of the quantum walk, including O_A', O_s', T\u0303, and the walk operator W.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u00a7 CLASSICAL BINARY SEARCH\n\n\nThe binary search is a classic, efficient algorithm that looks up a target in a sorted list. There are many methods to implement a binary search, such as using a while-loop or recursion. Here we use a for-loop version that has a fixed step number, which can more easily be converted to the quantum version.\n\nNote that this binary search version only correctly outputs the position when the search target is actually in the list, which has already met the demand for implementing the quantum walk.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nunsrt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}