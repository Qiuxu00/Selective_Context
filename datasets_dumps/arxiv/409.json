{"entry_id": "http://arxiv.org/abs/2303.06759v2", "published": "20230312213922", "title": "New Approximation Algorithms for Touring Regions", "authors": ["Benjamin Qi", "Richard Qi", "Xinyang Chen"], "primary_category": "cs.CG", "categories": ["cs.CG"], "text": "\n\n[\n    Wenzheng Kuang\n    March 30, 2023\n==================\n\n\n\n\nWe analyze the touring regions problem: find a (1+\u03f5)-approximate Euclidean shortest path in d-dimensional space that starts at a given starting point, ends at a given ending point, and visits given regions R_1, R_2, R_3, \u2026, R_n in that order. \n\nOur main result is an \ud835\udcaa(n/\u221a(\u03f5)log1/\u03f5 + 1/\u03f5)-time algorithm for touring disjoint disks. We also give an \ud835\udcaa (min(n/\u03f5, n^2/\u221a(\u03f5)) )-time algorithm for touring disjoint two-dimensional convex fat bodies. Both of these results naturally generalize to larger dimensions; we obtain \ud835\udcaa(n/\u03f5^d-1log^21/\u03f5+1/\u03f5^2d-2) and \ud835\udcaa(n/\u03f5^2d-2)-time algorithms for touring disjoint d-dimensional balls and convex fat bodies, respectively.\n\n\n\n\n\u00a7 INTRODUCTION\n\n\nWe analyze the touring regions problem: find a (1+)-approximate Euclidean shortest path in d-dimensional space that starts at a given starting point, ends at a given ending point, and visits given regions R_1, R_2, R_3, \u2026, R_n in that order. We present algorithms for the cases where the regions R_i are constrained to be unions of general convex bodies, convex fat bodies, or balls. To the best of our knowledge, we are the first to consider the cases where regions are disjoint convex fat bodies or balls in arbitrary dimensions. Consequently, our algorithms use techniques not previously considered in the touring regions literature (<ref>). Our algorithms work under the assumption that a closest point oracle is provided; closest point projection has been extensively used and studied in convex optimization and mathematics <cit.>.\n\nMost prior work focuses on d=2 or significantly restricts the convex bodies. The special case where d=2 and all regions are constrained to be polygons is known as the touring polygons problem. Dror et al. <cit.> solved the case where every region is a convex polygon exactly, presenting an |V|n log|V|/n-time algorithm when the regions are disjoint as well as an |V|n^2 log|V|-time algorithm when the regions are possibly non-disjoint and the subpath between every two consecutive polygons in the tour is constrained to lie within a simply connected region called a fence. Here, |V| is the total number of vertices over all polygons. Tan and Jiang <cit.> improved these bounds to |V|n and |V|n^2-time, respectively, without considering subpath constraints. \n\nFor touring nonconvex polygons, Ahadi et al. <cit.> proved that finding an optimal path is NP-hard even when polygons are disjoint and constrained to be two line segments each. Dror et al. <cit.> showed that approximately touring nonconvex polygons with constraining fences is a special case of 3D shortest path with obstacle polyhedra, which can be solved in e^4/\u03f5^2 time by applying results of Asano et al. <cit.>, where e is the total number of edges over all polyhedra. Mozafari and Zarei <cit.> improved the bound for the case of nonconvex polygons with constraining fences to |V|^2n^2/^2 time. Ahadi et al. <cit.> also solve the touring objects problem exactly in polynomial time, in which the R_i are disjoint, nonconvex polygons and the objective is to visit the border of every region without entering the interior of any region.\n\nFor touring disjoint disks, a heuristic algorithm with experimental results was demonstrated by Chou <cit.>. Touring disjoint unit disks was given in a programming contest and was a source of inspiration for this paper; an n/\u03f5^2-time algorithm was given <cit.>. The main result that we show for disks is superior to both of these algorithms.\n\nPolishchuk and Mitchell <cit.> showed the case where regions are constrained to be intersections of balls or halfspaces in d dimensions to be a special instance of a second-order cone program (SOCP), which runs in d^3c^1.5n^2log1/\u03f5 time using SOCP time bounds as a black box. Here, c is the number of halfspace or ball constraints.\n\nThe touring regions problem can be seen as the offline version of chasing convex bodies, in which convex bodies are given sequentially, and the algorithm must choose which point to go to on a convex body before the next convex body is revealed. Bubeck et al. <cit.> and Sellke <cit.> showed competitive ratios of 2^d and \u221a(d logn), respectively. \n\n\n\n \u00a7.\u00a7 Formal problem description\n\n\n\nGiven n sets of points (regions) R_1, R_2, \u2026, R_n each a subset of ^d, a starting point p_0, and an ending point p_n+1,[For convenience, some of our results define the degenerate regions R_0\u225c{p_0} and R_n+1\u225c{p_n+1}. ] define the function D (^d)^n \u2192 as D(p_1, p_2, \u2026, p_n) \u225c\u2211_i=0^np_i-p_i+1_2.\n\n\nLet \ud835\udc9c\u225c{(p_1, p_2, \u2026, p_n) |\u2200 i, p_i \u2208 R_i}\u2286 (^d)^n. Find a tuple of points (tour) (p_1',p_2',\u2026,p_n')\u2208\ud835\udc9c such that D(p_1', p_2', \u2026, p_n') \u2264 (1+)min_x \u2208\ud835\udc9c D(x).\n\n\n\n\n\nWe consider three main types of regions: unions of convex bodies, convex fat bodies with constant bounded fatness, and balls.\n\n\n\nWe call a region R \u2282^d a union of k convex bodies if R = C_1 \u222a C_2 \u222a\u2026\u222a C_k and each C_i is convex and compact. The C_i are allowed to intersect.\n\n\nWe primarily restrict to the case where k \u22641. \n\n\n\nWe say that a convex region R \u2282^d is fat if there exist balls h, H with radii 0<r_h \u2264 r_H, respectively, that satisfy h \u2286 R \u2286 H \u2282^d and r_H/r_h =1. \n\n\nFat objects have been previously considered in a variety of computational geometry settings <cit.>.\n\nOne element of the problem that has not yet been determined is how we represent the sets of points R_1, R_2, \u2026, R_n; this depends on what we restrict the regions to be:\n\n    \n  * Unions of convex bodies: We are given each region in the form R_i = C_i, 1\u222a C_i, 2\u222a\u2026\u222a C_i, k_i. Each of the convex bodies C_i, j may be accessed via a closest point oracle. This oracle allows us to call the function _i,j(p) on some point p, which returns the point p' \u2208 C_i, j such that p-p' is minimized in 1 time (note that p' is unique due to convexity).\n    \n    \n  * Convex fat bodies: We have access to each of the convex bodies R_i via a closest point oracle. Additionally, for each region, we are given the radius r_h of the inscribed ball (as described in <ref>), and a constant upper bound on the quantity r_H/r_h over all regions. \n    \n    \n  * Balls: For each ball in the input we are given its center  c \u2208^d and its radius r \u2208_>0.\n\n\nWe consider the 2-dimensional and general d-dimensional cases separately. In the d-dimensional case, we assume d is a constant (for example, we say 2^d = 1). We also consider the possibly non-disjoint versus disjoint cases separately, where the latter is defined by the restriction R_i \u2229 R_j = \u2205 for all 0\u2264 i<j\u2264 n+1. \n\n\n\n  \n*Motivation for our model\nWhen considering general convex bodies,  it is natural to augment the model of computation with oracle access to the bodies, including membership, separation, and optimization oracles <cit.>. In fact, when solving the touring regions problem for general convex bodies, a closest point oracle is necessary even for the case of a single region, where the starting point is the same as the ending point and the optimal solution must visit the closest point in the region to the starting point. Closest point oracles can be constructed trivially when the bodies are constant sized polytopes or balls. Closest point oracles have been used in the field of convex optimization <cit.>.\n\nOur representations for unions of convex bodies, convex fat bodies, and balls, have the nice structure that each \u201ccontains\u201d the next: we can trivially construct a closest point oracle for balls. Additionally, a ball is a specific type of convex fat body, which in turn is a specific type of convex body. We justify considering convex fat bodies as they are in some sense \u201cbetween\u201d balls and general convex bodies: they obey some of the packing constraints of balls. Considering unions of convex bodies allows us to represent a variety of non-convex and disconnected regions.\n\n\n\n \u00a7.\u00a7 Summary of results\n\n\nOur results and relevant previous results are summarized in <ref> and <ref>. We obtain a bound of n^2d-1(loglog n+1/^2d-2) time for the most general case of touring unions of convex bodies in d dimensions, where each region is a union of 1 convex bodies. This significantly improves to n/^2d-2 time if we restrict the regions to be disjoint convex fat bodies. Notice that this latter bound is linear in n; in fact, we show that any FPTAS for touring convex fat bodies can be transformed into one that is linear in n (<ref>). If the regions are further restricted to be balls, we can apply our new technique of placing points nonuniformly, and the time complexity improves to n/^d-1log^21/+1/^2d-2, which roughly halves the exponent of 1/\u03f5 compared to the convex fat bodies algorithm while retaining an additive 1/\u03f5^2d-2 term. \n\nOur 2D-specific optimizations allow us to obtain superior time bounds compared to if we substituted d=2 into our general dimension algorithms. In most cases, we save a factor of 1/\u03f5. Notably, for convex fat bodies, we obtain an algorithm with linear time dependence on both n and 1/\u03f5. For our main result of touring disjoint disks, we combine our optimizations for convex fat bodies and balls with 2D-specific optimizations.\n\ntheoremnonIsectDisksTwoD\n\nThere is an n/\u221a()log1/+ 1/-time algorithm for touring disjoint disks.\n\n\n\nWith a new polygonal approximation technique, we use the result of <cit.> for touring polygons as a black box to obtain algorithms with a square root dependence on 1/\u03f5, most notably an n^3.5/\u221a(\u03f5)-time algorithm for touring 2D convex bodies and an n^2/\u221a(\u03f5)-time algorithm for touring 2D disjoint convex fat bodies.\n\nApproximation algorithms for touring polygons in 2D have been well-studied. As mentioned in the introduction, Tan and Jiang <cit.> improved on Dror et al.'s <cit.> exact solution for convex polygons, while Mozafari and Zarei <cit.> approximated unions of nonconvex polygons, which we include in <ref> for reference. One of our 2D-specific techniques can be used to improve the result of  <cit.> from |V|^2n^2/^2 to |V|nlog |V|loglog n+|V|n/log|V|/+|V|^2\u03b1(|V|) time, where \u03b1 is the inverse Ackermann function, obtaining a strictly better running time for the problem of touring possibly non-disjoint unions of polygons in 2 dimensions.\n\nThe c^1.5n^2log1/\u03f5-time result for touring d dimensional convex bodies given by <cit.>, where each body is an intersection of balls and half spaces (with a total of c constraints) can be applied specifically to balls to yield an n^3.5log1/\u03f5-time algorithm. Our algorithms for touring disjoint disks and balls all take time linear in n and are thus superior when \u03f5 is not too small.\n\n\n\n\n\n\n\n\n\n \u00a7.\u00a7 Organization of the paper\n\n\nWe start in <ref> by considering unions of general convex bodies, using the closest point projection, pseudo-approximation, and 2D-specific optimizations. We then use the ideas of packing and grouping to obtain algorithms for convex fat bodies in <ref>. Finally, we optimize specifically for balls in <ref> by placing points non-uniformly.\n\n\n\n \u00a7.\u00a7 Summary of techniques\n\n\nHere, we introduce the techniques mentioned in the previous subsection.\n\n\n\n  \n*Placing points uniformly (<ref>)\n\nA general idea that we use in our approximation algorithms is to approximate a convex body well using a set of points on its boundary. For previous results involving polygons or polyhedra <cit.>, this step of the process was trivial, as points were equally spaced along edges. In order to generalize to convex bodies in arbitrary dimensions, we equally space points on boundaries using the closest point projection oracle with a bounding hypercube (<ref>). \n\nAfter discretizing each body into a set of points, we can solve the problem in polynomial time using dynamic programming (DP): for each point, we find and store the optimal path ending at it by considering transitions from all points on the previous region.\n\n\n\n\n\n\n\n\n\n\n\n  \n*Pseudo-Approximation (<ref>)\n\nLet OPT be the optimal path length for touring regions. Consider some guess of the optimal path length for touring convex bodies L_APPROX\u2265 OPT, and then consider constructing a hypercube of side length 2L_APPROX centered at the starting point. We then equally space points on the boundary of the portions of the convex bodies which are inside the hypercube, and solve the problem assuming that the optimal path must travel through these points, which adds some additive error proportional to L_APPROX to the optimal path length. This is called a pseudo-approximation because the error bound only holds if L_APPROX\u2265 OPT, and if L_APPROX is much bigger than OPT, the additive error is very large.\n\nThe idea for using this pseudo-approximation to compute an actual approximation is to start with some naive large approximation of the optimal path length, and then continuously guess smaller values of the optimal path length and run the pseudo-approximation as a subroutine to generate better approximations, eventually finding a constant approximation in loglogn iterations. Once a constant approximation is found, the pseudo-approximation algorithm becomes an actual approximation algorithm, and is then used to find a (1+\u03f5)-approximation. This method was used previously by <cit.> and <cit.>. An exposition about pseudo-approximation can be found in <cit.>.\n\n\n\n  \n*2D-specific optimizations (<ref>)\n\nPrevious approximation algorithms for related problems discretize the boundary of each convex region using 1/\u03f5 points. We present a new approach to approximate each boundary using a convex polygon with 1/\u221a(\u03f5) vertices (<ref>). This allows us to use previous exact algorithms for touring convex polygons as black boxes. \n\nA separate approach is to use additively weighted Voronoi diagrams (<ref>) to optimize dynamic programming (DP) transitions from quadratic to near-linear time. When we additionally assume the input shapes are disjoint, we use properties of Monge matrices to optimize the transitions to expected linear time (<ref>).\n\n\n\n  \n*Packing and grouping (<ref>)\nWhile our general algorithm for unions of convex regions has runtime (n^2d-1/^2d-2 ), we are able to improve this to n/^2d-2 time for convex fat bodies. The key ideas behind this improvement are packing and grouping.\n\nWe use a simple packing argument to show that the path length for visiting n disjoint convex fat bodies with radius r must have length at least \u03a9(r \u00b7 n) for sufficiently large n (<ref>). This was used by <cit.> for the case of unit disks. However, it is not immediately clear how to use this observation to obtain improved time bounds when convex fat regions are not all restricted to be the same size.\n\nThe idea of grouping is to split the sequence of regions into smaller contiguous subsequences of regions (groups). In each group, we find the minimum-sized region, called a representative region, which allows us to break up the global path into smaller subpaths between consecutive representatives. The earlier packing argument now becomes relevant here, as we can show a lower bound on the total length of the optimal path in terms of the sizes of the representatives.\n\n\n\n  \n*Placing points non-uniformly (<ref>)\n\nPrevious approximation methods rely on discretizing the surfaces of bodies into evenly spaced points. For balls, we use the intuition that the portion of the optimal path from one ball to the next is \u201clong\u201d if the optimal path does not visit the parts of the surfaces that are closest together. This allows us to place points at a lower density on most of the surface area of each ball, leading to improved time bounds. We use this technique in conjunction with packing and grouping. For disks, we additionally apply the previously mentioned 2D-specific optimizations.\n\n\n\n\n\u00a7 CONVEX BODIES\n\n\n\nFirst, we consider the most general case of convex bodies (or unions of convex bodies), as variations of these techniques also apply to later results. We split the discussion into the general d-dimensional case and the 2-dimensional case. Omitted proofs for this section may be found in <ref>.\n\n\n\n \u00a7.\u00a7 General dimensions\n\n\nFor the theorems in this section, we let |R_i| denote the number of convex bodies that together union to region R_i. Recall that the convex bodies which make up region R_i may overlap.\n\nThe first main ingredient is the closest point projection, which allows us to equally space points on each convex body. The proof is deferred to the appendix.\n\n\nFor a convex region C, define closest_C(p)\u225cargmin_c\u2208 Cc-p. For any two points p_1 and p_2, closest_C(p_1)-closest_C(p_2)\u2264p_1-p_2.\n\n\nFor any closed set X, let \u2202 X denote the boundary of X.\n\n\n\nGiven a convex body C for which we have a closest point oracle and a hypercube \u210b with side length r, we can construct a set S\u2282 C of 1/^d-1 points such that for all p \u2208 (\u2202 C) \u2229\u210b, there exists p' \u2208 S such that p-p'\u2264 r.\n\n\n\nFirst, we prove the statement for C = \u210b. For this case, it suffices to equally space points on each face of an axis-aligned hypercube defined by [0, r]^d. For example, for the face defined by x_d = 0, we place points in a lattice at all coordinates (x_1, x_2, \u2026, x_d-1, x_d) that satisfy x_d = 0 and x_i = k_i \u00b7 r for all integers k_i\u2208[0, 1/]. For C \u2260\u210b, equally space points on \u210b as we stated to create a set S_\u210b. Then define S\u225c{_C(s) | s \u2208 S_\u210b}. The proof that S satisfies the conditions of the lemma is deferred to the appendix.\n\n\nNow, we introduce the concept of the pseudo-approximation, which takes in an accuracy parameter \u03b3 and an estimate of the optimal path length L_APPROX\u2265 OPT and reduces each region R_i to a finite set of points S_i \u2282 R_i such that the optimal tour for touring S_i is also a tour for R_i, and has length at most OPT + \u03b3 L_APPROX. \n\nNote that when the regions are possibly non-disjoint, it is not true that the optimal path must visit each \u2202 R_i, so more care must be taken. In particular, we use the fact that the only time an optimal path does not visit the boundary of R_i is when it visited the boundary of some region \u2202 R_l for some l < i and then remained on the interior of regions R_l+1, R_l+2, \u2026, R_i, in which case the optimal path has moved 0 distance when visiting these regions. This requires more effort to bound the error from the optimal length and makes the dynamic programming transitions more complex, but both algorithms achieve the same time bound when all |R_i| \u2264\ud835\udcaa(1) (that is, when all regions are unions of a constant number of convex bodies). \n\n\nGiven an estimate of the optimal path length L_APPROX and 0 < \u03b3\u2264 1, if OPT \u2264 L_APPROX, we can construct a valid solution with length at most OPT + \u03b3 L_APPROX. If all R_i are disjoint, this construction takes n/\u03b3^2d-2\u2211_i=1^n-1 |R_i||R_i+1| time. When the R_i are possibly non-disjoint, the runtime increases to n/\u03b3^2d-2max_j|R_j|\u2211_i=1^n |R_i|.\n\n\n\n\nWe construct finite sets of points S_i \u2282 R_i such that there exists a path of the desired length that tours regions S_i. \n\nAssume OPT\u2264 L_APPROX and consider a hypercube \u210b centered at p_0 with side length 4 \u00b7 L_APPROX. We define the construction as follows: For each of the convex bodies \nC_i, 1, C_i, 2, C_i, 3, \u2026, C_i, |R_i| that make up R_i, apply the construction given in <ref> with \u03f5\u225c\u03b3/16n, r \u225c 4L_APPROX, and set S_i to be the union of all |R_i| constructed sets of points. This uses 1/\u03f5^d-1 = n/\u03b3^d-1 points per convex body. \n\nGiven the sets S_i, the path of length OPT + \u03b3 L_APPROX can be computed directly using dynamic programming. When the R_i are disjoint, transitions occur from points on S_i to S_i+1. Transitions are slightly different for the possibly non-disjoint case since points in the set S_i can transition to points on S_j for j > i+1. The details of the dynamic programming and the proof that the length of the returned path is bounded above by OPT+\u03b3 L_APPROX are deferred to the appendix.\n\n\n\n\n\n\n\n\n\n\n\n\nTo convert our pseudo-approximation algorithm into an actual approximation, we start with an n-approximation of the optimal path length; the construction is deferred to the appendix.\n\n\n\nThere is a trivial (2n+1)-approximation for touring general regions that can be computed in n time given a closest point oracle.\n\n\nNow, our goal is to construct a constant approximation starting from our trivial approximation. The idea, first presented in <cit.> for the problem of 3D shortest path with obstacles, is to run the pseudo-approximation loglog n times with \u03b3=1. The resulting runtime is much faster than if one were to naively apply <ref> with \u03b3 = \u03f5/n. The proof is deferred to the appendix.\n\n\nThere is an \n\nn^2d-2loglogn\u00b7 (\u2211_i=1^n-1 |R_i| |R_i+1|)-time algorithm that obtains a 4-approximation for touring disjoint unions of convex bodies in d dimensions. If the unions can intersect, the runtime increases to n^2d-2loglogn\u00b7 (\u2211_i=1^n |R_i| max_j |R_j|).\n\n\nFinally, we combine all of the lemmas of the section to give the main results.\n\n\nThere is an n^2d-2(loglogn+1/^2d-2) \u00b7 (\u2211_i=1^n-1 |R_i| |R_i+1|)-time algorithm for touring disjoint unions of convex bodies in d dimensions. When the bodies are allowed to intersect, the runtime becomes (n^2d-2(loglogn+1/^2d-2) \u00b7 (\u2211_i=1^n |R_i| max_j |R_j|)).\n\n\n\n\nFor the disjoint case, apply <ref> to get a constant approximation in (n^2d-2loglogn\u00b7 (\u2211_i=1^n-1 |R_i| |R_i+1|)) time, then use <ref> with L_APPROX as our constant approximation and \u03b3 = \u03f5/4 to obtain a (1+)-approximation in n^2d-2(1/^2d-2) \u00b7 (\u2211_i=1^n-1 |R_i| |R_i+1|) additional time. The possibly non-disjoint case is similar.\n\n\n\n\n \u00a7.\u00a7 Two dimensions\n\n\nWhen the unions of convex bodies are constrained to lie in 2D, there are two main avenues for further improvements: first, by speeding up the dynamic programming (DP) transitions when all regions have been discretized into point sets, and second, by approximating convex bodies by convex polygons instead of sets of points. In this section, \u201cunion of convex bodies\u201d refers to a union of 1 convex bodies per region.\n\n\n\n  \u00a7.\u00a7.\u00a7 Dynamic programming speedup\n\n\nThe first speedup comes as a result of observing that the DP in <ref> is similar to closest point queries, which can be computed efficiently.\n\n\n\nGiven two lists of points B=[b_1,\u2026,b_m] and A=[a_1,a_2,\u2026,a_n] and a real weight [w_1,\u2026,w_n] for each point in A, we can compute min_1\u2264 j\u2264 nw_j+a_j-b_i for each i\u2208 [1,m] in (m+n)log n time.\n\n\n\n\nThis problem is equivalent to constructing and querying a Voronoi diagram for additively weighted point sets. Constructing the diagram can be done in nlog n time by a variant of Fortune's algorithm <cit.>. For each b_i we can search the Voronoi diagram for the a_j corresponding to the minimum in log n time.\n\n\n\nThe Touring Regions Problem in 2D, where all R_i are sets of finitely many points S_i, can be solved exactly in \u2211_i=1^n|S_i|log|S_i| time. \n\n\n\n\n\nRecall the dynamic programming method from <ref>, which computes the DP value for each point in S_i+1 in |S_i| time, meaning that each pair of adjacent regions contributes |S_i||S_i+1| to the runtime. Substituting <ref> in place of this step, the runtime improves to\n\u2211_i=1^n-1(|S_i|+|S_i+1|)log |S_i|\u2264\u2211_i=1^n|S_i|log |S_i|. \n\n\n\nFor disjoint convex regions, we use a stronger guarantee than <ref>:\n\n\nGiven are the vertices of two disjoint convex polygons B=[b_1,\u2026,b_m] and A=[a_1,a_2,\u2026,a_n] in counterclockwise order and real weights [w_1,\u2026,w_n], one for each vertex of A. Define d(i,j)\u225c w_j+a_j-b_i. Then  min_1\u2264 j\u2264 nd(i,j) may be computed for all i\u2208 [1,m] in m+n expected time.\n\n\n\nWe first discuss the case where all w_i=0. Aggarwal and Klawe <cit.> showed how to reduce the computation of min_1\u2264 j\u2264 n, a_j visible from b_id(i,j) and \nmin_1\u2264 j\u2264 n, a_j not visible from b_id(i,j) for all i\u2208 [1,m] to computing the row minima of several Monge partial matrices with dimensions m_1\u00d7 n_1, m_2\u00d7 n_2,\u2026, m_k\u00d7 n_k such that \u2211 (m_i+n_i)\u2264(m+n) in (m+n) time. Here, a_j is said to be visible from b_i if the segment a_jb_i intersects neither the interiors of polygons A nor B. The definition of Monge partial matrix can be found in <cit.>. \n\nChan <cit.> recently introduced an m+n expected time randomized algorithm for computing the row minima of an m\u00d7 n Monge partial matrix.[The Monge partial matrix does not have to be given explicitly; it suffices to provide an oracle that returns the value of any entry of the matrix in \ud835\udcaa(1) time.] Thus, the case of w_i=0 can be solved in m+n expected time. \n\nThe key claim that Aggarwal and Klawe <cit.> use to show that all the matrices they construct are Monge partial is as follows:\n\n[Lemma 2.1 of <cit.>, adapted]\nAssume all w_j=0. Suppose j\u2260 j' and i\u2260 i'. If a_ja_j'b_i'b_i form a convex quadrilateral in that order then d(i,j)+d(i',j')\u2264 d(i,j')+d(i',j).\n\n\nThe claim above holds by the triangle inequality, and it is easy to check that it still holds without the assumption w_j=0. Thus the algorithm from <cit.> generalizes to the case of nonzero w_j with minor modifications.\n\n\n\nThe Touring Regions Problem in 2D, where all R_i are sets of finitely many points S_i that each form a convex polygon in counterclockwise order and the convex hulls of all S_i are disjoint, can be solved exactly in \u2211_i=1^n|S_i| expected time.\n\n\nUsing these techniques, we obtain the following speedups. <ref> follows due to similar reasoning as <ref>, as a polygon with |V| vertices can be triangulated in |V| time due to Chazelle <cit.>.\n\n\nThere is an n^2loglog n+1/-time algorithm for touring disjoint unions of convex bodies in 2D where each union consists of 1 convex bodies. When the bodies are possibly non-disjoint, the bound is n^3loglog n+1/+log 1//n time.\n\n\n\nFor the first bound, use <ref> with <ref> to speed up DP transitions. For the second bound, use <ref> but with an extension of <ref> to speed up DP transitions. \n\n\n\nThere is an |V|nlog |V|loglog n+|V|n/log|V|/-time algorithm for touring disjoint unions of polygons. When the polygons are allowed to intersect each other, the time complexity increases by |V|^2\u03b1(|V|).\n\n\n\n\n  \u00a7.\u00a7.\u00a7 Polygonal approximation algorithms\n\n\nUp until now, we have approximated the perimeter of a convex region using points. We can alternatively approximate the perimeter using a convex polygon with fewer vertices, which can be computed using our closest point projection oracle. The proof is deferred to the appendix.\n\n\nGiven a closest point oracle for a convex region C and a unit square U, we may select ^-1/2 points in C such that every point within C\u2229 U is within distance  of the convex hull of the selected points.\n\n\nThe polygonal approximation allows us to immediately obtain the following result. The proof is deferred to the appendix.\n\n\n\nThere is a n^2.5/\u221a()-time algorithm for touring disjoint convex bodies in 2D. When the convex bodies are possibly non-disjoint, the bound is n^3.5/\u221a() time.\n\n\n\nLet's start with the disjoint case.\nWe first use <ref> with 1+\u03f5 = 2 to obtain a path of length L_APPROX that satisfies L_APPROX\u2264 2\u00b7 OPT in o(n^2.5) time.\n\nConsider constructing a square \u210b of side length 2L_APPROX centered at p_0. Let \u03f5' = \u03f5/8n. \nNow, we apply <ref> to select a set S_i of size |S_i| \u2264\u03f5'^-1/2 points on each region R_i, such that every point within R_i \u2229\u210b is within distance  \u03f5' \u00b7 L_APPROX of some point in the convex hull of S_i.  \n\nDefine C_i to be the convex hull of S_i in counterclockwise order, which we can compute in linear time because the construction given in <ref> returns points that are all on the convex hull. Now, run <cit.> to solve the touring disjoint convex polygons problem for C_i exactly in |V|n = n^2 \u03f5'^-1/2\u2264n^2.5/\u221a(\u03f5) time. Recall that |V| is the total number of vertices over all polygons.\n\nIt remains to show that the solution we find from the convex polygons problem is a 1+\u03f5 approximation of the answer. Consider an optimal solution p_0 \u2208 R_0, p_1 \u2208 R_1, \u2026, p_n \u2208 R_n, p_n+1\u2208 R_n+1. Now, for every i, define p_i' to be the closest point on C_i to p_i, where <ref> guarantees p_i-p_i'\u2264\u03f5' \u00b7 L_APPROX\u2264 2\u03f5' \u00b7 OPT. Thus, \n\n    \u2211_i=0^np_i'-p_i+1'   \u2264\u2211_i=0^np_i-p_i+1 + p_i-p_i' + p_i+1-p_i+1'\n       \u2264 OPT + (n+1) \u00b7 4\u03f5' \u00b7 OPT \u2264 (1+\u03f5)OPT,\n\nas desired.\n\nFor the intersecting case, we first use <ref> with 1+\u03f5 = 2 to obtain a constant approximation of the optimal length in o(n^3.5) time. The rest of the proof is identical, except now the C_i can intersect, which changes the runtime of the application of <cit.> to |V|n^2 = n^3 \u03f5'^-1/2\u2264n^3.5/\u221a(\u03f5).\n\n\n\n\n\u00a7 DISJOINT CONVEX FAT BODIES\n\n\nIn this section, we present packing and grouping techniques for touring disjoint convex fat bodies and show how they can be applied to obtain minn/,n^2/\u221a()-time algorithms for touring disjoint convex fat bodies in 2 dimensions. Omitted proofs for this section may be found in <ref>.\n\n\n\n \u00a7.\u00a7 Techniques\n\n\n\n\n  \u00a7.\u00a7.\u00a7 Packing\n\n\nA packing argument shows that the length of the optimal path length is at least linear in the number of bodies and the minimum r_h (that is, the minimum radius of any inscribed ball). Intuitively, if we place n disjoint objects of radius at least 1 that are close to being disks on the plane, the length of the optimal tour that visits all of them should be at least linear in n for sufficiently large n. The details are in the appendix.\n\n\nAssume a fixed upper bound on r_H/r_h. Then there exists n_0= 1 such that the optimal path length OPT for touring any n \u2265 n_0 disjoint convex fat objects is \u03a9(n \u00b7min r_h). For balls, n_0=3.\n\n\nThe packing lemma allows us to obtain a strong lower bound on the length of the optimal tour in terms of the size of the regions, which will be crucial in proving that our algorithms have low relative error. \n\n\n\nLet r_i denote the ith largest r_h. For all i\u2265 n_0, r_i\u2264OPT/i.\n\n\n\n\nConsider dropping all regions except those with the i largest inner radii and let OPT_i be the optimal length of a tour that visits the remaining disks in the original order. By <ref>, for i\u2265 n_0, OPT\u2265 OPT_i\u2265\u03a9(i\u00b7 r_i) r_i\u2264OPT/i.\n\n\n\n\nThe optimal path length for touring n disjoint convex fat bodies is \u03a9( \u2211_i\u2265 n_0 r_i/logn), and there exists a construction for which this bound is tight.\n\n\n\n\nUsing <ref>,\n\n    \u2211_i\u2265 n_0r_i/log n\u2264\u2211_i\u2265 n_0OPT/i/log n\u2264OPT/log n\u2211_i=n_0^n1/i\u2264OPT.\n\nWe display the construction in <ref>; we defer the full description to the appendix. The idea is to place disjoint disks of radii 1/1, 1/2, 1/3, \u2026 such that they are all tangent to a segment of the x-axis of length 1.\n\n\n\n\n\n\n  \u00a7.\u00a7.\u00a7 Grouping\n\n\nWe now show that we can split up the optimal path into smaller subpaths by splitting the sequence of bodies into groups of consecutive bodies, finding the minimum-sized body in each group, and considering the subpaths between these small bodies. By the packing lemma, the sum of the radii of the representatives is small compared to the total path length.\n\nIn particular, using groups of size 1/\u03f5, we can compress the smallest sized region into a single point, meaning that we can consider touring regions between these points independently from each other. This allows us to turn any polynomial time approximation scheme for touring disjoint convex fat bodies into one that is linear in n. \n\n\n\nGiven an algorithm for touring disjoint convex fat bodies in d dimensions that runs in f(n, ) time, where f is a polynomial, we can construct an algorithm that runs in (n+1) \u00b7 f(1/, ) time (for \u2264(1)).\n\n\n\nWe describe an algorithm achieving a (1+())-approximation. To achieve a (1+)-approximation, scale down  by the appropriate factor.\n \nDefine s \u225c\u23081/\u03f5\u2309 and let n_0 be the constant defined in the statement of <ref>. We will prove the statement for all \u03f5 satisfying 1/\u03f5\u2265 n_0. First, we divide the n+2 regions (including R_0 and R_n+1) into k=maxn+2/s,2\u2264n+1 consecutive subsequences, each with exactly s regions (except the starting and ending subsequences, which are allowed to have fewer).\n\nLet M_i be the region with minimum inscribed radius r_h in the ith subsequence; note that M_1=R_0 and M_k=R_n+1. For each i \u2208[1,k], pick an arbitrary point p_i\u2208 M_i. Let OPT' be the length of the shortest tour of R_0,\u2026,R_n+1 that passes through all of the p_i. The p_1,\u2026,p_k form k-1 subproblems, each with at most 2s regions. Therefore, we can (1+)-approximate OPT' by (1+)-approximating each subproblem in\n(k-1) \u00b7 f(2s,\u03f5)\u2264 (n+1) \u00b7 f(1/, ) time.\n\nIt remains to show that OPT' is a (1+O(\u03f5))-approximation for OPT. Let r_i be shorthand for the radius r_h of M_i (r_1=r_k=0). By the definition of fatness, the distance between any two points in M_i is at most r_i. By following through OPT and detouring to each point p_i, we get a path through points p_i with length at most OPT+\u2211 r_i, and OPT' is at most this amount. \n\nThe last remaining step is to show \u2211 r_i\u2264\u03f5\u00b7 OPT. We apply <ref> to each subsequence, and obtain that r_is\u2264OPT_i, where OPT_i is the optimal distance to tour regions in subsequence i. Note that although the starting and ending subsequences can have sizes less than s, they satisfy r_i=0, so this bound holds for all subsequences. Therefore, \u2211 r_i\u2264\u03f5\u00b7\u2211 OPT_i\u2264\u03f5\u00b7 OPT.\n\n\n\n\n \u00a7.\u00a7 Algorithms for convex fat bodies\n\n\nUsing a similar grouping argument, but using constant sized instead of 1/\u03f5 sized groups, along with earlier methods of using estimates of the path length to place points on the boundaries of the convex fat bodies yields the following results.\n\n\nThere is an n/^2d-2-time algorithm for touring disjoint convex fat bodies in d dimensions.\n\n\n\nWe proceed in a similar fashion as <ref>, except we define s \u225c n_0, i.e., using constant sized groups instead of \u23081/\u03f5\u2309 sized groups. Let the M_i be defined as in the proof of <ref>, and define m_i to be the outer radius of M_i.\n\nFor each pair of regions M_i,M_i+1, pick arbitrary points a\u2208 M_i,b\u2208 M_i+1, and use <ref> to\nobtain a 4-approximation D_approx of the length of the shortest path from a to b in 1 time.\nSuppose that the optimal path uses p\u2208 M_i, q\u2208 M_i+1 and the shortest path from a to b has distance OPT_a,b;\nby the triangle inequality, we must have\n\n    1/4 D_approx\u2264 OPT_a,b\u2264 OPT_i + 2m_i + 2m_i+1.\n\n\nNow, consider the path where we start at p and then travel along the line segment from p to a, the approximate path of length D_approx from a to b (visiting the regions in between M_i and M_i+1), and the line segment from b to q. This path has length at most D_approx+2m_i+2m_i+1, and upper bounds the length of the optimal path between p and q. So, the entire path between p and q lies within a ball of radius D_approx+4m_i+2m_i+1 centered at a; call this ball L. Note that L has radius l = D_approx+4m_i+2m_i+1\u2264OPT_i+m_i+m_i+1.\n\nFor each region R_j between M_i and M_i+1 inclusive, we apply <ref> with the region and a hypercube containing\nL, which has side length 2l. Note that points are placed twice on each M_i; this is fine. <ref> guarantees\nthe existence of a point in R_j that is 2l\u03f5 close to the point OPT uses by placing 1/\u03f5^d-1 points on each region.\n\nWe now bound the difference between the optimal and the shortest paths using only the points we placed.\nThe difference is at most\n\n    \u2211_i=1^k(2 l_i\u03f5\u00b7 n_0)\n        =\u03f5\u00b7\u2211_i=1^k l_i\n        =\u03f5\u00b7OPT + \u2211_i=1^k m_i=\u03f5\u00b7 OPT,\n\nwhere the last step is due to <ref> applied on each subsequence: in particular, the optimal path length visiting all the regions in subsequence i has length at least \u03a9(m_i), so summing this inequality over all subsequences, we have \u2211_i=1^k m_i \u2264OPT.\n\nWe have now reduced the problem to the case where each region has only finitely many points.\nWe finish with dynamic programming. Since we have 1/\u03f5^d-1 points on each of the n regions, the runtime is\nn/\u03f5^2d-2, as desired.\n\n\n\nThere is an n/-time algorithm for touring disjoint convex fat bodies in 2 dimensions.\n\n\n\nThis is almost the same as <ref>, where 1/\u03f5^d-1 = 1/\u03f5 points are placed on each body,\nexcept that we use <ref> to more efficiently solve the case where each region is a finite point set.\n\n\n\n\n\n\n\n\nThere is an n^2/\u221a()-time algorithm for touring disjoint convex fat bodies in 2 dimensions.\n\n\n\n<ref> through the construction of <ref> places 1/\u03f5 points on an arc of length R on each convex fat body to guarantee additive error \u2264\u03f5 R. We can achieve the same additive error using a convex polygon with \u03f5^-1/2 vertices using <ref>. Then, recall that <cit.> gives an |V|n-time exact algorithm for touring convex polygons, so we can recover a solution in |V|n = (n \u00b7\u03f5^-1/2) \u00b7 n time.\n\n\n\n\n\n\u00a7 BALLS\n\n\n\nWe can improve the results in previous sections by discretizing the surfaces non-uniformly, placing fewer points on areas of each hypersphere that are farther away from the previous and next ball in the sequence. This reduces the dependence on  by a square root compared to <ref> and <ref>. Omitted proofs for this section may be found in <ref>. We first state the results:\n\n\n\n\nThere is an n/^d-1log^21/+1/^2d-2-time algorithm for touring disjoint balls in d dimensions.\n\n\n\nThe crucial lemma we use for these results follows. We defer its proof to the appendix.\n\n\nA tour of disjoint balls is globally optimal if and only if for each intermediate ball, the tour either passes straight through the ball or perfectly reflects off its border (see <Ref> for an example).\n\n\n\n\nWe start with the special case of unit disks and then generalize to non-unit disks (<ref>). First, we provide intuition through a simple example where n=1 and R_1 is a line.\n\n\nGiven start and endpoints p_0=(-1,1) and p_2=(1,1), select p_1 from the x-axis such that OPT=p_0-p_1+p_1-p_2 is minimized.\n\n\n\nTo solve this exactly, choose p_1=(0,0) such that the path perfectly reflects off the x-axis. This gives OPT=2\u221a(2). \n\nNow suppose that we are only interested in an approximate solution. Tile the x-axis with points at regular intervals such that every two consecutive points are separated by distance d, and round p_1 to the closest such point p_1'. Since p_1-p_1'\u2264 d,\n\n    OPT'   \u225cp_0-p_1'+p_1'-p_2\n       \u2264\u221a(1+(1-d)^2)+\u221a(1+(1+d)^2)\u2264\u221a(2-2d+d^2)+\u221a(2+2d+d^2)\n       \u2264\u221a(2)(1-d/2+1+d/2+d^2)\u2264 2\u221a(2)(1+d^2).\n\n\nSo, to attain OPT'\u2264 (1+)OPT, it suffices to take d=\u0398(\u221a()) rather than d=\u0398() because p_1'-p_1 is parallel to the x-axis. We can apply a similar idea to replace the middle region with a point set when R_1 is a circle rather than a line since circles are locally linear. However, this doesn't quite work when either p_0-p_1 or p_1-p_2 is small. For example, if p_0 was very close to the x-axis (say, p_0=(-d,d)) then rounding p_1 to the nearest p_1' could cause OPT' to increase by \u0398(d)\u226b d^2. So when we replace each circle with a point set, we need to be careful about how we handle two circles that are close to touching; the solution is to space points more densely near where they touch.\n\n\n\nThere is an n/\u221a()log1/-time algorithm for touring disjoint unit disks.\n\n\n\nWe describe how to place a set of 1/\u221a()log1/ points S_i on each unit circle c_i so that the length of an optimal path increases by at most n after rounding each p_i to the nearest p_i'\u2208 S_i.\n\nDefine (x)=x/x. Let o_i\u225c p'_i-p_i for all i\u2208 [0,n+1] (note that o_0=o_n+1=0), where o stands for offset. Also, define vectors \n\n    d_i\u225c p'_i+1-p'_i=p_i+1+o_i+1-p_i-o_i\n\nand scalars\n\n    a_i\u225c d_i\u00b7(p_i+1-p_i)=p_i+1-p_i+(o_i+1-o_i)\u00b7(p_i+1-p_i),\n\nwhere a_i is the component of d_i along the direction of p_i+1-p_i. Then the total path length after rounding each p_i to p_i' is:\n\n    \u2211_i=0^nd_i   =\u2211_i=0^n\u221a([d_i\u00b7(p_i+1-p_i)]^2+[d_i\u00b7(p_i+1-p_i)^\u22a5]^2)\n       =\u2211_i=0^n\u221a(a_i^2+[(o_i+1-o_i)\u00b7(p_i+1-p_i)^\u22a5]^2)\n       =\u2211_i=0^n[a_i+(\u221a(a_i^2+[(o_i+1-o_i)\u00b7(p_i+1-p_i)^\u22a5]^2)-a_i)] \n       =OPT+\u2211_i=1^n o_i\u00b7 ((p_i-p_i-1)-(p_i+1-p_i))^extra_1(i)\n          +\u2211_i=0^n(\u221a(a_i^2+[(o_i+1-o_i)\u00b7(p_i+1-p_i)^\u22a5]^2)-a_i)^extra_2(i)\n       =OPT+\u2211_i=1^nextra_1(i)+\u2211_i=0^nextra_2(i).\n\nWe defer the construction of the sets S_i so that both extra terms are small to <ref>. Then we can finish with dynamic programming (<ref>).\n\n\n\nIt is possible to choose S_i in the proof of <Ref> such that |S_i|\u22641/\u221a()log1/, extra_1(i)\u2264, and extra_2(i)\u2264 for all i.\n\n\n\nFirst, we present the construction. For every pair of adjacent disks i and i+1 we describe a procedure to generate points on their borders. Then we set S_i to be the union of the generated points on the border of disk i when running the procedure on disks (i,i+1), and the generated points on the border of disk i when running the procedure on disks (i-1,i). Finally, we show that extra_1(i) and extra_2(i) are sufficiently small for all i for our choice of S_i.\n\n\n\n    Procedure\n Reorient the plane that c_i=(0,y) and c_i+1=(0,-y) for some y>1. \n Let \u211d_\u2265 0\u2192\u211d_>0 be a function that is nonincreasing with respect to |\u03d5| that we will define later. Given , we use the following process to add points to S_i (and symmetrically for S_i+1):\n\n\n    \n  * Set \u03d5=0.\n    \n  * While \u03d5\u2264\u03c0:\n    \n        \n  * Add (sin\u03d5, y-cos\u03d5) to S_i.\n        \n  * \u03d5+=(\u03d5).\n    \n    \n  * Repeat steps 1-2 but for \u03d5 from 0 to -\u03c0.\n\nThis procedure has the property that for any \u03d5\u2208 [-\u03c0,\u03c0], the point (sin\u03d5, y-cos\u03d5) is within distance (|\u03d5|) of some point in S_i. In particular, if the optimal path has p_i=(sin\u03d5_i,y-cos\u03d5_i) then it is guaranteed that o_i\u2264(\u03d5_i). To compute |S_i|, note that as long as (\u03d5) is sufficiently smooth that (\u03d5)/\u03d5+(\u03d5)=\u0398(1) for all \u03d5, the number of points added to S_i will be at most a constant factor larger than the value of the definite integral \u222b_-\u03c0^\u03c01/(\u03d5)  d\u03d5. \n\nNext, we construct  so that |S_i|=1/\u221a()log1/. Intuitively, by <ref>, we should have (\u03d5)=\u0398() closer to circle i+1 (when \u03d5\u2248 0) and (\u03d5)=\u0398(\u221a()) farther from circle i+1 (when \u03d5=\u0398(1)). Thus, we set (\u03d5)=max(,\u221a()\u03d5). The total number of added points is on the order of:\n\n    \u222b_0^\u03c01/(\u03d5)  d\u03d5   =1/\u221a()(\u222b_0^\u221a()1/\u221a()  d\u03d5+\u222b_\u221a()^\u03c01/\u03d5  d\u03d5)\n       =1/\u221a()(1+log(\u03c0/\u221a()))\u22641/\u221a()log1/.\n\n\nFinally, we show that both extra terms are small for our choice of S_i.\n\n*Part 1: extra_1(i). \n\nWe note that (p_i-p_i-1)-(p_i+1-p_i) must be parallel to p_i-c_i for an optimal solution p. To verify this, it suffices to check the two possible cases from <Ref>:\n\n    \n  * The points p_i-1,p_i,p_i+1 are collinear, in which case (p_i-p_i-1)-(p_i+1-p_i)=0.\n    \n  * The path reflects perfectly off circle i, in which case (p_i-p_i-1)-(p_i+1-p_i) is parallel to p_i-c_i.\n\n\nIf we ensure that spacing(\u03d5)\u2264\u221a() for all \u03d5, then |o_i\u00b7(p_i-c_i)|\u2264 because o_i is always nearly tangent to the circle centered at c_i at point p_i. The conclusion follows because extra_1(i)\u2264 2|o_i\u00b7(p_i-c_i)|\u2264 2.\n\n*Part 2: extra_2(i).\n\nWe upper bound extra_2(i) by the sum of two summands, the first associated only with o_i and the second associated only with o_i+1.\n\n\nLetting ycoord(\u00b7) denote the y-coordinate of a point,\n\n    extra_2(i)\u2264 2\u00b7( min(o_i,4o_i^2/ycoord(p_i))+min(o_i+1,4o_i+1^2/-ycoord(p_i+1))).\n\n\n\n\nWe do casework based on which term is smaller on each of the mins.\n\n    \n  * o_i\u2265ycoord(p_i)/4, o_i+1\u2265-ycoord(p_i+1)/4\n    \n    The result, extra_2(i)\u2264 2(o_i+o_i+1), follows by summing the following two inequalities:\n    \n    \n    \u221a(a_i^2+[(o_i+1-o_i)\u00b7(p_i+1-p_i)^\u22a5]^2)-p_i+1-p_i\n       =p_i+1-p_i+o_i+1-o_i-p_i+1-p_i\n       \u2264o_i+o_i+1\n\n    and p_i+1-p_i-a_i\u2264o_i+o_i+1.\n    \n    \n  * o_i\u2264ycoord(p_i)/4, o_i+1\u2264-ycoord(p_i+1)/4\n    \n    Then o_i, o_i+1\u2264p_i+1-p_i/4 so a_i\u2265p_i+1-p_i/2, and\n    \n    extra_2(i)   \u2264o_i+1-o_i^2/2a_i\u22642(o_i+1^2+o_i^2)/2a_i\n       \u2264 2\u00b7o_i+1^2+o_i^2/p_i-p_i+1\u2264 2\u00b7(o_i^2/ycoord(p_i)+o_i+1^2/-ycoord(p_i+1)).\n\n    \n    \n  * o_i\u2264ycoord(p_i)/4, o_i+1\u2265-ycoord(p_i+1)/4\n    \n    Define extra'(i) to be the same as extra_2(i) with o_i+1 set to 0. Then\n    \n    extra'(i)   \u225cp_i+1-p_i-o_i-(p_i+1-p_i-o_i\u00b7(p_i+1-p_i))\n       =\u221a((p_i+1-p_i-o_i\u00b7(p_i+1-p_i))^2+[o_i\u00b7(p_i+1-p_i)^\u22a5]^2)\n          -(p_i+1-p_i-o_i\u00b7(p_i+1-p_i))\n       \u2264o_i^2/2\u00b73/4p_i-p_i+1\u2264o_i^2/2\u00b73/4\u00b7ycoord(p_i)\n\n    and by similar reasoning as case 1, extra_2(i)-extra'(i)\u2264 2o_i+1.\n    \n    \n  * o_i\u2265ycoord(p_i)/4, o_i+1\u2264-ycoord(p_i+1)/4\n    \n    Similar to case 3. \n\n\nNow that we have a claim showing an upper bound on extra_2(i), it remains to show that min(o_i,o_i^2/ycoord(p_i))\u2264 for our choice of . Indeed, when \u03d5\u2264\u221a() we have o_i\u2264(\u03d5)\u2264, while for \u03d5>\u221a() we have o_i^2/ycoord(p_i)\u2264(\u03d5)/\u03d5^2\u2264.\n\n\nWith small modifications to the proof of <Ref>, we have the following corollary:\n\n\nConsider the case of non-unit disks. If the ith disk has radius r_i, then we can place 1/\u221a()_ilog1/_i points on its border such that the additive error associated with c_i \u2014specifically, extra_1(i) plus the components of extra_2(i-1) and extra_2(i) associated with o_i \u2014is r_i_i. Consequently,\nOPT+\u2211_i=1^nextra_1(i)+\u2211_i=0^nextra_2(i)\u2264 OPT+\u2211_i=1^nr_i_i.\n\n\nNow, we finally prove <ref>.\n\n\nWe first present a slightly weaker result, and then show how to improve it. Recall that by <ref>, the ith largest disk has radius OPT/i for i\u2265 3. So if we set _i='=/log n for each of the ith largest disks for i\u2265 3, the total additive error contributed by these disks becomes\n\n    \u2211_i=3^nOPT/i\u00b7_i\u2264OPT\u00b7'\u00b7\u2211_i=3^n1/i\u2264 OPT\n\nby <ref>. For the two largest disks, we use the previous naive discretization (placing 1/ points uniformly on the intersection of the circles with a square of side length OPT centered about the starting point). We may assume we have already computed a constant approximation to OPT in n time by applying <ref> with =1. After selecting the point sets, we can finish with <ref>. The overall time complexity is\nn/\u221a(')log1/'+1/\u2264n\u221a(log n)/\u221a()loglog n/+1/.\n\nWe can remove the factors of log n by selecting the _i to be an increasing sequence. Set _i=\u0398 i^2/3/n^2/3 for each i\u2208 [3,n] such that more points are placed on larger disks. Then the total added error remains\n\n    OPT\u00b7+\u2211_i=3^n_i/i   =\n    OPT\u00b7+\u2211_i=3^n1/i\u00b7 i^2/3/n^2/3\n       =OPT\u00b71+n^-2/3\u00b7\u2211_i=3^ni^-1/3\u2264OPT,\n\nand the factors involving log n drop out from the time complexity:\n\n    \u2211_i=3^n1/\u221a()_ilog1/_i+1/   \u2264\u222b_i=3^n1/\u221a()n^1/3i^-1/3logn^2/3/i^2/3di +1/\n       \u22643n^1/3/2\u221a(\u03f5)i^2/3logn^2/3/i^2/3\u03f5+1|_3^n+1/\u03f5\n       \u2264n/\u221a()log1/+1/.\n\n\n\nWe note that under certain additional assumptions, the time complexity of <Ref> can be slightly improved. We summarize these in the following corollary, which we state without proof.\n\n\nIf any of the following conditions hold:\n\n    \n  * the two largest disks are not adjacent in the order\n    \n  * the two largest disks are separated by distance \u03a9(OPT)\n    \n  * the second-largest disk has radius OPT\n\nthen a generalization of <Ref> may be applied to remove the 1/ term from the time complexity of <Ref>.\n\n\nTo extend to multiple dimensions, we generalize the construction from <Ref>.\n\n\n As in <Ref>, set (\u03d5)=max(,\u221a()\u03d5) for a point p_i satisfying m\u2220 p_ic_ic_i+1=\u03d5, meaning that there must exist p_i'\u2208 S_i satisfying p_i-p_i'\u2264 r_i\u00b7(\u03d5). The total number of points |S_i| placed on the surface of a d-dimensional sphere is proportional to\n\n    \u222b_0^\u03c0sin^d-2(\u03d5)/(\u03d5)^d-1  d\u03d5   \u22641/(\u221a())^d-1\u222b_0^\u03c0\u03d5^d-2/max(\u221a(),\u03d5)^d-1  d\u03d5\n       =1/^(d-1)/2\u222b_0^\u221a()\u03d5^d-2/(\u221a())^d-1  d\u03d5 + \u222b_0^\u221a()1/\u03d5  d\u03d5\n       \u22641/^(d-1)/2log1/.\n\nwhere the derivation of the integration factor sin^d-2(\u03d5) can be found in <cit.>. \n\nIt remains to describe how to space points so that they satisfy the given spacing function. For each spacing s=, 2, 4, \u2026, \u221a(), we can find a d-dimensional hypercube of side length O(s/\u221a()) that encloses all points on the hypersphere with required spacing at most 2s. Evenly space points with spacing s across the surface of this hypercube according to <Ref>, and project each of these points onto the hypersphere. There are a total of log1/ values of s, and each s results in 1/^(d-1)/2 points being projected onto the hypersphere, for a total of 1/^(d-1)/2log1/ points.\n\n\n\n\n\n\n\n\n\n\n\n\n\u00a7 APPENDIX\n\n\nOrganization: The three subsections contain omitted proofs from sections 2, 3, and 4, respectively.\n\n\n\n \u00a7.\u00a7 Convex bodies: omitted proofs\n\n\n\nDefine c_1\u225cclosest_C(p_1) and c_2\u225cclosest_C(p_2). Since C is convex, C must contain all points on the segment connecting c_1 and c_2. Thus, it must be the case that (p_1-c_1)\u00b7 (c_2-c_1)\u2264 0, or some point on the segment connecting c_1 and c_2 would be closer to p_1 than c_1. Similarly, it must be the case that (p_2-c_2)\u00b7 (c_2-c_1)\u2265 0. To finish,\n\n    (p_2-p_1)\u00b7 (c_2-c_1)   \u2265 (p_2-c_2+c_2-c_1+c_1-p_1)\u00b7 (c_2-c_1)\n       \u2265 (c_2-c_1)\u00b7 (c_2-c_1)\u2265c_2-c_1^2,\n\nimplying p_2-p_1\u2265c_2-c_1.\n\n\n\nConsider some point p \u2208 (\u2202 C) \u2229\u210b. By the convexity of C and because p lies on its boundary, there exists some unit vector v\u20d7 such that p \u00b7v\u20d7\u2265 x \u00b7v\u20d7 for any x \u2208 C. Let the intersection of \u210b with the ray starting at p and going in the direction of v\u20d7  be the point s. Notice that _C(s) = p. \n\nNow, define s' \u2208 S_\u210b to be the closest such point to s. From our construction of S_\u210b, s-s'\u2264 r. From our construction of S, _C(s') \u2208 S, and since _C(s) = p, after applying <ref>, we have p-_C(s')\u2264 r.\n\n\n\nFirst, we show that there exists a path p' touring the S_i that is nearly as short as the shortest path touring the R_i.\n\n\nIf OPT\u2264 L_APPROX, there exists an increasing sequence 0 = z_0 < z_1 < \u2026 < z_l = n+1 and points p_z_i' such that p_z_i' \u2208 S_z_i for all i and p_z_i' \u2208 R_j for all i, j satisfying 0 \u2264 i \u2264 l-1, z_i \u2264 j < z_i+1, and \u2211_i=0^l-1p_z_i'-p_z_i+1'\u2264 OPT+\u03b3 L_APPROX. Additionally, if the regions are disjoint, there exists a sequence that satisfies the above conditions that also satisfies z_i = i for all i.\n\n\n\nDefine D(z_t, p_z_t') to be the minimum distance for touring regions R_z_t, R_z_t+1, \u2026, R_n starting at p_z_t' and ending at p_n+1. We show by induction that for all t\u2264 l, there exists a sequence p_z_0,\u2026,p_z_t satisfying the invariant\n\n    \u2211_i=0^t-1p_z_i'-p_z_i+1' + D(z_t, p_z_t) \u2264 OPT+t/2n\u00b7\u03b3 L_APPROX.\n\nNote that for t=l, (<ref>) implies\n\n    \u2211_i=0^l-1p_z_i'-p_z_i+1'\u2264 OPT + l/2n\u00b7\u03b3 L_APPROX\u2264 OPT + \u03b3 L_APPROX,\n\nas desired.\n\nBase Case: First, define z_0 = 0, p_z_0' = p_0. The invariant holds for t=0. \n\nInductive Step: Suppose we have already constructed z_0, z_1, \u2026, z_t and p_z_0', p_z_1', \u2026, p_z_t'. It remains to show how to construct z_t+1, p_z_t+1' from z_t, p_z_t' such that the invariant is maintained.\n\nLet z_t+1\u2264 n be the smallest integer greater than z_t such that p_z_t' \u2209 R_z_t+1. If all R_i are disjoint, then clearly z_t+1 = z_t+1. If no such z_t+1 exists, then we set z_t+1 = n+1. Consider an optimal path q_z_t, q_z_t+1, q_z_t+2, \u2026, q_n+1 for touring regions R_z_t, R_z_t+1, \u2026, R_n starting at q_z_t = p_z_t' and ending at q_n+1 = p_n+1, with total length D(z_t, p_z_t'). Because q_z_t = p_z_t' \u2208 R_j for all z_t \u2264 j < z_t+1, we can consider an optimal path that satisfies q_z_t = q_z_t+1 = q_z_t+2 = \u2026 = q_z_t+1-1, and q_z_t+1 lies on the boundary of R_z_t+1. In other words, the optimal path does not need to move from its starting point if it is contained within some prefix of the regions, and it can always choose q_z_t+1 to be its first point of contact with R_z_t+1. Therefore q_z_t+1\u2208\u2202 C_z_t+1, w for some 1\u2264 w\u2264 |R_z_t+1|. \n\nFurthermore, a path exists from p_0 to p_z_t' = q_z_t to p_n+1 with length \n\n    \u2211_i=0^t-1p_z_i'-p_z_i+1' + D(z_t, p_z_t') \u2264 OPT+t/2n\u00b7\u03b3 L_APPROX\u2264 OPT + L_APPROX\u2264 2L_APPROX,\n\nindicating that q_z_t+1-p_0\u2264 2L_APPROX, which in turn implies q_z_t+1\u2208\u210b.\n\nThus, q_z_t+1\u2208 (\u2202 C_z_t+1, w)\u2229\u210b, so by <ref> there exists some point p_z_t+1' \u2208 S_z_t+1 such that p_z_t+1'-q_z_t+1\u2264\u03f5\u00b7 r = \u03b3/16n\u00b7 4 L_APPROX. Now, we can show that the invariant holds for t+1:\n\n    \u2211_i=0^tp_z_i'-p_z_i+1' + D(z_t+1, p_z_t+1') \n       \u2264\u2211_i=0^tp_z_i'-p_z_i+1' + p_z_t+1'-q_z_t+1+\u2211_i=z_t+1^nq_i-q_i+1\n       \u2264\u2211_i=0^t-1p_z_i'-p_z_i+1' +\n        p'_z_t-q_z_t+1 + 2p_z_t+1'-q_z_t+1+\u2211_i=z_t+1^nq_i-q_i+1\n       \u2264\u2211_i=0^t-1p_z_i'-p_z_i+1' + p'_z_t-q_z_t+1 + 2 r +\u2211_i=z_t+1^nq_i-q_i+1\n       = 2 r + \u2211_i=0^t-1p_z_i'-p_z_i+1'  + D(z_t, p_z_t') \n       \u2264 2  r + OPT + t/2n\u00b7\u03b3 L_APPROX\n       = OPT + \u03b3 L_APPROX/2n + t/2n\u00b7\u03b3 L_APPROX = OPT + t+1/2n\u00b7\u03b3 L_APPROX.\n\n(<ref>) follows from p_z_t+1', q_z_t+1+1, \u2026, q_n+1 being a valid tour of regions R_z_t+1, R_z_t+1+1, \u2026, R_n, while (<ref>) follows from the triangle inequality.\n\nRecall that if all R_i are disjoint, then z_t+1 = z_t+1  z_i = i for all i.\n\n\nIt remains to show that we can recover a path touring the S_i that is at least as good as p'. For each point p \u2208 S_i for some i, define successor(p) to be the minimum j > i such that p \u2209 R_j. Notice that successor(p_z_i') = z_i+1. Now, define pred(S_j) for each S_j to be the set of all points p such that successor(p) = j.\n\nWe use dynamic programming: first, set dp(p_0) = 0. Then, iterate over the sets S_i in increasing i. For each point x \u2208 S_i, we will set dp(x)\u225cmin_y \u2208 pred(S_j)dp(y)+x-y. By storing the optimal transition for each point, we can recover a path q_0, q_1, \u2026, q_l_q that tours the R_i regions. Because successor(p_z_i') = z_i+1 for the path (p_i'), we must have that the path recovered from dynamic programming has length at most \u2211_i=0^l-1p_z_i'-p_z_i+1'.\n\nIf the R_i are disjoint, then pred(S_j) = S_j-1 and the total number of transitions in the DP is given by\n\n    \u2211_i=0^n |S_i||S_i+1| = \u2211_i=0^n |R_i|n/\u03b3^d-1\u00b7 |R_i+1| n/\u03b3^d-1,\n\nas desired. If the R_i are possibly non-disjoint, notice that the total number of transitions in the DP is given by \n\n    \u2211_i=0^n\u2211_p \u2208 S_i|S_successor(p)|n/\u03b3^d-1   \u2264\u2211_i=0^n\u2211_p \u2208 S_imax_j |R_j| n/\u03b3^d-1\n       \u2264\u2211_i=0^n |R_i|n/\u03b3^d-1max_j |R_j| n/\u03b3^d-1\n       \u2264n/\u03b3^2d-2\u2211_i=0^n |R_i|max_j|R_j|.\n\n\n\n\nUsing the oracle to project p_0 onto each of the regions R_1, R_2, \u2026, R_n to obtain points p_1, p_2, \u2026, p_n. Now, let OPT be the total length of the optimal solution for the problem. Clearly, we must have p_i-p_0\u2264 OPT. Thus,\n\n    \u2211_i=0^np_i+1-p_i   \u2264p_1-p_0 + \u2211_i=1^np_i+1-p_0+p_i-p_0\n       \u2264 OPT + 2n \u00b7 OPT = (2n+1)OPT.\n\n\n\n\nFirst, apply <ref> to get a 1+2n approximation. Label the path length of this approximation L_0. Define B_0 = 1+2n, where we know L_0/B_0\u2264 OPT\u2264 L_0. Our goal is to show that given some L_t, B_t, we can generate L_t+1, B_t+1 so that L_t+1/B_t+1\u2264 OPT\u2264 L_t+1, and B_t+1\u2264 2\u221a(B_t). \n\nWe apply <ref> with \u03b3 = 1, L_APPROX = L_t/\u221a(B_t). Let L_APPROX' be the length of the optimal tour that visits S_0, S_1, \u2026, S_n+1. There are two possible cases.\n\n\n    \n  * L'_APPROX\u2264 2L_APPROX. In this case, we know that \n    L_t/B_t\u2264 OPT\u2264 L'_APPROX\u2264 2L_APPROX=2L_t/\u221a(B)_t, so we can set L_t+1=2L_t/\u221a(B)_t and B_t+1=2\u221a(B_t).\n    \n    \n  * L'_APPROX > 2L_APPROX. In this case we know that OPT>L_APPROX, because <ref> guarantees that if OPT \u2264 L_APPROX, then L'_APPROX\u2264 OPT + \u03b3 L_APPROX\u2264 2L_APPROX. Thus,\n    L_t/\u221a(B)_t=L_APPROX< OPT\u2264 L_t,\n    so we can set L_t+1=L_t and B_t+1=\u221a(B)_t.\n\n\nThus, we can generate the sequences (L_i) and (B_i) until we reach some B_l \u2264 4 for some l \u2264loglogn in loglogn\u00b7 n^2d-2\u2211_i=1^n-1|R_i||R_i+1| time. This gives us some L_l such that OPT \u2264 L_l \u2264 4 \u00b7 OPT, a constant approximation of OPT.\n\n\n\n\nThe bulk of the time for the second bound is spent computing successor(p) for every one of the n^2/ points in the discretization, which could take \u0398(n) calls to the oracle, contributing the factor of n^3/. On the other hand, the actual dynamic programming updates contribute only n^2/logn^2/.\n\n\n\nHere we describe how to modify the method of <cit.> to achieve the desired time complexity. The approach we describe in this paper is a more general method (which can be modified similarly).\n\nAs in our approach, the method of <cit.> involves a pseudo-approximation: the idea is to intersect every one of the |V| edges with a disk of radius L_APPROX centered at p_0, discretize every one of the |V| edges into n/ evenly spaced points, and then apply dynamic programming as described in the previous subsection. Naively, these DP transitions run in |V|n/^2 time, but <ref> speeds these transitions up to |V|n/log|V|/ time. The first term in the time complexity corresponds to the time required to obtain a constant approximation by setting =1, as described in <ref>.\n\nWhen the regions can possibly intersect, we additionally need a data structure that will compute successor(p) for any p\u2208\u2202 R_i in log |V| time. The construction of such a data structure contributes the additional term to the time complexity.\n\nNow, we describe how to generate a separate data structure for each edge e\u2208\u03b4 R_i such that each data structure can answer successor(p) for any p\u2208\u2202 e in log |V| time. This construction runs in |V|^2\u03b1(|V|) time.\n\nFirst, for each edge  e\u2208\u03b4 R_i we need to compute which parts of it belong to each other region R_j where j>i. To do so, we need to know\n\n    \n  * For each such region, whether the endpoints of e are contained within that region.\n    \n  * The intersection points of e with all such regions in sorted order along the edge (at most |V|, assuming non-degeneracy).\n\nThese quantities can be computed in |V|^2 time due to Balaban <cit.>. \n\nThe intersection points partition e into ranges such that the first j>i such that a point belongs to R_j is the same for all points within the range (see <ref>). If we have computed the first j>i for every such range, we can answer queries in log v time via binary search.\n\n\n\nTo do so, we start by iterating over all intervals of e contained within R_i+1 and setting all ranges that they cover to have successor=i+1. This determines the answer for three of the ranges in <ref>. Then do the same for R_i+2,R_i+3,\u2026 and so on. Note that there are |V| intervals in total.\n\nNaively, such an implementation would run in |V|^2 time; however, using Tarjan's disjoint set union data structure <cit.>, we can speed up this process to |V|\u03b1(|V|) time, where \u03b1 is the inverse Ackermann function.  We assume an implementation of DSU that initially assumes that every range is its own representative, and supports both of the following operations in amortized \u03b1(|V|) time:\n\n    \n  * (x): Return the representative of range x.\n    \n  * (x,y): Given a range x such that (x)=x, for each range that x is a representative of, set its representative to be (y).\n\n\nFor an interval covering ranges [l,r] belonging to R_j, we use the following process to set the answers for every range it covers whose successor has not been set yet:\n\n    \n  * Set l=(l).\n    \n  * If l>r, break.\n    \n  * Set successor(l)=j\n    \n  * Call (l,l+1).\n    \n  * Return to step 1.\n\nThe correctness of this procedure follows from the DSU maintaining the invariant that the representative for a range is the first range that succeeds it whose successor has not been set yet.\n\n\n\n\nFirst, see <ref> for the case where C lies strictly within U. Next, we describe what needs to be changed when this is not the case:\n\nIf we have exact access to \u2202(U)\u2229 C, then we can convert a closest point oracle for C into a closest point oracle for C\u2229 U and apply the previous lemma to select points on \u2202 (C\u2229 U). Note that due to the convexity of C, the intersection of each side of U with C is a line segment if it is nonempty, and the endpoints of this line segment can be approximated to arbitrary precision using the oracle to binary search. \n\nSpecifically, if C intersects a side s\u2286\u2202(U), we can approximate this intersection by binary searching on s. Say we take some p\u2208 s such that p\u2209C; then the direction of the vector from p to _C(p) tells us which side of s\u2229 C p lies on). After log1/ queries, we either end up with:\n\n    \n  * A point within C\u2229 s, and approximations of both endpoints of C\u2229 s to within distance o(\u03f5) each.\n    \n  * A segment of length o(\u03f5) containing C\u2229 s.\n\nIn either case, given an estimate of an endpoint of C\u2229 s that is within o(\u03f5) of an endpoint of C\u2229 s, by projecting the estimate onto C we get an estimate of the endpoint that is within o(\u03f5) to the true endpoint (and now is part of C).\n\nWhen querying the closest point in C\u2229 U to a point p, \n\n    \n  * Compute the closest point in U to p. If the point is within C, return it.\n    \n  * Otherwise, query the oracle for the closest point in C to p. If the point is within U, return it.\n    \n  * Otherwise, return the closest estimated endpoint (which is guaranteed to be within o(\u03f5) of the true answer). \n    \n    \n\n\n\n\n\n\n\n\n\n\nGiven a closest point oracle for a convex region C that is strictly contained within a unit square U, we may select ^-1/2 points on \u2202 C such that every point within C is within distance  of the convex hull of the selected points.\n\n\n\nLet S denote the set of all selected points. First, we state a sufficient pair of conditions for S to satisfy the desired property: For every pair of consecutive points s_1 and s_2 in S, \n\n    \n  * The distance between s_1 and s_2 along the border of C is at most \u221a().\n    \n    \n  * The difference in angle \u03b8 between the normals to C at s_1 and s_2 is at most \u221a().\n\n\nTo see that this is true, consider any point p on \u2202 C lying between s_1 and s_2, and define d\u225cdist(p,s_1s_2). See <Ref> for an illustration. Then \n\n    d/sin\u2220 ps_1s_2+d/sin\u2220 ps_2s_1=|s_1-s_2|   d/sin\u2220 s_1ps_2< |s_1-s_2| \n       d/sin\u03b8 < |s_1-s_2| \n       d/\u221a()<\u221a() d<\n\n\nInequality (<ref>) follows from m\u2220 s_1ps_2>\u03c0-\u03b8.\n\nIt remains to construct S satisfying both of the desired conditions. Note that we can actually construct two separate sets of points S_1 and S_2, one for each of the two conditions, and then set S=S_1\u222a S_2. Let S' denote a set of 41/\u221a() points spaced equally about the border of U.\n\n\n    \n  * Form S_1 by projecting each point in S' onto C.\n    \n    \n  * Form S_2 by dilating each point in S' by a sufficiently large constant about the center of U and then projecting each of these points onto C. Essentially, we use the closest point oracle to implement a tangent line oracle.  There is an alternate proof of <ref> that only involves querying the closest point oracle at points on the border of U.\n\n\nSince the distance between any two consecutive points in S' is at most 1/\u221a(), S_1 satisfies condition 1 by a stronger version of <Ref>. Furthermore, condition 1 continues to be satisfied as points from S_2 are added to S. Similarly, it's easy to verify that S_2 satisfies condition 2, and that condition 2 continues to be satisfied as points from S_1 are added to S.\n\n\n\n\nThere is no need to query the closest point oracle for points that can be infinitely far away from C (which is done in the original proof). Let's start with a set S' containing a single point on the border of U. While there are two consecutive points s_1' and s_2' in S' such that the clockwise distance between s_1' and s_2' along the border of U times the difference in angle between the normals to C at (s_1') and (s_2') is greater than , insert an additional point m into S such that m is the midpoint of the portion of \u2202(U) that goes clockwise about U from s_1' and s_2'. Once no such pair of points exists in S', set S={(s')| s'\u2208 S'}.\n\nHere is a different way to interpret this process. Start with a list of pairs initially containing only (4,2\u03c0), corresponding to the length of the border of U and the measure of a full angle, respectively. While there exists a pair (x,y) satisfying xy>, remove it from the list and add the pairs (x/2,r) and (x/2,y-r) to the list, where r\u2208 [0,y]. Here,\n\n\n    \n  * x represents an upper bound on the distance from (s_1') to (s_2') along \u2202(C), and x/2 is an upper bound on both the distances from (s_1') to (m) and the distances from (m) to (s_2') along \u2202(C).\n    \n  * y is the difference in angle between the normals to C at (s_1') and (s_2'). Adding m in between s_1' and s_2' splits this angle into two parts.\n\n\nThe correctness of the stopping condition can be proved similarly to the original proof of <Ref>.  It remains to prove that the size of the list upon the termination of this process is 1/\u221a(). Define \ud835\udc5d\ud835\udc5c\ud835\udc61\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc4e\ud835\udc59(x,y)=max(1,4\u221a(xy/)). We claim that \ud835\udc5d\ud835\udc5c\ud835\udc61\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc4e\ud835\udc59(4,2\u03c0)\u22641/\u221a() is an upper bound on the size of the list upon termination. It suffices to show that whenever xy>, the following inequality holds for any choice of r:\n\n    \ud835\udc5d\ud835\udc5c\ud835\udc61\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc4e\ud835\udc59(x,y)\u2265\ud835\udc5d\ud835\udc5c\ud835\udc61\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc4e\ud835\udc59(x/2,r)+\ud835\udc5d\ud835\udc5c\ud835\udc61\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc4e\ud835\udc59(x/2,y-r).\n\n\nThis may be rewritten as:\n\n    4\u221a(xy/)\u2265max2,4\u221a(x/2\u00b7 y/)+1,4\u221a(x/2\u00b7 r/)+4\u221a(x/2\u00b7 (y-r)/)\n\n\nwhich can easily be verified. Equality holds when r=y/2.\n\n\n\n\n \u00a7.\u00a7 Disjoint convex fat bodies: omitted proofs\n\n\n\n\tWe first see that it suffices to find an n such that the optimal path must be \u03a9(min r_h).\n\tOnce we find such an n, we can use the bound on subsequences of size n to obtain the desired result.\n\n\tLet m\u225cmin r_h. Suppose that OPT<m; it suffices to show that n= 1.\n\n\tLet C(P, r) be the sphere centered at P with radius r.\n\tPick an arbitrary point p on OPT. Observe that all of OPT lies inside C(p, m), and for each region R, there is a point q\u2208 R\u2229 C(p,m). \n\t\n\t\n\t\t\n\t\tFor all convex fat regions R with r_h\u2265 m, we must have\n\t\t(C(q,m)\u2229 R)\u2265\u03a9((C(q,m))).\n\t\t\n\t\n\t\n\tIf the claim holds, since the regions C(q,m)\u2229 R are disjoint subsets of C(p,2m),\n\twe would have n\u00b7\u03a9((C(q,m)))\u2264(C(p,2m)),\n\timplying the desired result n= 1.\n\n\t\n\t\tLet R_c be the center of a ball contained in R with radius r_h.\n\t\tConsider the case that R_c-q> 1/2 m.\n\t\tBy convexity, since q\u2208 R and (C(R_c,r_h))\u2286 R,\n\t\tthe image of a dilation of (C(R_c,r_h)) with center q and ratio m/2R_c-q\u2264 1\n\t\tis also a subset of R.\n\t\tLet image of the dilation be (C(R_c',r_h')).\n\t\tWe have that q-R_c'=1/2 m and\n\t\tr_h'=r_h\u00b7m/R_c-q\u2265 r_h\u00b7m/r_H\u2265\u03a9(m).\n\t\tTherefore, it suffices to prove that\n\t\t(C(q,m)\u2229 C(R_c, \u03a9(m)))\u2265\u03a9((C(q,m)))\n\t\tfor all points q-R_c\u22641/2 m.\n\n\t\tWLOG \u03a9(m)\u22641/2 m. Then C(R_c, \u03a9(m)) lies entirely inside (C(q,m)), so\n\t\t(C(q,m)\u2229 C(R_c, \u03a9(m)))= ( C(R_c, \u03a9(m))) \u2265\u03a9((C(q,m))),\n\t\tas desired.\n\t\n\n\t\n\t\n\t\tThe bound for balls is n_0=3.\n\t\n\n\t\n\t\tFirst, we reduce this claim to the 2D case.  More specifically, we want to show that in the case of three balls,\n\t\tthe optimal path must lie on the plane P containing the centers of the balls. \n\t\t\n\t\tFor any path p, the projection p' of p onto P is also a valid path\n\t\tand has length at most the length of p. We note that projection never increases\n\t\tthe length of a segment; therefore, the distances of the points on the path to\n\t\tthe centers of their respective balls must have decreased. Therefore, p' still passes through all three balls, and the length of p' is at most that of p.\n\n\t\tIt remains to show the claim in the 2D case. We claim that we must have OPT\u22651/100( min r_h). We proceed similarly to the general case:\n\t\tAssume the contradiction, and let m\u225c1/10( min r_h).\n\t\tThen the optimal path lies in a disk C(p, 1/10m).\n\t\tFor each region R, let q be any point in p\u2229 R. Then Cq, m is contained inside Cp, 1+1/10m.\n\t\tNote that this differs from the general case as we assumed OPT<1/10m instead of\n\t\tOPT<m.\n\n\t\tTherefore, to create a contradiction, it remains to show that\n\t\t\n    (C(q, m)\u2229 R)> 1/3Cp, 1+1/10m=\n    \t\t1/31+1/10^2(C(p, m)),\n\n\t\twhere R is any disk with radius at least 10m and q\u2208 R.\n\n\t\tLet r be the center of R, and a be any point inside C(q,m).\n\t\tAlso let x\u225cr-q, y\u225cq-a, and z\u225cr-a.\n\t\tBy the Law of Cosines,\n\t\tz^2=x^2 + y^2 -2xy cos\u2220rqa.\n\n\t\tSuppose that we have cos\u2220rqa\u22651/20;\n\t\twe claim that this implies z\u2264 10m.\n\t\tNote that from our constraints we have x\u2264 10m and y\u2264 m\u2264 10m,\n\t\tso we have\n\t\t\n    (x-10m)(y-10m)=xy-10mx-10my+100m^2\u2265 0.\n\n\t\tNext, we have\n\t\t\n    z^2\n    \t\t\t\t   \u2264 x^2 + y^2\n    \t\t\t\t  -1/10xy \n       \u2264 x^2 + y^2\n    \t\t\t\t  -1/1010mx+10my-100m^2\n       = x-1/2m^2 + y-1/2 m^2\n    \t\t\t\t  +19/2m^2 \n       \u226410m-1/2m^2 + m-1/2 m^2\n    \t\t\t\t  +19/2m^2 \n       =100m^2.\n\n\t\tTo conclude,\n\t\t\n    (C(q, m)\u2229 R)\u22652arccos1/20/2\u03c0(C(q, m))>\n    \t\t1/3Cq, 1+1/10m,\n\n\t\tas desired.\n\t\n\n\n\n\n\n\nFor the construction, we'll address the case where all the bodies are disks on the 2D plane; the result can trivially be extended to higher dimensions. Let x_i be the x-coordinate of the center of the ith largest disk. We will show that it is possible to have r_i=1/i for all i such that every disk is tangent to the segment connecting (0,0) and (8,0), every disk has center above the x-axis, and no two disks intersect. As \u2211 r_i=\u0398(log n) and OPT\u2264 8, this would give the desired bound.\n\nWe claim that regardless of how x_1,x_2,\u2026,x_i-1 have been selected, there is always a valid choice for x_i such that the ith disk does not intersect with any of the first i-1. Observe that x_i is valid if |x_i-x_j|\u2265\u221a((r_i+r_j)^2-(r_i-r_j)^2)= 2\u221a(r_ir_j) for all j\u2208 [1,i-1], where r_j denotes the radius of the jth disk. The total length of the x-axis rendered invalid by any of the first i-1 disks is at most\n\n    \u2211_j=1^i-14\u221a(r_ir_j)=4/\u221a(i)\u2211_j=1^i-11/\u221a(j)< 8\u221a(i)/\u221a(i)< 8.\n\n\nTherefore, some x\u2208 [0,8] must exist that was not rendered invalid and is thus a valid candidate for x_i.\n\n\n\n\n \u00a7.\u00a7 Balls: omitted proofs\n \n\n\nAs the problem of touring disks be formulated as a convex optimization problem by <ref> and the optimal value is lower bounded, a global optimum is guaranteed. This global optimum must be locally optimal, in the sense that it should not be able to decrease the objective by moving any single p_i. This means that\n\n    \n  * For all p_i satisfying |p_i-c_i|<r_i, the gradient of the objective with respect to p_i must be 0.\n    \n  * For all p_i satisfying |p_i-c_i|=r_i, the gradient of the objective with respect to p_i must be perpendicular to the ith circle.\n\nThe gradient of the objective with respect to p_i is precisely (p_i-p_i-1)+(p_i-p_i+1), where (x)\u225cx/x. Case 1 corresponds to the tour passing straight through the ith disk while case 2 corresponds to reflecting off the ith circle.\n\nConversely, given a locally optimal solution, we can certify its optimality by choosing z_i=(p_i+1-p_i), where z_i is defined in the proof of <ref>.\n\n\n\nThe touring balls problem can be formulated as a convex optimization problem (specifically, a second-order cone problem).\n\n\n\nStated in <cit.>. We restate a possible formulation here:\n\n*Primal.\n\nConstants: c_i \u2208^d, \u2200 i\u2208 [0,n+1]. r_i \u2208^+, \u2200 i\u2208 [0,n+1].\n\nDecision Variables: p_i \u2208^d, \u2200 i\u2208 [0,n+1]. d_i \u2208^+, \u2200 i\u2208 [0,n].\n\nConstraints: p_i-c_i\u2264 r_i, \u2200 i \u2208 [0, n+1]. p_i+1-p_i\u2264 d_i, \u2200 i \u2208 [0, n].\n\nObjective: min\u2211_i=0^nd_i\n\n*Dual.\n\nConstants: Same as primal.\n\nDecision Variables: \n\n    \n  * Associate a variable y_i\u2208^d, \u2200 i\u2208 [0,n+1] and a real w_i\u2208^+, \u2200 i\u2208 [0,n+1] for each constraint of the first type (y_i\u00b7 (p_i-c_i)\u2264 w_i\u00b7 r_i).\n    \n  * Associate a variable z_i\u2208^d, \u2200 i\u2208 [0,n] for each constraint of the second type (z_i\u00b7 (p_i+1-p_i)\u2264 d_i).\n\n\nConstraints: z_i\u2264 1, \u2200 i\u2208 [0,n]. y_i=z_i-z_i-1, \u2200 i\u2208 [0,n+1]. y_i\u2264 w_i, \u2200 i\u2208 [0,n+1]. \n\nObjective: max-\u2211_i=0^n+1w_ir_i-\u2211_i=0^n+1y_i\u00b7 c_i.\n\n"}