{"entry_id": "http://arxiv.org/abs/2303.07310v1", "published": "20230313173246", "title": "Learning Reduced-Order Models for Cardiovascular Simulations with Graph Neural Networks", "authors": ["Luca Pegolotti", "Martin R. Pfaller", "Natalia L. Rubio", "Ke Ding", "Rita Brugarolas Brufau", "Eric Darve", "Alison L. Marsden"], "primary_category": "cs.LG", "categories": ["cs.LG", "cs.CE"], "text": "\n\nNearest-Neighbor Inter-Intra Contrastive Learning from Unlabeled Videos\n    David Fan Deyu Yang Xinyu Li Vimal Bhat Rohith MV Amazon Prime Video \n\n{fandavi, deyu, xxnl, vimalb, kurohith}@amazon.com\n\n\n\n\n\n\n    March 30, 2023\n===================================================================================================================================\n\n\n\n\nReduced-order models based on physics are a popular choice in cardiovascular modeling due to their efficiency, but they may experience reduced accuracy when working with anatomies that contain numerous junctions or pathological conditions.\n\nWe develop one-dimensional reduced-order models that simulate blood flow dynamics using a graph neural network trained on three-dimensional hemodynamic simulation data. Given the initial condition of the system, the network iteratively predicts the pressure and flow rate at the vessel centerline nodes. Our numerical results demonstrate the accuracy and generalizability of our method in physiological geometries comprising a variety of anatomies and boundary conditions. \nOur findings demonstrate that our approach can achieve errors below 2% and 3% for pressure and flow rate, respectively, provided there is adequate training data. As a result, our method exhibits superior performance compared to physics-based one-dimensional models, while maintaining high efficiency at inference time.\n\n\n\n\n\n\n\n\n\n\n\n\u00a7 INTRODUCTION\n\n\nIn the last twenty years, Computational Fluid Dynamics (CFD) has become an essential tool in the study of the cardiovascular system <cit.>. For example, CFD simulations have been used to noninvasively assess the severity of coronary artery aneurysms <cit.>, to propose novel surgical methods for congenital heart disease <cit.>, and to optimize medical devices <cit.>. Full 3D blood flow models, often solved with the finite element method, allow for patient-specific modeling and extraction of detailed quantities such as wall shear stress and velocity fields. \n\nHowever, the implementation of these simulations in clinical practice is still limited due, in part, to their high computational cost. Reduced-order models (ROMs) have been devised to overcome this issue, though their increased efficiency generally comes with a cost of lost accuracy. This paper aims to develop and validate a novel ROM following a data-driven approach based on graph neural networks (GNNs). \n\nThe typical approach to deriving ROMs for cardiovascular simulations is physics-based. These formulations rely on simplifying assumptions that reduce the vessel geometry's complexity, and, consequently, the number of variables necessary to describe the quantities of interest. This physics-based class of ROMs includes popular zero-dimensional and one-dimensional models. \n\nIn zero-dimensional formulations (often called lumped-parameter network models) the cardiovascular system is analogous to an electric circuit in which the pressure drop across portions of the arterial tree and blood flow rate play the role of electric potential difference and currents, respectively. These quantities of interest do not depend on any spatial variable. We refer to <cit.> for examples of uses of such models in cardiovascular simulations, from simple Windkessel models <cit.> to full circulatory networks. \n\nOne-dimensional models are derived by integrating the three-dimensional Navier-Stokes equation over the vessel cross-section to reduce the equations to a single spatial variable <cit.>. Specifically, arterial trees are approximated as compositions of segments representing the centerline of the vessels, and pressure, flow rate, and vessel wall displacement are considered functions of the axial component only. Compared to lumped-parameter network models, one-dimensional models capture more of the physics due to their ability to account for wave propagation phenomena due to the interaction of flow with elastic vessel walls. \n\nOne-dimensional models have proven to be useful in numerous studies; see, for example, <cit.>. \n\nZero- and one-dimensional formulations often lead to reasonably accurate results at a fraction of the computational cost of full three-dimensional simulations. However, these ROMs sometimes perform poorly because (i) they do not account correctly for pressure losses at vascular junctions and (ii) they rely on specific mathematical models (mostly based on empirical data or heuristics), particularly to describe pathological cases (e.g., stenoses or aneurysms). A recent study conducted on 72 cardiovascular models selected from a freely available database of cardiovascular models, the Vascular Model Repository (VMR),[<http://www.vascularmodel.com>] compared zero- and one-dimensional formulations against three-dimensional reference simulations <cit.>. The authors observed average relative errors of 2.1% & 1.8% on the pressure (zero- and one-dimensional models, respectively) and 3.9% & 3.4% on the flow rate (zero- and one-dimensional models, respectively).\n\nData-driven ROMs have the potential to overcome the issues mentioned above. \nTypical data-driven reduced-order approaches include projection-based methods such as reduced-basis or proper-orthogonal decomposition techniques <cit.>. Although these methods can be adapted to specific geometries through interpolation strategies <cit.>, they are often not capable of representing the full range of geometrical variability characterizing patient-specific anatomic models. These problems can be partially overcome by employing projection-based methods in simple subdomains making up the vascular geometry of interest <cit.>.\n\nAnother option for generating data-driven models for physical simulations is deep learning.  While, in the context of cardiovascular modeling, deep learning has been used to accelerate other aspects of the simulation pipeline, for example, image-based segmentation <cit.> and model generation <cit.>, it has not yet been used widely to model physical processes. Among the most popular architectures devoted to this scope are physics-informed neural networks (PINNs) <cit.>, which are neural networks trained to mimic known physical laws. PINNs have been applied, for example, to ocean and climate modeling in <cit.>, in the field of atomistic simulations in <cit.>, to approximate cardiac activation mapping in <cit.> and blood flow dynamics in <cit.> and <cit.>. For an overview of fluid dynamics and machine learning efforts, we refer to <cit.>. As with projection-based methods, these algorithms are typically not flexible with respect to changes in the domain geometry, which is a crucial drawback for their use in cardiovascular simulations on patient-specific applications. \n\nRecently, GNNs have been proposed as an alternative to classic fully connected and convolutional neural networks to address these difficulties. GNNs are used, for example, in <cit.> to learn the laws governing particle interactions in particle-based simulations and in <cit.> as solvers for mesh-based simulations called MeshGraphNets. More recently, GNNs have also been used to estimate steady blood flow in a synthetic dataset of three-dimensional arteries <cit.>.\n\n In this paper, we consider an approach inspired by MeshGraphNets to derive a one-dimensional surrogate ROM for cardiovascular simulations. We apply the GNN to learn the laws governing bulk quantities, such as average pressure and flow rate at the centerline nodes, as opposed to using it to approximate the solution of the three-dimensional blood flow equations (as in the original paper). Owing to its capacity to resolve pressure and flow rate on cardiovascular models' centerlines, we consider our method a data-driven one-dimensional model. The network iteratively considers the state of the system, comprising pressure and flow rate at a particular timestep and other relevant features (such as cross-sectional area and parameters governing the boundary conditions), and computes approximations for the next values of pressure and flow rate. \n \n We adapt the original MeshGraphNet implementation to make it suitable for blood flow simulations. In particular, we include graph edges to efficiently transfer boundary condition information to the interior graph nodes, and we include special parameters as node features to handle Windkessel-type or resistance-type boundary conditions, which are typically encountered in cardiovascular modeling. In our numerical results, we demonstrate the GNN on a diverse set of geometries. We assess its ability to generalize to multiple geometries and compare its performance with physics-based one-dimensional models.\n\nIn summary, the main contributions of this paper are threefold:\n\n    \n  * We consider a modified version of MeshGraphNet capable of handling complex boundary conditions by adding special edges and patient-specific features to the graph. We show that these modifications lead to substantial improvements compared to MeshGraphNet in an ablation study performed in <Ref>. \n    \n  * We assess the ability of the GNN to generalize to different geometries, which, to our knowledge, has not been investigated in previous works. We reiterate that geometrical variability plays an essential role in patient-specific modeling (see  <Ref> and <Ref>).\n    \n  * We demonstrate that our ROM outperforms physics-driven one-dimensional models in geometries characterized by many junctions or pathological conditions (see <Ref>).\n\n\nOur GNN implementation is freely available at <https://github.com/StanfordCBCL/gROM>.\n\n\n\n\u00a7 NOTATION\n\n\n\nLet us consider a set of G patient-specific cardiovascular geometries \u03a9_1, \u2026, \u03a9_G. Given a geometry \u03a9_g, we generate a directed graph consisting of a set of nodes n^g_1, \u2026, n^g_N^g along the vessel centerline; see <Ref> (left). We denote e^g_ij as the directed edge connecting node i to node j. We denote T_cc^g as the period of one cardiac cycle of the patient and consider the discrete time sequence\n\n    t^0,g, t^1,g, \u2026, t^M,g,\n\nsuch that t^0,g = 0, t^M,g= T_cc^g, and \u0394 t^g = t^1,g - t^0,g = \u2026 = t^M,g - t^M-1,g. \n\nIn this paper, we take a constant \u0394 t^g for all patients to simplify the learning process. However, we envision that the generalization to variable time step size is possible with minimal changes to the architecture (for instance, by including \u0394 t^g in the set of node features). \n\nWe call the set of all node and edge features at time t^k,g the state of the system \u0398^k,g(\u03bc), where \u03bc is a vector of system parameters\u2014in this work, these are related to its boundary conditions.  We call a sequence of states \u0398^k,g(\u03bc) for a particular choice of system parameters \u03bc a trajectory. We refer to <Ref> for a description of the features we consider in this work. For brevity, we will implicitly assume that all quantities must be patient-specific and omit the superscript g in the following sections whenever possible.\n\n\n\n\u00a7 MESHGRAPHNETS FOR CARDIOVASCULAR SIMULATIONS\n\n\n\n\nOur GNN acts as a data-driven one-dimensional ROM; for a description of classical physics-based one-dimensional models, we refer to <Ref>. During the rollout phase shown in <Ref> (top-right), the network takes as an input \u0398^k and computes an update that allows us to advance the state of the system from \u0398^k to \u0398^k+1. We apply the GNN iteratively. In each time step t^k with k > 0 we provide it with the previously estimated system state. At t^0, we feed the network a prescribed initial condition. The action of the GNN is described in <Ref>.\n\n\n\n \u00a7.\u00a7 Graph features\n\n\nWe select the node and edge features based on our knowledge of the problem. For example, it is well known that, under a Poiseulle condition, a linear relation exists between flow rate Q and pressure drop \u0394 P across an approximately cylindrical vessel. Specifically,\n\n    \u0394 P = R Q = 8 \u03bc L\u03c0 r^4 Q.\n\nThe proportionality constant R is called resistance and depends on the viscosity of blood \u03bc, the length of the vessel L, and its radius r. In this work, we assume that the viscosity and density of the blood are equal to \u03bc = 0.04 g cm^-1 s^-1 and \u03c1 = 1.06 gr cm^-3 for all patients, respectively, and we do not include viscosity and density as graph features. Based on these notions of fluid dynamics, we include the cross-sectional area in the node features.\n\n\n\n  \nNode features We consider the cross-sectional average pressure p^k_i \u2208\u211d^+ and the flow rate q^k_i \u2208\u211d in every centerline node n_i as descriptors of the state of the system \u0398^k at time t^k. These are computed on the section obtained as the intersection between the plane orthogonal to the centerline and the thee-dimensional model of the vessel. Similarly, the area of the vessel lumen A_i \u2208\u211d is the area of the section passing through node i and is considered a node feature for the above reasons. We introduce a one-hot vector \u03b1_i \u2208\u211d^4 to encode different node types. These are branch nodes, junction nodes, model inlet (one per geometry), and model outlets, as shown in <Ref> (left). The distinction between branch and junction nodes is necessary because the area of sections within junctions varies discontinuously across the centerline (owing to nearby slices sometimes cutting through a different number of branches). This leads to different blood dynamics in branches and junctions when looking at quantities averaged over such sections. We use the same automated algorithm for junction detection as in <cit.>. Additional node features are the tangent to the centerline evaluated at node n_i, which we denote \u03d5_i \u2208\u211d^3, the period of the cardiac cycle T_cc\u2208\u211d^+, minimum and maximum pressure over the whole cardiac cycle (p_min\u2208\u211d^+ and p_max\u2208\u211d^+), three parameters associated with the boundary conditions (R_i,p\u2208\u211d^+, C_i\u2208\u211d^+, and R_i,d\u2208\u211d^+; see <Ref> for further information), and a boolean loading variable l^k \u2208{0,1} associated with model initialization (see <Ref>). We remark that, although in this work p_min and p_max are set based on simulation data, these values are typically known for the patient at hand\u2014for example, they are identified as diastolic and systolic pressure in aorta models\u2014and are often used in physics-based cardiovascular simulations to tune the boundary conditions discussed in <Ref>. In summary, we associate with each node n_i the vector of features \n\n    \ud835\udc2f^k_i = [p_i^k, q_i^k, A_i, \u03b1_i^T, \u03d5_i^T, T_cc, p_min, p_max, R_i,p, C_i, R_i,d, l^k]^T\u2208\u211d^17.\n\n\nNode features and their definitions are summarized in <Ref>.\n\n\n\n\n\n\n  \nEdge features We define \ud835\udc1d_ij = \ud835\udc31_j - \ud835\udc31_i \u2208\u211d^3 as the difference between the position of nodes n_j and n_i, and z_ij the length of the shortest path between the two nodes. In addition to physical edges, in this work we introduce edges connecting boundary nodes to interior ones (see <Ref>). We, therefore, introduce the one-hot vector \u03b2_ij\u2208\u211d^4 to encode the edge type. We define the following edge types: edges connecting branch nodes to branch nodes, edges connecting junction nodes to junction nodes, and edges connecting the model inlet or outlets to interior nodes. For simplicity, edges connecting branch nodes to junction nodes are assigned the same type as those within branches. We note that edges within branches and junctions are those defining the centerline of the anatomical model and that, when computing the shortest path z_ij, we only consider these edges. Moreover, we highlight that although the introduction of boundary edges changes the topology of the graph, information regarding the original topology is maintained through the different edge types. The edge features associated with e_ij are\n\n    \ud835\udc30_ij = [\ud835\udc1d_ij^T / \u2016\ud835\udc1d_ij\u2016_2, z_ij, \u03b2_ij^T]^T\u2208\u211d^8.\n\n\n\n\nEdge features and their definitions are summarized in <Ref>.\n\nNote that all features (except for the unitary vectors \ud835\udc2d_i and \ud835\udc1d_ij^T / \u2016\ud835\udc1d_ij\u2016_2) are normalized to follow a standard Gaussian distribution \ud835\udca9(0,1) using statistics computed on the dataset.\n\n\n\n \u00a7.\u00a7 Extension of MeshGraphNet to support cardiovascular boundary conditions\n\n\n\n\n\nThe hemodynamics in the vasculature are determined by the boundary conditions at the inlet and outlets. In cardiovascular simulations, we represent the downstream vasculature as three-element Windkessel-type (RCR) or resistance-type boundary conditions, as shown in <Ref>. \n\nIn RCR boundary conditions, the pressure in the capacitor P_c(t, Q) is determined by the relationship\n\n    d P_cd t = 1C (Q(t) - P_cR_d ).\n\nThen, the pressure at the outlet (P in <Ref>) is found as P(t, Q) = P_c(t,Q) - R_p Q(t). \n\nIn resistance boundary conditions, the relationship between pressure and flow rate at the outlet is simply P(t) = R Q(t). We remark that this is a special case of RCR boundary conditions where C and R_d tend to zero. \n\nIn both RCR and resistance boundary conditions, we assume that the distal pressure is zero for simplicity.\n\nTo integrate these boundary condition types into the MeshGraphNet framework, we provide the values of R_p, C, and R_d as node features in the outlet nodes. We set those features to zero for all remaining nodes in the graph. When using resistance-only boundary conditions, we also set C = 0 and R_d = 0.\n During training and in every iteration of the rollout phase, we solely prescribe the flow rate value at the next time step at the inlet. \n \n Due to the nature of the centerlines we consider in this paper, most centerline nodes are connected to only two neighbors, which hinders the information transfer between the boundary nodes and the interior ones. For this reason, we add artificial edges connecting each interior node to the closest node on the boundary. Specifically, every interior node n_i is connected to the boundary node n_j for which the shortest path length between n_i and n_j, i.e., z_ij, is minimized. Edges connecting inlets and outlets to interior nodes are associated with different types of edges (see Edge features in <Ref>) and are bidirectional as all the other types of edges that we consider in this paper.  \n\n\n\n\n \u00a7.\u00a7 Initial conditions\n\n\n\nAs we shall see in <Ref>, we train our GNN on time-dependent simulation data over one cardiac cycle. However, the initial condition of the system at the start of the cardiac cycle is in general not a piece of information that can be easily estimated from clinical data. For this reason, when generating the trajectories in the dataset, we start from a constant solution in which p^0 = p_min and q^0 = 0 in all graph nodes and then linearly interpolate between this initial state and the actual initial condition at the start of the cardiac cycle over T_l = 0.1 s. We then include a node feature,  denoted l^k, taking a unitary value between t = -0.1 sec and t = 0 sec, and zero for t > 0, to differentiate between the loading stage and the actual simulation of the cardiac cycle. \n\n\n\n\n \u00a7.\u00a7 Forward step of the Graph Neural Network\n\n\nIn this section, we denote by \ud835\udc1f_* a fully-connected neural network (FCNN) <cit.> with n_h hidden layers. The number of neurons in the hidden layers is constant and equal to n_s. We consider the LeakyReLU activation function for every layer except the output layer, and we apply a layer normalization on the output layer unless explicitly specified. When an FCNN accepts multiple arguments, these should be concatenated into a single tensor.\n\nMeshGraphNet is based on the three main stages shown in <Ref> (bottom-right):\n\n\n  * Encode: we transform the node and edge features into latent features using FCNNs. In particular, given node feature \ud835\udc2f_i^k, we compute its latent representation as \ud835\udc2f_i^k,(0) = \ud835\udc1f_en(\ud835\udc2f_i^k) \u2208\u211d^n_l, where \ud835\udc1f_en is an FCNN mapping the space of node features into \u211d^n_l. Similarly, we compute \ud835\udc30_ij^(0) = \ud835\udc1f_ee(\ud835\udc30_ij) \u2208\u211d^n_l for all edges e_ij. Although the size of the latent space n_l does not need to coincide for edges and nodes, we take it to be the same to facilitate the optimization of our architecture, discussed in <Ref>. \n\n  * Process: the process stage is performed L times and is further divided into two phases. In the first phase, we compute new edge features as\n\n    \ud835\udc30_ij^(l) = \ud835\udc1f_pe^(l)(\ud835\udc30_ij^(l-1), \ud835\udc2f_i^k,(l-1),  \ud835\udc2f_j^k,(l-1))\u2208\u211d^n_l,\n\nwhere l \u2265 1 is the iteration number. Then, we compute new node features using aggregation functions as\n\n    \ud835\udc2f_j^k,(l) = \ud835\udc1f_pn^(l)(\ud835\udc2f_j^k,(l-1),  \u2211_i: \u2203 e_ij\ud835\udc30_ij^(l), \ud835\udc30_in,j, \ud835\udc30_out,j)\u2208\u211d^n_l.\n\nAll the networks considered in this stage feature a residual connection.\n\n  * Decode: in the last stage, node features are transformed from the latent space to the desired output space using an FCNN. The desired output is a vector that contains the update of pressure and flow rate [\u03b4 p_i^k, \u03b4 q_i^k] = \ud835\udc1f_dn(\ud835\udc2f_i^k,(L)) \u2208\u211d^2. Following <cit.>, we do not use layer normalization on the output layer of \ud835\udc1f_dn.\n\nAt the end of the forward pass of the GNN, we update the pressure and flow rate nodal values p_i^k and q_i^k as p_i^k+1 = p_i^k + \u03b4 p_i^k and q_i^k+1 = q_i^k + \u03b4 q_i^k.\n\nWe introduce \u03b4\ud835\udc2f_i^k = [\u03b4 p_i^k, \u03b4 q_i^k, 0,\u2026,0] \u2208\u211d^17 and the function \u03a8_m, which denotes the result of applying the GNN m consecutive times (rollout phase). Specifically,\n\n    \u03a8_1(\u0398^k)     = \u22c3_i = 1^N {\ud835\udc2f_i^k + \u03b4\ud835\udc2f_i^k } \u222a\u22c3_i,j: \u2203 e_ij{\ud835\udc30_ij},\n    and\u03a8_m(\u0398^k)     = (\u03a8_1 \u2218\u22ef\u2218\u03a8_1_m)(\u0398^k).\n\nWe denote the approximation of p and q at node i, after m applications of the GNN, as \u03a8_m(\u0398^k)|_p,i and \u03a8_m(\u0398^k)|_q,i, respectively. \n\n\n\n\n\n \u00a7.\u00a7 Training\n\n\n\n\n\n\n\n\nWe now introduce the loss function \u2112 minimized during training of the GNN. Let us define the training set {\u03a9_g}_g \u2208\ud835\udcaf, where \ud835\udcaf is a subset of [1,\u2026,G]. We train the network on small strides of s consecutive time steps so that it approximates the exact values of the nodal pressure and flow rate p\u0302^k,g_i and q\u0302^k,g_i. Here, we consider s = 5. Considering multiple steps has been proven to be beneficial in <cit.>. In particular, we define the strided MSE\n\n    sMSE^k,g,s = 1N^g\u2211_l = 1^s\u2211_i = 1^N^ga_l b_i  [ ( p\u0302^k+l,g_i - \u03a8_l(\u0398^k,g)|_p,i)^2 + (q\u0302^k+l,g_i - \u03a8_l(\u0398^k,g)|_q,i)^2  ],\n\nwhere a_l = 1 if l = 1 and a_l = 0.5 otherwise, and b_i = 100 for boundary nodes and b_i = 1 otherwise. \n\nThen, the loss function reads\n\n    \u2112 = MSE = \u2211_g \u2208\ud835\udcaf1|\ud835\udcaf|(M^g-s)\u2211_k = 0^M^g-ssMSE^k,g,s.\n\n\n\n\n\n\n\n\n\n\n\n\n\nOur goal is to make the GNN robust for rollouts of many time steps. In order to achieve this, it is imperative to add random noise during training to simulate the effect of the error caused by the network in the rollout phase, as described in <cit.>. During training, we perturb the pressure and flow rate in the state \u0398^k,g as p\u0303_i^g = p\u0302_i^g + \u03b5_p and q\u0303_i^g = q\u0302_i^g + \u03b5_q, where \u03b5_p \u223c N (0,\u03c3^2), \u03b5_q \u223c N(0,\u03c3^2), and \u03c3 is a hyperparameter controlling the noise standard deviation. The loss function\u00a0(<ref>) is optimized using stochastic gradient descent and the Adam optimizer. For details on the GNN and training hyperparameters, we refer to <Ref>.\n\nWe consider each entire trajectory as a datapoint. Due to the limited size of the datasets that we obtain in this way (as opposed to, for example, considering every possible set of s consecutive timestep as separate datapoints), we use k-fold cross-validation\u00a0<cit.>, that is, we train k networks on different train-test splits using the same set of hyperparameters and report their average performance. The train-test splits are made such that 1-1/k and 1/k of the trajectories are assigned to the train and test set, respectively, and such that each trajectory appears in the test set exactly once. Consider as an example the dataset employed in <Ref>, which is composed of 160 trajectories. During 10-fold cross-validation, each of the 10 networks is trained on 144 trajectories and tested on 16, and we report the average performance achieved on train and test.\n\n\n\n \u00a7.\u00a7 Hyperparameter optimization\n\n\nHyperparameter optimization is essential for achieving state-of-the-art performance using machine learning methods. In this work, we employ the optimization platform SigOpt.[<https://sigopt.com>] As our objective function, we employed the average rollout error on pressure and flow rate obtained on the test set after training. More specifically, given the anatomy of patient g, the errors for pressure and flow rate are computed as\n\n    e_p^g    = \u2211_i \u2208\u212c^g\u2211_k = 1^M^g (p\u0302^k,g_i - \u03a8_k(\u0398^0,g)|_p,i)^2\u2211_i \u2208\u212c^g\u2211_k = 1^M^g (p\u0302^k,g_i )^2, \n    e_q^g    = \u2211_i \u2208\u212c^g\u2211_k = 1^M^g (q\u0302^k,g_i - \u03a8_k(\u0398^0,g)|_q,i)^2\u2211_i \u2208\u212c^g\u2211_k = 1^M^g (q\u0302^k,g_i )^2,\n\nwhere p\u0302^k,g_i and q\u0302^k,g_i are the exact pressure and flow rate values at time t^k and at node n_i for patient g. Note that, when computing these errors, we only consider the indices of nodes located in branches, that is, \u212c^g.\n\nOur optimization yielded the following choices of hyperparameters:\n\n\n\n\n  * Network architecture. Each fully-connected network in the GNN consists of n_h = 2 hidden layers and n_s = 64 neurons per hidden layer. The optimal number of processing iterations in the forward step of the GNN is L = 5, and we consider n_l = 16 as the size for the latent space.\n\n\n  * Training hyperparameters. We consider a starting learning rate of 10^-3. This is decreased using a cosine annealing function; the final value of learning rate is 10^-6. We use batches of 100 graphs. During training, we inject normally distributed noise N(0,\u03c3^2) with \u03c3 = 5 \u00b7 10^-2. Unless explicitly stated, we train the GNNs for 100 epochs.\n\n\n\n\n\n\n\u00a7 DATASET\n\n\n\n\n\nWe consider eight healthy and diseased patient-specific models selected from the VMR and shown in <Ref>. Models 1-5 are healthy aorta models, Model 6 is an aortofemoral model featuring an aneurysm, Model 7 is a healthy pulmonary model, and Model 8 is an aorta affected by coarctation. We selected these models as, based on previous studies such as <cit.>, they present features\u2014e.g, many junctions (Model 7) or stenoses (Model 8)\u2014that are typically challenging for traditional physics-based models.\n\nThe data-generation pipeline consists of three main steps: three-dimensional simulation using SimVascular <cit.>, transformation to the one-dimensional representation, and graph generation.\n\n\n\n  \nThree-dimensional simulation. In addition to geometrical information, the VMR also contains simulation data and boundary conditions information tuned to match clinical measurements. The models include a prescribed flow rate profile over one cardiac cycle at the inlet and RCR (Models 1-6 and Model 8) or resistance boundary conditions (Model 7) at the outlets. We performed 32 (Models 1-5) and 50 (Models 6-8) three-dimensional simulations for each of these geometries under random perturbations of the original boundary conditions. In particular, we multiplied the inlet flow rate and each of the parameters governing the outlet boundary conditions by independent factors uniformly distributed in the range [0.8,1.2]. Using the notation introduced in <Ref>, each model in the VMR was associated with a particular parameter set \u03bc = [\u03bc^in,\u03bc^out_1,\u2026,\u03bc^out_N_out] governing its boundary conditions, and we ran simulations for multiple perturbed parameter sets each of the form \u03bc = [c^in\u03bc^in ,c^out_1\u03bc^out_1 ,\u2026,c^out_N_out\u03bc^out_N_out], where c^in,c^out_1,\u2026,c^out_N_out\u223c U(0.8,1.8). We performed the three-dimensional finite-element simulations of the unsteady Navier\u2013Stokes of two cardiac cycles on 128 dual-socket AMD(R) EPYC 7742 cores of the San Diego Super Computing Center (SDSC) Expanse cluster.\n\n In <Ref> we report the average simulation run time for each of the eight considered models.\n\n\n\n\n\n  \nPost-processing of simulation results. We restricted the three-dimensional results to the model centerlines. We achieved this by considering the orthogonal sections of the vascular geometry at each centerline node and integrating the pressure and normal component of the velocity over the cross section, thus computing average pressure and flow rate. We also associated with each centerline node the area of the corresponding section. For clarity, <Ref> (middle) shows a subset of the sections where we integrated the pressure and velocity field.\n\n\n\n  \nGraph generation.  Our GNN implementation is based on PyTorch and the Deep Graph Library (DGL)[<https://www.dgl.ai>]. In this last step of the pipeline, we generated nodes, edges, and relative features, in a format compatible with DGL. As discussed in <Ref> and shown in <Ref> (right), at this stage we added edges connecting boundary nodes to interior ones. The time-dependent pressure and flow rate fields are here resampled at each graph node using cubic splines at a constant \u0394 t. We also performed data augmentation and increase the number of graphs 4-fold by starting each trajectory at a different offset. <Ref> shows statistics computed over the graphs considered in this paper. Each row is indexed based on the ID of the corresponding cardiovascular model (see <Ref> for reference). \n\nThese three steps of the pipeline are summarized in <Ref>.\n\n\n\n\n\n\n\n\u00a7 RESULTS\n\n\n\nIn this section, we present the results obtained on the datasets described in <Ref>. We trained the networks in a distributed fashion over 16 36-core dual-socket Intel(R) Ice Lake Xeon(R) nodes. For inference, we use an Apple M1 Max processor.\n\n\n\n \u00a7.\u00a7 Convergence study with respect to dataset size and sensitivity analysis\n\n\n\n\n\nWe first assessed the performance of the GNN as a function of the dataset size. We used the five healthy models shown in <Ref> (Models 1-5) and extracted the solution from the last cardiac cycle (32 per geometry) to train MeshGraphNet. Considering data augmentation, this resulted in 640 resolved flows in the dataset. We performed 10-fold cross-validation by considering a 90-10% split between train and test sets and avoiding data leaks\u2014that is, the augmented data for each simulation belonged to the same (train or test) set as the original simulation.\n\n<Ref> shows the performance of the network when trained over 10, 20, 40, 80, and 160 trajectories. On the left, we report the train and test loss value decay over the training epochs. As the size of the dataset increases, the gap between train and test validation loss decreases, as does the value of the final loss. On the right, we numerically demonstrate the expected convergence in the pressure and flow rate errors (computed as in <Ref> and <Ref>) with respect to the dataset size. Our results also show that, as we consider more trajectories to train the GNN, the generalization gap between train and test rollout errors decreases and is less variable. The variability in performance is represented in <Ref> (right) by 95% confidence intervals computed over the 10 networks trained during 10-fold cross-validation.\n\n\n\nWe analyzed the sensitivity of MeshGraphNet with respect to each of the node and edge features as follows. We selected one trajectory at random in the dataset and assessed the baseline performance of each of the 10 GNNs trained over the whole dataset in terms of pressure and flow rate rollout errors. Then, we performed many rollouts using the same GNNs while applying random Gaussian noise N(0, 0.05) to only one feature per rollout in each node and edge in each timestep (in the case of multidimensional node features such as tangent and node type, we divide the standard deviation by the size of the vector). We recall that node and edge features are standard normalized, which motivates the use of the same noise distribution for all features. We define the sensitivity factor with respect to a particular feature as the ratio between the error obtained in the perturbed configuration and the baseline error. Therefore, sensitivity close to one indicates robustness with respect to noise. Features associated with higher values of sensitivity are more important to the result accuracy than those associated with lower values. Our findings are summarized in <Ref>. \n\nThe accuracy in the global approximation of pressure and flow rate did not depend dramatically on the previous timestep. As a matter of fact, we train our GNNs specifically to be robust to noise in pressure and flow rate, as discussed in <Ref>. The networks were most sensitive to variations in the cross-sectional area (which is consistent with our understanding of fluid dynamics) and patient-specific data such as boundary conditions parameters and reference values for pressure (p_min and p_max). Unexpectedly, the cardiac cycle period T_cc also played an important role; we believe that this is due to the low number of distinct T_cc considered here (five, i.e., one per geometry) and that increasing the variability of that parameter in the dataset will also reduce its effect. Geometrical features such as tangent or node distance did not significantly affect the accuracy of the results. This might be partially due to the fact that those features are not independent of each other\u2014for instance, the tangent value can be estimated starting from the node positions and vice versa. Finally, we observe that the loading variable l^k, which we introduced to distinguish between the loading phase and cardiac cycle simulation, did not play an important role in the rollout accuracy.\n\n\n\n \u00a7.\u00a7 Comparison against physics-based one-dimensional models\n\n\n\nTo assess the performance of our method against a physics-based ROM, we considered Models 6, 7, and 8 (see <Ref>), which present characteristics that are typically difficult to handle using one-dimensional models. For each geometry, we simulated two cardiac cycles using 50 random configurations of the boundary conditions associated with that cardiovascular model in the VMR.\n\nWe also performed one-dimensional simulations using the same boundary conditions used in the three-dimensional ones. We set the material properties of the arterial wall to obtain close-to-zero variations in the lumen area, following the approach adopted in <cit.>. We refer to <Ref> for more details about our implementation of one-dimensional models. We initialized the ROM with the pressure and flow rate approximations by the three-dimensional model evaluated at the one-dimensional nodes and ran it for two cardiac cycles. In our experience, this configuration leads to better agreement with the three-dimensional data (instead of initializing the ROM using constant values for pressure and flow rate or performing the simulation for more cardiac cycles).\n\nSimilarly to <Ref>, we used 4-fold data augmentation for training and, therefore, each anatomical model was associated with a training dataset of 200 trajectories. We considered two approaches for training. In the first approach, we considered a global dataset with trajectories computed on all three cardiovascular models. We denoted the networks trained this way GNN-A. The second strategy consists of training three distinct GNNs over datasets comprising trajectories from the same anatomical models. In other words, we trained one GNN on all trajectories associated with Model 6, one on all trajectories associated with Model 7, and one on all trajectories associated with Model 8. As these networks are trained on a single geometry, we denote them GNN-Bg, where g=6, g=7 or g=8 is the patient identifier.  <Ref>, which reports statistics on the models considered in this section, motivates the choice of training geometry-specific networks. Indeed, different vascular regions are characterized by different ranges for key quantities such as pressure, flow rate, and cross-sectional area. Since the GNN operates on data normalized using statistics computed over all graphs in the dataset, we aim to investigate whether normalizing the data with values adapted to each cardiovascular region presents advantages in terms of accuracy. We perform 5-fold cross-validation for GNN-A and GNN-Bg. Due to the different dataset sizes, we train GNN-A networks for 100 epochs and GNN-Bg ones for 500.\n\n\n\n<Ref> shows the performance of GNN-A, GNN-B6 (left column), GNN-B7 (middle column), and GNN-B8 (right column), over trajectories contained in the test sets. We evaluate the error in pressure at 20 graph nodes sampled at random in the models' branches and display the pressure and flow rate evolution at the locations where the error in pressure achieved by GNN-A is minimum (top row), median (middle row), and maximum (bottom row). The GNNs are remarkably accurate in all considered locations. <Ref> also shows the performance of one-dimensional models ran with \u0394 t = 10^-2 s (same time step as GNN-A and GNN-Bg). The data- and physics-driven models both performed well on the aortofemoral model (left column), but the GNNs outperformed the one-dimensional ROM on the pulmonary and aorta coarctation models (middle and right columns).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<Ref> compares the accuracy of the GNN-A and one-dimensional models over the whole dataset; since GNN-A and GNN-Bg performed comparatively well, we here focus on the more general GNN-A for simplicity. In all cases \u0394 t = 10^-2 s. We plot the pressure (top row) and flow rate (bottom row) approximations by the GNNs and one-dimensional models against the ground truth at locations randomly sampled in space and in time in all the models in the dataset. Points positioned on the bisector indicate good agreement between ROM approximation and ground truth. Once again, these results demonstrate that the GNN achieves a much higher accuracy than the physics-based one-dimensional models.\n\n\n\n\nIn <Ref>, we report the average performance of the GNNs and one-dimensional models over all 150 trajectories. Owing to 5-fold cross-validation and the fact that each trajectory appears in the test set exactly once, the GNN results are averaged over all trajectories in the dataset. We observe that the accuracy of GNN-A and GNN-Bg are comparable, which suggests that a single GNN can generalize to multiple geometries. We also note that using \u0394 t = 2 \u00b7 10^-2\u00a0s instead of \u0394 t = 10^-1\u00a0s when training GNN-A leads to lower accuracy. However, we highlight that different time-step sizes might require a different set of hyperparameters\u2014most notably, the standard deviation of the noise we use to make the network robust during rollout. In our case, the hyperparameter optimization discussed in <Ref> is performed considering \u0394 t = 10^-2 s. \n\nThe relative errors for pressure and flow rate produced by the GNNs in each anatomical model are considerably lower than those produced by the one-dimensional ROMs. Moreover, we do not observe a strong effect of \u0394 t on the global accuracy of one-dimensional models. This indicates that the poor performance achieved on Models 7 and 8 was due to limitations intrinsic to the methods. \n\nThe GNNs showed similar efficiency than the one-dimensional models in terms of run time using the same time step size \u0394 t in the Model 6 and lower efficiency in Model 8. In the case of the more complex pulmonary model (Model 7), the GNNs are orders of magnitude more efficient than the one-dimensional models: for example, for \u0394 t = 0.01 s the one-dimensional models took 60.6 seconds to complete a single cardiac cycle, whereas GNN-A and GNN-Bg took around 4.0 seconds. \n\nWe observe that, when using a larger \u0394 t to train GNN-A, the run time decreased accordingly: the run times for Models 6, 7, and 8 scales from 3.1, 4.0, and 2.9 (approximately the same for GNN-A and GNN-Bg) to 1.6, 2.0, and 1.5, respectively. The run times in the one-dimensional models do not scale linearly due to the larger number of Newton iterations necessary to reach convergence in the solution of the nonlinear system with larger \u0394 t. \n\n\n\nFinally, we performed an ablation study to evaluate the effects of different GNN components by excluding them altogether. Our goal was to determine whether the main modifications to MeshGraphNet proposed in this paper improve the accuracy of the original algorithm. These modifications are: (i) all graph features listed in <Ref> and <Ref>, except for p_i^k, q_i^k, \u03b1_i, \ud835\udc1d^T_ij/\u2016\ud835\udc1d^T_ij\u2016, and z_ij, and (ii) the boundary edges discussed in <Ref>. For the sake of clarity, we define the set\n\n    \u03c4 = {A_i, \u03d5_i, T_cc, p_min, p_max, R_i,p, C_i, R_i,d, l^k, \u03b2_ij, for all i,j,k},\n\nwhich includes all node and edge graph features we propose to incorporate in MeshGraphNet, for all nodes, edges, and timesteps.\nWe trained one GNN-A by excluding \u03c4 and another one by excluding boundary edges using the same hyperparameters discussed in <Ref>, performed 5-fold cross-validation, and compared their performance against a baseline GNN-A. <Ref> shows the results averaged over all networks and divided into Models 6, 7, and 8. We observed the biggest performance decline when excluding the boundary edges. This suggests that, in our application, MeshGraphNet cannot be used as is without including those edges to allow information to flow more quickly in the graph. Excluding all the graph features we introduced in this paper also resulted in a noticeable performance drop, particularly in the diseased models (Models 6 and 8). These results demonstrate that our modifications to MeshGraphNet lead to noticeable improvements in the ROM.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u00a7 CONCLUSIONS\n\n\nWe presented a reduced-order model to simulate blood dynamics in one-dimensional approximations of patient-specific vasculatures. Our architecture is a modified version of MeshGraphNet adapted to suit cardiovascular simulations. We demonstrated the generalizability of the network on a variety of different geometries and topologies. We showed the convergence of rollout error on train and test datasets as the number of trajectories used for training increased. We performed a sensitivity analysis to determine which node and edge features are more important to correctly approximating pressure and flow rate. In our experiments, the most influential features were nodal cross-sectional area and patient-specific quantities such as parameters governing the boundary conditions. In <Ref>, we carried out a direct comparison with physics-driven one-dimensional models, showing superior performance of the graph neural network, in particular when handling complex geometries such as those with many junctions (Model 7) or stenosis (Model 8). Specifically, our networks consistently achieved errors below 2% and 3% in pressure and flow rate, respectively. We also considered different approaches to train our algorithm: training networks specific to different cardiovascular regions instead of a single network able to handle different geometries. Our results show that low errors can be obtained by following the latter strategy, which indicates that, with sufficient training data, our algorithm will adequately mimic three-dimensional simulations in all regions of the cardiovascular tree. Motivated by our sensitivity study, we performed an ablation study to determine which of our contributions played a more critical role in the accuracy of the network when excluding them altogether. Our results indicate that introducing boundary edges is essential to ensure meaningful results and that using patient-specific graph features also leads to performance improvements with respect to the original MeshGraphNet architecture.\n\nFuture work will focus on further quantifying and improving the graph neural network's ability to generalize to unseen geometries during training. We will pursue methods that enable the graph neural network to robustly achieve the accuracies and efficiencies demonstrated in this work using smaller training datasets. This could be done by modifying the structure of the graph neural network (e.g., by incorporating notions of physics like conservation of mass) or the composition of the training dataset to include more patient-specific geometries with fewer trajectories each.\n\nAnother open direction of research (motivated by our sensitivity analysis in <Ref>) consists of investigating whether introducing new features or removing some of the existing ones will improve the performance of the method. Removing the parameters associated with the boundary conditions\u2014while keeping the patient-specific data that is normally used to determine them\u2014would be a significant advantage over existing approaches. Indeed, boundary condition tuning is a critical step in current physics-based simulations and is typically performed by varying the boundary condition parameters of surrogate models (for example, zero- or one-dimensional reduced-order models) in Bayesian optimization frameworks that usually require many model evaluations to converge. These optimization procedures are based on objective functions that measure how closely the surrogate model reproduces key physiological quantities such as systolic and diastolic pressures. Incorporating these physiological measures into the neural networks would allow us to bypass the boundary condition tuning stage and reduce the number of steps between medical image acquisition and simulation result assessment. The results presented in <Ref> give us confidence that further tuning of the model and improvements in the training dataset will allow us to obtain accurate approximation results without providing boundary condition parameters to the networks.\n\n\n\n\u00a7 ACKNOWLEDGMENTS\n\n\nThis work was supported by NIH Grants R01LM013120, R01EB029362, and K99HL161313.  Additional funding was provided by the Stanford Graduate Fellowship and an NSF GRFP. This publication was additionally supported by the Stanford Maternal and Child Health Research Institute. The authors gratefully acknowledge the San Diego Super Computing Center (SDSC) and Intel for providing the computational resources to run the three-dimensional simulations and to train the GNNs presented in this paper. The authors also thank Dr. Tailin Wu for the insightful discussions and support on GNNs implementation and calibration.\n\nunsrtnat\n\n\n\n\n\u00a7 DETAILS ON ONE-DIMENSIONAL MODELS\n\n\nOne-dimensional models approximate pressure, flow rate, and wall displacement along the centerline of compliant blood vessels. Given a curve in three-dimensional space parametrized by axial variable z, we define  p=p(z,t), q=q(z,t) and A=A(z,t) are pressure and flow rate of blood and the area of the vessel lumen at z, respectively. Under the assumption of Poiseuille flow, the blood dynamics equations read\n\n    \u2202 A\u2202 t + \u2202 q\u2202 z   = 0,\n    \u2202 q\u2202 t + \u2202\u2202 z (43q^2A )    = -8\u03c0\u03bdqA + \u03bd\u2202^2 q\u2202 z^2 - A\u03c1\u2202 p\u2202 z,\n\nwhere \u03bd is the kinematic viscosity of blood, which is typically set to \u03bd = 3.77 \u00b7 10^-2 s cm^-2. To accurately predict the vessel response to blood flow, it is necessary to supplement <Ref> with a constitutive model. The Olufsen model\n\n    p(z,t) = p_0(z) + 43 (k_1 e^k_2 r_0(z) + k_3 ) (1 - \u221a(A_0(z)A(z,t)) )\n\nis an example of commonly used constitutive law based on a reduced form of linear elasticity <cit.>. Here, p_0(z), r_0(z), A_0(z) are reference values for pressure, radius, and lumen area, and k_1, k_2, and k_3 are empirical constants. Since the three-dimensional simulations we use as benchmark are obtained under rigid-wall assumptions, in the tests presented in <Ref> we set k_1 = 0 and k_3 to an arbitrarily large value, to obtain the same kind of wall response in the one-dimensional models. This approach was also followed in <cit.>, where one-dimensional models were compared with three-dimensional simulations on 72 diverse cardiovascular geometries.\n\nWhile <Ref> models behavior in branches, we need to add conditions to model the dynamics in junctions. Typical conditions include flow rate conservation\u2014i.e., the sum of incoming inflow must equal the sum of outgoing outflow\u2014and zero pressure drop between junction inlets and outlets.\n\nOur results are obtained using an open-source C++ code publicly available at <https://github.com/SimVascular/svOneDSolver>. \n\n\n\n\u00a7 CARDIOVASCULAR MODELS REFERENCE IDENTIFIERS\n\n\nThe cardiovascular models used in this study are associated with the following identifiers in the VMR: 1 = 0090_0001, 2 = 0091_0001, 3 = 0093_0001, 4 = 0094_0001, 5 = 0095_0001, 6 = 0140_2001, 7 = 0080_0001, 8 = 0104_0001.\n\n\n\n\u00a7 REMOVAL OF BOUNDARY CONDITIONS PARAMETERS FROM GRAPH FEATURES\n\n\n\n\n\nSimilar to the ablation study performed in <Ref>, we aimed to investigate the effects of removing a feature from the graph and evaluating the effects on the GNN performance. In particular, we focused on RCR values for boundary conditions. This choice is motivated by the fact that, in the standard simulation pipeline, RCR parameters are estimated starting from physiological measurements in an optimization process that requires numerous model evaluations. Due to the flexibility provided by data-driven approaches that allows the easy incorporation of physiological features during inference (in our case, for example, we include  p_min and p_max among the graph node features, which are often used to estimate boundary values parameters), we foresee that, in the future, it will be possible to omit the boundary condition tuning step in the simulation pipeline. To motivate this hypothesis, we trained a GNN-A by removing RCR values from the node graph features. We report the performance obtained on the same three models considered in <Ref> in <Ref>. Similar to the results presented in <Ref>, these results are averages obtained during 5-fold cross-validation. Although the addition of RCR values to the graph led to increased accuracy in some cases (particularly in the flow rate approximation), the difference with respect to the baseline GNN-A was negligible, which supports our initial hypothesis. Future work will focus on corroborating our hypothesis further and on analyzing the dependencies among graph features to decrease their number while preserving accuracy.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}