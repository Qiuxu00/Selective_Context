{"entry_id": "http://arxiv.org/abs/2303.06676v1", "published": "20230312143353", "title": "Local Search For SMT On Linear and Multilinear Real Arithmetic", "authors": ["Bohan Li", "Shaowei Cai"], "primary_category": "cs.LO", "categories": ["cs.LO"], "text": "\n\n\n\n\n\n\n\n\n\nBohan Li and Shaowei Cai\n\n\n\nState Key Laboratory of Computer Science\n\nInstitute of Software, Chinese Academy of Sciences, Beijing, China\n\n{libh,caisw}@ios.ac.cn\nSchool of Computer Science and Technology \n\nUniversity of Chinese Academy of Sciences, Beijing, China\n\n\n\nLocal Search For SMT On Linear and Multilinear Real Arithmetic\n     Bohan Li1,2 Shaowei Cai1,2Corresponding author \n    March 30, 2023\n==============================================================\n\n\n\n\nSatisfiability Modulo Theories (SMT) has significant application in various domains. In this paper, we focus on  Satisfiablity Modulo Real Arithmetic, referred to as SMT(RA), including both linear and non-linear real arithmetic theories. As for non-linear real arithmetic theory, we focus on one of its important fragment where the atomic constraints are multilinear. We proposed the first local search algorithm for SMT(RA), called LS-RA, based on two novel ideas. First, an interval-based operator is proposed to cooperate with the traditional local search operator by considering the interval information. Moreover, we propose a tie-breaking mechanism to further evaluate the operations when the operations are indistinguishable according to the score function. Experiments are conducted to evaluate LS-RA on benchmarks from SMT-LIB. The results show that LS-RA is competitive with the state-of-the-art SMT solvers, and performs particularly well on multilinear instances.\n\n\n\n\n\n\n\n\n\n\u00a7 INTRODUCTION\n\nThe Satisfiability Modulo Theories (SMT) is the  problem of checking the satisfiability of a first order logic formula with respect to certain background theories.\nIt has been applied in various areas, including program verification and termination analysis\u00a0<cit.>, symbolic execution\u00a0<cit.> and test-case generation\u00a0<cit.>, etc.\n\nIn this paper, we focus on the theory of real arithmetic, consisting of  atomic constraints in the form of polynomial equalities or inequalities over real variables.\nThe theory can be divided into two categories, namely linear real arithmetic (LRA) and non-linear real arithmetic (NRA), based on whether the arithmetic atomic constraints are linear or not.\nAs for NRA, this paper concerns one of its important fragment where the atomic constraints are multilinear.\nThe SMT problem with the background theory of LRA and NRA is to determine the satisfiability of the Boolean combination of respective atomic constraints, referred to as SMT(LRA) and SMT(NRA).\nIn general, we refer to the SMT problem on the theory of real arithmetic as SMT(RA).\n\n\n\nThe mainstream approach for solving SMT(RA) is the lazy approach\u00a0<cit.>, also known as DPLL(T)\u00a0<cit.>, which relies on the interaction of a SAT solver with a theory solver.\nMost state-of-the-art SMT solvers supporting the theory on real arithmetic are mainly based on the lazy approach, including Z3\u00a0<cit.>, Yices2\u00a0<cit.>, SMT-RAT\u00a0<cit.>, CVC5\u00a0<cit.>, OpenSMT\u00a0<cit.> and MathSAT5\u00a0<cit.>.\nIn the DPLL(T) framework, the SMT formula is abstracted into a Boolean formula by replacing arithmetic atomic constraints with fresh Boolean variables. A SAT solver is employed to reason about the Boolean structure, while a theory solver is invoked to receive the set of theory constraints determined by the SAT solver, and solve the conjunction of these theory constraints, including consistency checking of the assignments and theory-based deduction.\n\n\nThe efforts in the lazy approach are mainly devoted to designing effective decision procedures, serving as theory solvers to deal with the conjunction of theory constraints.\nThe core reasoning module for LRA  integrated in DPLL(T) is a variant of simplex algorithm dedicated for SMT solving, proposed in\u00a0<cit.>.\nAnother approach for solving LRA constraint systems is the Fourier-Motzkin variable elimination\u00a0<cit.>, which often shows worse performance than the simplex algorithm.\n\nAs for non-linear real arithmetic, the cylindrical algebraic decomposition (CAD)\u00a0<cit.> is the most widely used decision procedure, and CAD is adapted and embedded as theory solver in the SMT-RAT solver\u00a0<cit.> with improvement since\u00a0<cit.>.\nMoreover, an elegant variation of CAD method is instantiated in the model-constructing satisfiability calculus framework of Z3\u00a0<cit.>.\nOther well-known methods use Gr\u00f6bner bases\u00a0<cit.> or the realization of sign conditions\u00a0<cit.>.\nIncomplete methods include a theory solver\u00a0<cit.>  based on virtual substitution\u00a0<cit.>, and techniques based on interval constraint propagation\u00a0<cit.> proposed in\u00a0<cit.>.\n\n\n\n\nDespite the fact that local search has been successfully employed to solve SAT\u00a0<cit.> and recently to SMT on integer arithmetic\u00a0<cit.>, we are not aware of any local search algorithm for SMT on real arithmetic.\nIn this paper, for the first time, we design a local search algorithm for SMT(RA), namely LS-RA,  based on the following novel strategies.\n\nFirst, we propose the  interval-based operator to enhance the conventional local search operator by taking interval information into account.\nSpecifically, we observe that assigning the real-value variable to any value in a given interval  would make the same amount of currently falsified clauses become satisfied. \nHence, the interval-based operator evaluates multiple values inside the interval as the potential value of the operation, rather than only assign it to a fixed value (e.g. the threshold value to satisfy a constraint).\nMoreover, \nwe observe that there frequently exist multiple  operations with the same best score when performing local search, and thus a tie-breaking mechanism is proposed to further distinguish these operations.\n\n\n\nExperiments are conducted to evaluate LS-RA on 2 benchmarks, namely SMT(LRA) and SMT(NRA) benchmarks from SMT-LIB.\nNote that unsatisfiable instances are excluded, and we only consider multilinear instances from SMT(NRA) benchmark.\nWe compare LS-RA with the top 4 SMT solvers according to the SMT-COMP 2022[https://smt-comp.github.io/2022/], excluding the portfolio and derived solvers.\nSpecifically, as for SMT(LRA), we compare LS-RA with OpenSMT, Yices2, CVC5 and Z3, while for SMT(NRA), the competitors are  Z3, CVC5, Yices2 and SMT-RAT.\nExperimental results show that LS-RA is competitive and complementary with state-of-the-art SMT solvers, especially on multilinear instances.\nMoreover, the Ablation experiment confirms the effectiveness of our proposed novel strategies.\n\nNote that multilinear instances are comparatively difficult to solve by existing solvers. For example, Z3, perhaps the best solver for satisfiable SMT(NRA) instances, can solve 90.5% QF(NRA) instances, while it can only solve 77.5% multilinear instances from SMTLIB. \nHowever, multilinear instances are suitable for local search, since without high order terms, the operation can be  easily calculated.\n\n\n\n\nIn section <ref>, preliminary knowledge is introduced.\n\nIn section <ref>, we propose a novel interval-based operator to enrich the traditional operator by considering the interval information.\nIn section <ref>, a tie-breaking mechanism is proposed to distinguish multiple operations with the same best score.\nBased on the two novel strategies, our local search for SMT(RA) is proposed in section <ref>.\nExperimental results are presented in section <ref>.\nConclusion and future work are given in section <ref>.\n\n\n\n\n\u00a7 PRELIMINARY\n\n\n\n\n\n \u00a7.\u00a7 Basic Definitions\n\nA monomial is an expression of the form x_1^e_1...x_m^e_m where m>0, x_i are variables and e_i are exponents,\ne_i>0 for all i\u2208{1...m}, and x_i\u2260x_j for all i,j\u2208{1...m},i\u2260j.\nA monomial is linear if m=1 and e_1=1.\n\nA polynomial is a linear combination of monomials, that is, an arithmetic expression of the form \u2211_i a_i m_i where a_i are coefficients and m_i are monomials.\nIf all its monomials are linear in a polynomial, indicating that the polynomial can be written as \u2211_i a_ix_i, then it is linear, and otherwise it is non-linear.\nA special case of non-linear polynomial is multilinear polynomial, where the highest exponent for all variables is 1, indicating that each monomial is in the form of x_1...x_m. \n\n\n    The atomic constraints of the theory of real arithmetic are polynomial inequalities and equalities, in the form of \u2211_i a_i m_i\u22c8 k, where \u22c8\u2208{=,\u2264,<,\u2265,>}, m_i are monomials consisting of real-valued variables, k and a_i are rational constants.\n\n\nThe formulas of the SMT problem on the theory of real arithmetic, denoted as SMT(RA), are Boolean combination of atomic constraints and propositional variables, where the set of real-valued variables and propositional variables are denoted as X and P.\nThe SMT problem on the theory of linear real arithmetic (LRA) and non-linear arithmetic (NRA) are denoted as SMT(LRA) and SMT(NRA), respectively.\nAs for NRA, this paper concerns one important fragment where the polynomials in atomic constraints are multilinear, denoted as MRA in this paper.\n\n\n\nLet X={x_1,x_2,x_3,x_4,x_5} and P={p_1,p_2} denote the sets of integer-valued and propositional variables respectively.\nA typical SMT(LRA) formula F_LRA and SMT(MRA) formula F_MRA are shown as follows:\n\nF_LRA: (p_1\u2228 (x_1+2x_2\u22642)  )\u2227(p_2\u2228 (3x_3+4x_4=2)\u2228(-x_2-x_3< 3) )\n\nF_MRA: (p_1\u2228 (x_1 x_2\u22642)  )\u2227(p_2\u2228 (3x_3x_4+4x_4=2)\u2228(-x_2-x_3< 3) )\n\n\nIn the theory of real arithmetic, a positive, infinitesimal real number is denoted as \u03b4.\n\nA literal is an atomic constraint or a propositional variable, or their negation.\nA clause is the disjunction of a set of literals, and a formula in conjunctive normal form (CNF) is the conjunction of a set of clauses.\nFor an SMT(RA) formula F, an assignment \u03b1 is a  mapping X\u2192 R and P\u2192{false,true}, and \u03b1(x) denotes the value of a variable x under \u03b1. \nA complete assignment is a mapping which assigns to each variable a value.\nA literal is true if it evaluates to true under the given assignment, and false otherwise.\nA clause is satisfied if it has at least one true literal, and falsified if all literals in the clause are false.\nA complete assignment is a solution to an SMT(RA) formula iff it satisfies all the clauses.\n\n\n\n \u00a7.\u00a7 Local Search\n\n\nWhen local search is performed on the SMT problem, the search space is comprised of all complete assignments, each of which represents a candidate solution.\nTypically, a local search algorithm begins with a complete assignment and repeatedly updates it by modifying the value of variables in order to find a solution.\n\nGiven a formula F, the cost of an assignment \u03b1, denoted as cost(\u03b1), is the number of falsified clauses under \u03b1. In dynamic local search algorithms which use clause weighting techniques\u00a0<cit.>, cost(\u03b1) denotes the total weight of all falsified clauses under an assignment \u03b1.\n\nA  key component of a local search algorithm is the operator, defining how to modify the current solution.\nWhen an operator is instantiated by specifying the variable to operate and the value to assign, an operation is obtained.\nThe operation to assign variable x to value v is denoted as op(x,v).\nAn operator for SMT on linear integer arithmetic proposed in\u00a0<cit.> is defined as follow.\n\n\n\n\nThe critical move operator, denoted as  cm(x,\u2113), assigns an integer variable x to the threshold value  making literal \u2113 true, where \u2113 is a falsified literal containing x.\n\n\nLocal search algorithms usually choose an operation among candidate operations according to some scoring functions.\n\nGiven a formula and an assignment \u03b1, the most commonly used scoring function of an operation op is defined as \n    score(op)=cost(\u03b1')-cost(\u03b1)\n where \u03b1' is the resulting assignment by applying op to \u03b1.\nAn operation op is said to be decreasing if score(op)>0.\n\nAnother property to evaluate the operation is the make value.\n\n\nGiven an operation op, the make value of op, denoted as make(op), is the number of falsified clauses that would become satisfied after performing op.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u00a7 INTERVAL-BASED OPERATION\n\n\n\n\n\n\n\nCritical move  satisfies falsified clauses by modifying one variable in a false literal to make it true.\nThis operator can still be used in the context of SMT(RA), and it is also used in our algorithm. \nHowever, an issue of accuracy arises when applying the critical move operator in the context of Real Arithmetic. Recalling that we need to calculate the threshold value for a literal to become true, when solving a strict inequality, there is no threshold value. Instead, the value depends on what accuracy we intend to maintain. In this section, we propose an operator for SMT(RA), which considers the interval information and is more flexible than critical move.\n\n\n\n\n \u00a7.\u00a7 Satisfying Domain\n\nAn important fact on linear or multilinear inequality of real-value variables is that, when all variables but one in the inequality  are fixed, there is a domain for the remaining variable, such that assigning the variable to any value in the domain makes the inequality hold.\nThus, given a falsified literal \u2113 in the form of an atomic constraint and a variable x in it, it can be satisfied by assigning x to any value in the corresponding domain, called Satisfying Domain.\n\nFor example, consider a literal \u2113: (x-y> 4) where the current assignment is \u03b1={x=0, y=0}, then obviously assigning x to any value in   (4,+\u221e) satisfies the inequality, and thus the Satisfying Domain is (4,+\u221e).\n\n\nWe further extend the definition of Satisfying Domain to the clause level, defined as follows.\n\n\nGiven an assignment \u03b1, for a false literal \u2113 and a variable x appearing in \u2113, x's satisfying domain to literal \u2113 is SD_l(x,\u2113)={v|\u2113 becomes true if assigning x to v};\nfor a falsified clause c and a variable x in c,  x's  satisfying domain to clause c is SD_c(x,c)=\u22c3_\u2113\u2208 cSD_l(x,\u2113).\n\n\n\nSD_c(x,c) may contain (-\u221e,u] whose upper bound is defined as UB(x,c)=u, or [l,\u221e) whose lower bound is defined as LB(x,c)=l, or both kinds of intervals.\n For simplicity,  interval (-\u221e,u') or (l',\u221e) are denoted as (-\u221e,u'-\u03b4] or [l'+\u03b4,\u221e) respectively.\n\n\n\n    Given a clause c=\u2113_1\u2228\u2113_2\u2228\u2113_3=(a-b>4) \u2228 (2a-b \u2265 7) \u2228 (2a-c \u2264-5) and the current assignment is \u03b1={a=0,b=0,c=0}, for variable a, the satisfying domains to the three literals are SD_l(a,\u2113_1)=[4+\u03b4,\u221e), SD_l(a,\u2113_2)=[3.5,\u221e) and SD_l(a,\u2113_3)=(-\u221e,-2.5] respectively. The Satisfying Domain to clause c is SD_c(a,c)=(-\u221e,-2.5]\u222a[3.5,\u221e), and the corresponding upper bound and lower bound are UB(a,c)=-2.5 and LB(a,c)=3.5 respectively.\n\n\n\n\n \u00a7.\u00a7 Equi-make Intervals\n\n\n\n\nBased on the variables' satisfying domain to clauses, we observe that operations assigning the variable to any value in a given interval would satisfy the same amount of falsified clauses, that is, they have the same make value. \nThis leads to a concept  called equi-make interval.\n\n\nGiven an SMT(RA) formula F and an assignment \u03b1 to its variables, for a variable x, an  equi-make interval is a maximal interval I such that all operations op(x,v) with v\u2208 I  have the same make value.\n\n\n\n\nWe can divide (-\u221e, +\u221e) into several equi-make intervals w.r.t. a variable. \n\n\nConsider a formula F: c_1\u2227 c_2 where both clauses are falsified under the current assignment, and  variable a appears in both clauses.\nSuppose SD_c(a,c_1)=[3,+\u221e) and SD_c(a,c_2)=[5,+\u221e), then we can divide (-\u221e,+\u221e) into three intervals as (-\u221e, 3), [3,5) and [5,+\u221e). Operations assigning a to any value in (-\u221e, 3) results in a make value of 0, those assigning a to a value in [3,5) results in a make value of 1, while those corresponding to [5,\u221e) results in a make value of 2.\n\n\n\nThus, we can enrich the traditional critical move operator by considering the interval information.\nThe intuition is to find the equi-make intervals, and then consider multiple values in such interval as the options for future value of operations, rather than only consider the threshold value.\n\n\n\n\n\n\n\nWe focus on the variables appearing in at least one falsified clause.\nHere we describe a procedure to  partition (-\u221e,+\u221e) into equi-make intervals for such variables.\n\n\n    \n  * First, we go through the falsified clauses. For each  falsified clause c, we calculate for each real-valued variable x in c  the corresponding satisfying domain to c, SD_c(x,c), as well as the upper bound UB(x,c) and lower bound LB(x,c) if they exist.\n    \n  * Then, for each real-valued variable x appearing in falsified clauses, all its UBs  are sorted in the ascending order, while LBs  sorted in the descending order.\n    After sorting, these bounds are labeled as UB^1(x),\u2026 UB^n(x) and LB^1(x),\u2026 LB^m(x), where UB^n(x) and LB^m(x) denotes the maximum of UB and minimum of LB for x respectively [Note that UB^n(x)<LB^m(x), since otherwise the current assignment is either in the interval [LB^m(x),\u221e) or  (-\u221e,UB^n(x)], and at least one falsified clause is satisfied, which causes conflicts.].\nFor convenience in description, we denote UB^0(x)=-\u221e and LB^0(x)=\u221e.\nThese bounds are listed in order: UB^0(x)<UB^1(x)<\u2026<UB^n(x)<LB^m(x)<\u2026<LB^1(x)<LB^0(x).\n\n  * Finally, for each variable x, we obtain an interval partition \n\n    IP(x)=\u22c3_0<i\u2264 n{(UB^i-1(x),UB^i(x)]}\u222a (UB^n, LB^m) \u222a\u22c3_0<j\u2264 m{[LB^j(x),LB^j-1(x))}\n\n\n\n\n\n\n\n\n\nFormally, given a real variable x and an interval I from IP(x), \u2200 v_1,v_2\u2208 I, make(op(x,v_1))=make(op(x,v_2)).\nAs a slight abuse of notation, for an interval I from IP(x), we define its make value as the make value of any operation op(x,v) with v\u2208 I. \nNote that all intervals in IP(x) have positive make values except (UB^n, LB^m), whose  make value is 0.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGiven a formula F:c_1\u2227 c_2=(a-b > 4\u2228 2a-b\u2265 7\u2228 2a-c\u2264 -5)\u2227 (a-c\u2265 2\u2228 a-d\u2264-1) and the current assignment is \u03b1={a=0, b=0, c=0}.\nFor variable a, SD_c(a,c_1)=(-\u221e,-2.5]\u222a[3.5,\u221e) and SD_c(a,c_2)=(-\u221e,-1]\u222a[2,\u221e).\n\nThen, UB^0(a)=-\u221e, UB^1(a)=UB(a,c_1)=-2.5, UB^2(a)=UB(a,c_2)=-1, LB^2(a)=LB(a,c_2)=2, LB^1(a)=LB(a,c_1)=3.5 and LB^0(a)=\u221e.\n\n\nTherefore, interval partition for x is IP(x)=I_1 \u222a I_2 \u222a I_3 \u222a I_4 \u222a I_5=(-\u221e, -2.5]\u222a (-2.5, -1] \u222a (-1, 2) \u222a [2, 3.5) \u222a [3.5, +\u221e), as shown in Fig <ref>. For these intervals w.r.t. x, the make value is 2, 1, 0, 1, 2 respectively.\n\n\n\n\n\n\n\n\n\n \u00a7.\u00a7 Candidate Values for Operations\n\n\n\n\nSince assigning a variable x to any value in an equi-make interval  would satisfy the same amount of falsified clauses, after choosing an equi-make interval, we can consider more values in the interval as the option for the future value of operation, rather than only the threshold.\n\nIn this work, we only consider the intervals with a positive make value, and thus the interval (UB^n, LB^m) is omitted. Thus, the interval for consideration is of the form (UB^i-1(x),UB^i(x)] or [LB^i(x),LB^i-1(x)). For such an interval, we consider the following values for the operation:\n\n    \n  * Assign x to the threshold UB^i(x) or LB^i(x).\n    \n  * Assign x to the median of the interval, that is (UB^i-1(x)+UB^i(x))/2 and (LB^i(x)+LB^i-1(x))/2.\n    \n  * if there exist integers in the open interval (UB^i-1(x),UB^i(x)) or the interval (LB^i(x), LB^i-1(x)), assign x to the largest or smallest integer in the respective open interval; Otherwise, suppose that the open interval can be written as (a/b,c/d), then assign x to a+c/b+d.\n\n\nThe first option is the same as critical move, and thus critical move can be regarded as a special case of our interval-based operator.\nThe second option is an typical choice among intervals.\nThe third option aims to find a rational value in the open interval with small denominator.\n\n\n\n\n\u00a7 A TIE-BREAKING MECHANISM\n\n\n\nWe notice that there often exist different operations with the same best score during local search, and thus tie-breaking is also important to guide the search. \n\n\n\nTo confirm our observation, we conduct a pre-experiment on 100 randomly selected instances.\nOn each instance, we execute a simple local search algorithm which selects an operation with the best score for  10000 iterations, and we count the number of steps where k operations with the same best score are found, denoted as step(k).\n\n\n\nThe average step(k) is presented in Fig. <ref>.\nThe steps where more than one operations have the same best score take up 61.2% of the total steps.\nThus, a tie-breaking heuristic is required to further distinguish these operations with same best score.\n\nFirst, we consider that assigning real-valued variable to values with large denominator can lead the algorithm to more complex search space, leading to more complicated computation and possible errors.\nThus, we prefer operations that assign variable to value with a small denominator.\n\nMoreover, we consider that assigning variable to value with large absolute value  can lead to the assignment with extraordinarily large value, deviating the algorithm from finding a possible solution.\nThus, we prefer operations assigning variable to value with a small absolute value.\n\nBased on the above observation and intuition, we propose the selection rule for picking operation, described as follows.\n\nSelection Rules: Select the operation with the greatest score, breaking ties by preferring the one assigning the corresponding variable to value with the smallest denominator.\nFurther ties are broken by picking the operation assigning the variable with the smallest absolute value.\n\n\n\n\n\n\u00a7 LS-RA ALGORITHM\n\n\n\nOur local search algorithm adopts a two-mode framework, which switches between  Real mode and Boolean mode. This framework has been used in the local search algorithm LS-LIA for integer arithmetic theories\u00a0<cit.>.  \n\n\n\n\n \u00a7.\u00a7 Local search Framework\n\n\n\nAs depicted in Fig. <ref>,  after the initialization, the algorithm switches between Real mode and Boolean mode.\nIn each mode, an operation on a variable of the corresponding data type is selected to modify the current solution.\n The two modes switches to each other when the number of non-improving steps (denoted as non_improve_steps) of the current mode reaches a threshold. \n The threshold is set to L\u00d7 P_b for the Boolean mode and L\u00d7 P_r for the Real mode, where P_b and P_r denote the proportion of Boolean and real-variable literals to all literals in falsified clauses, and L is a parameter.\n\n\n\n\n\n \u00a7.\u00a7 Local Search in Real Mode\n\n\nAs described in Algorithm <ref>, if the current assignment \u03b1 satisfies the given formula F, then the solution is found (Line 2).\nThe algorithm tries to find a decreasing interval-based operation according to the Selection Rule (Line 3\u20134).\n\nIf there exists no such decreasing operation, indicating that the algorithm falls into the local optimum.\nWe first update the clause weight according to the probabilistic version of the PAWS scheme <cit.> (Line 6),\nand then randomly sample K interval-based operations into the set Set_op (Line 7), where K is a relatively small parameter.\nThe best operation is picked according to Selection Rules among Set_op (Line 8).\nNote that since the interval-based operation can satisfy at least one clause, picking the best one among few randomly sampled interval-based operation  can be regarded as a diversification operation.\n\nThe probabilistic version of the PAWS scheme works as follows.\nWith probability 1-sp, the weight of each falsified clause is increased by one, and  with probability sp, for each satisfied clause whose weight is greater than 1, the weight is decreased by one.\n\n\n\n\nAs for the Boolean mode focusing on the subformula consisting of Boolean variables, LS-RA works in the same way as the Boolean mode of LS-LIA.\nBy putting the Boolean mode and the Real mode together, we propose our local search algorithm for SMT(RA) denoted as LS-RA.\n\n\n\n\n\n\n\u00a7 EXPERIMENTS\n\n\nWe conducted experiments to evaluate LS-RA on on 2 benchmarks from SMT-LIB, and compare it with state-of-the-art SMT solvers.\nMoreover, ablation experiments are conducted to analyze the effectiveness of the proposed strategies.\n\n\n\n \u00a7.\u00a7 Experiment Preliminaries\n\nImplementation: \nLS-RA is implemented in C++ and compiled by g++ with '-O3' option.\nThere are 3 parameters in LS-LRA:\n L for switching phases,  K for the number of sampled operation and sp (the smoothing probability) for the PAWS scheme.\nThe parameters are tuned according to suggestions from the literature and our preliminary experiments on 20% sampled instances, and are set as follows:\nL=20, K=3, sp=0.0003 for all benchmarks. \n\n\nCompetitors: \nIn the context of SMT(LRA), we compare LS-RA with the top 4 state-of-the-art SMT solvers according to  SMT-COMP 2022[https://smt-comp.github.io/2022], namely\nOpenSMT (version 2.4.2)\n[https://github.com/usi-verification-and-security/opensmt],\nYices2 (version 2.6.2)\n[https://yices.csl.sri.com],\nCVC5 (version 1.0.0)\n[https://cvc5.github.io/],\nand Z3 (version 4.8.17)\n[https://github.com/Z3Prover/z3/].\nWhile in the context of SMT(NRA), the top 4 competitors are as follows,\nCVC5 (version 1.0.0),\nYices2 (version 2.6.2),\nZ3 (version 4.8.17)\nand SMT-RAT-MCSAT (version 22.06)\n[https://github.com/ths-rwth/smtrat].\nThe binaries of all competitors are downloaded from their websites.\nNote that portfolio and derived solvers are excluded.\n\nBenchmarks:  Experiments are carried out on 2 benchmark sets from SMT-LIB.\n\n\n\n    \n  * SMTLIB-LRA: This benchmark set consists of SMT(LRA) instances from SMT-LIB[https://clc-gitlab.cs.uiowa.edu:2443/SMT-LIB-benchmarks/QF_LRA].\n    As LS-RA is an incomplete solver, UNSAT instances are excluded, resulting in a benchmark consisting of 1044  unknown and satisfiable instances. \n    \n  * SMTLIB-MRA: This benchmark set consists of SMT(NRA) instances whose atomic constraints are multilinear from  SMT-LIB[https://clc-gitlab.cs.uiowa.edu:2443/SMT-LIB-benchmarks/QF_NRA].\n    UNSAT instances are also excluded, resulting in a benchmark consisting of 979  unknown and satisfiable instances.\n    \n\n\nExperiment Setup: \nAll experiments are carried out on a server with AMD EPYC 7763 64-Core  2.45GHz and 2048G RAM under the system Ubuntu 20.04.4.\nEach solver is executed one run with a cutoff time of 1200 seconds (as in the SMT-COMP) for each instance in both benchmarks, as they contain sufficient instances.\nWe compare the number of instances where an algorithm finds a model (\u201c#solved\u201d), as well as the run time.\nThe bold value in table emphasizes the solver with greatest \u201c#solved\u201d.\n\n\n\n\n\n \u00a7.\u00a7 Results on SMTLIB-LRA Benchmark\n\nAs shown in Table <ref>, LS-RA can solve 900 out of 1044 instances, which is competitive but still cannot rival its competitors.\nWe also compare the run time comparison between LS-RA and each competitor on instances from SMTLIB-LRA in Fig <ref>, which shows that LS-RA is complementary to the competitors.\n\nOne explanation for the fact that LS-RA cannot rival its CDCL(T) competitors is that the simplex-based theory solver performs so efficiently that there is little space for improvement.\nMoreover, 54.5% of the instances in SMTLIB-LRA contain Boolean variables, while the Boolean mode of LS-RA is not good at exploiting the relations among Boolean variables, similar to LS-LIA.\n\n\n\n\n\n\n\n\n\n\n\n \u00a7.\u00a7 Results on SMTLIB-MRA Benchmark\n\nLS-RA can solve more multilinear instances than all competitors on this benchmark (solving 891 out of 979 instances), which is shown in Table <ref>. \nThe time comparison between LS-RA and its competitors is shown in Fig <ref>, confirming that LS-RA is more efficient than all competitors.\n\nLS-RA works particularly well on instances from \u201czankl\u201d and \u201cUltimateAutomizer\u201d type, which are industrial instances generated in the context of software verification.\nOn these types, LS-RA can solve all instances, outperforming all the competitors.\nMoreover, LS-RA can exclusively solve 13 instances from \u201c20170501-Heizmann\u201d type, which implements a constraint-based synthesis of invariants<cit.>.\n\nThe explanation for the superiority of LS-RA on SMTLIB-MRA are as follows.\nIn contrast to LRA, the theory solver for NRA constraints requires complex calculation, which reduces the performance of these competitors, while LS-RA can trivially determine the operations in multilinear constraints, and thus LS-RA can efficiently explore the search space.\n\n\n\n\n\n\n\n \u00a7.\u00a7 Effectiveness of Proposed strategies\n\nIn order to analyze the effectiveness of the strategies in LS-RA, we modify  LS-RA to obtain 3 alternative versions as follows.\n\n    \n  * To analyze the effectiveness of interval-based operator, we modify LS-RA by replacing the interval-based operation with traditional cm operator, leading to the version v_cm.\n    \n  * To analyze the effectiveness of the tie-breaking mechanism, we modify LS-RA by evaluating operation based on score without considering the Selection Rules, leading to the version v_score.\n    \n  * We also implement a plain version which adopts neither interval-based operator nor tie-breaking mechanism, denoted as v_plain.\n\n\n\n\nLS-RA is compared with these modified versions on both benchmarks.\nThe runtime distribution of LS-RA and its modified versions is presented in Fig. <ref>, which confirms the effectiveness of our proposed strategies.\n\n\n\n\n\u00a7 CONCLUSION AND FUTURE WORK\n\n\nIn this paper, we propose the first local search algorithm for SMT on Real Arithmetic based on the following novel ideas.\nFirst, the interval-based operation is proposed to enrich the traditional operation, by considering the interval information.\nMoreover, a tie-breaking mechanism are proposed to distinguish  operations with same best score. \nExperiments on SMT-LIB show that our solver is competitive and complementary with state-of-the-art SMT solvers, especially for those multilinear instances.\n\nThe future direction is to extend LS-RA to support all SMT(NRA) instances and deeply combine our local search algorithm with the state-of-the-art DPLL(T) SMT solver, resulting in a hybrid solver that can make the most of respective advantages.\n\n\n\n\n\n\n\nsplncs04\n\n\n\n"}