{"entry_id": "http://arxiv.org/abs/2303.07290v1", "published": "20230313171005", "title": "Finding Diverse Minimum s-t Cuts", "authors": ["Mark de Berg", "Andr\u00e9s L\u00f3pez Mart\u00ednez", "Frits Spieksma"], "primary_category": "cs.DS", "categories": ["cs.DS", "05C85", "F.2.2; G.2.2"], "text": "\n\nAnyon condensation in the string-net models\n    Fiona J. Burnell\n    March 30, 2023\n===========================================\n\n\n\narabic\n\n\nRecently, many studies have been devoted to finding diverse solutions in classical combinatorial problems, such as Vertex Cover (Baste et al., IJCAI'20), Matching (Fomin et al., ISAAC'20) and Spanning Tree (Hanaka et al., AAAI'21). Finding diverse solutions is important in settings where the user is not able to specify all criteria of the desired solution. Motivated by an application in the field of system identification, we initiate the algorithmic study of k-Diverse Minimum s-t Cuts which, given a directed graph G = (V, E), two specified vertices s,t \u2208 V, and an integer k > 0, asks for a collection of k minimum s-t cuts in G that has maximum diversity. We investigate the complexity of the problem for two diversity measures for a collection of cuts: (i) the sum of all pairwise Hamming distances, and (ii) the cardinality of the union of cuts in the collection. We prove that k-Diverse Minimum s-t Cuts can be solved in strongly polynomial time for both diversity measures via submodular function minimization. We obtain this result by establishing a connection between ordered collections of minimum s-t cuts and the theory of distributive lattices. When restricted to finding only collections of mutually disjoint solutions, we provide a more practical algorithm that finds a maximum set of pairwise disjoint minimum s-t cuts. For graphs with small minimum s-t cut, it runs in the time of a single max-flow computation. These results stand in contrast to the problem of finding k diverse global minimum cuts\u2014which is known to be NP-hard even for the disjoint case (Hanaka et al., 2022)\u2014and partially answer a long-standing open question of Wagner (Networks 1990) about improving the complexity of finding disjoint collections of minimum s-t cuts.  \n\n\n\n\n\u00a7 INTRODUCTION\n\n\nThe Minimum s-t Cut problem is a classic combinatorial optimization problem. Given a directed graph G = (V, E) and two special \nvertices s, t \u2208 V, the problem asks for a subset S \u2286 E of minimum cardinality that separates vertices s and t, meaning that removing these edges from G ensures there is no path from s to t. Such a set is called a minimum s-t cut or s-t mincut, and it need not be unique. This problem has been studied extensively and has numerous practical and theoretical applications. Moreover, it is known to be solvable in polynomial time. Several variants and generalizations of the problem have been studied; we mention the global minimum cut problem and the problem of enumerating all minimum s-t cuts in a graph.\nIn this paper, we initiate the algorithmic study of computing diverse minimum s-t cuts. Concretely, we introduce the following optimization problem. \n\n[k-Diverse Minimum s-t Cuts (k-DMC)] \nGiven are a directed graph G = (V, E), vertices s,t \u2208 V and an integer k > 0. Let \u0393_G(s, t) be the set of minimum s-t cuts in G, and let U_k be the set of k-element multisets of \u0393_G(s, t). We want to find C \u2208 U_k such that d(C) = max_S \u2208 U_k d(S), where d : 2^U_k\u2192\u2115 is a measure of diversity.\n\n\nInformally, given a directed graph G along with two specified vertices s and t, and an integer k, we are interested in finding a collection of k s-t mincuts in G that are as different from each other as possible; that is, a collection having maximum diversity. Notice that the problem is well defined even when there are less than k s-t mincuts in G, because we allow multisets in the solution. To formally capture the notion of diversity of a collection of sets, several measures have been proposed in literature <cit.>. \nIn this work, we choose two natural and general measures as our notions of diversity. Given a collection (X_1, X_2, \u2026, X_k) of subsets of a set A (not necessarily distinct), we define \n\n    d_sum(X_1, \u2026, X_k) = \u2211_1\u2264 i < j \u2264 k |X_i  X_j|, \n        d_cov(X_1, \u2026, X_k) = |\u22c3_1 \u2264 i \u2264 k X_i |\n\nwhere X_i  X_j = (X_i \u222a X_j) \u2216 (X_i \u2229 X_j) is the symmetric difference (or Hamming distance) of X_i and X_j. Throughout, we call function (<ref>) the pairwise-sum diversity and function (<ref>) the coverage diversity. \nThese measures are amongst the most broadly used in describing diversity among solutions in combinatorial problems.  \n\n\n\n  \nMotivation.\nWe now briefly motivate why finding diverse minimum s-t cuts in a graph can be of interest. In general, to solve a real-world problem, one typically formulates the problem as an instance of a computational problem and proceeds to find a solution with the help of an optimization algorithm. However, this is not always an easy task, and the abstraction to a mathematical formulation is usually just a simplification. From a theoretical perspective, an optimal solution to the simplified problem is as good as any other optimal solution, but due to the loss of information during the abstraction process, not every such solution is guaranteed to be adequate for practical usage. \nAn illustrating example is the so-called synthesis problem in the field of system identification, where (under special conditions) the Minimum s-t Cut problem can be used to determine an optimal placement of input and output signals in a physical system (modeled as a directed graph) to gather information about its behaviour <cit.>. \nAn optimal placement obtained from the abstract model, however, is not always practically feasible due to omitted physical constraints of the system that would otherwise render the model unmanageable <cit.>.\n\nOne way of dealing with this issue is to present all optimal solutions of the simplified model and let a user choose between them based on external factors ignored by the mathematical model. Such an approach is useful when the number of optimal solutions is small, but in most cases (as in the Minimum s-t Cut problem) the number of optimal solutions can be exponential in the input size, rendering the approach infeasible. Another approach is to present only a small number k of optimal solutions, but one should be careful not to output solutions that are very similar to each other, as a solution resembling a practically infeasible solution is likely to be practically infeasible as well. Thus, we would like to somehow obtain a small list of k optimal, yet sufficiently \u201cdiverse\u201d solutions from which a user can make a choice a posteriori. \n\n\n\n  \nOur results. \nWe investigate the complexity of the following two variants of k-Diverse Minimum s-t Cuts: (i) Sum k-Diverse Minimum s-t Cuts (Sum-k-DMC), and (ii) Cover k-Diverse Minimum s-t Cuts (Cov-k-DMC). These are the problems obtained when defining function d in k-DMC as diversity measures (<ref>) and (<ref>), respectively. For a graph G, we use n to denote the number of nodes and m to denote the number of edges.\n\nContrary to the hardness of finding diverse global mincuts in a graph <cit.>, we show that both Sum-k-DMC and Cov-k-DMC can be solved in polynomial time. We show this via a reduction to the submodular function minimization problem (SFM) on a lattice, which is known to be solvable in strongly polynomial time when the lattice is distributive <cit.>.\n\n[]theoremmainTheorem \n    Sum-k-DMC and Cov-k-DMC can be solved in strongly polynomial time.\n\n\nAt the core of this reduction is a generalization of an old result of Escalante <cit.> establishing a connection between minimum s-t cuts and distributive lattices. As will be elaborated in Section <ref>, we obtain our results by showing that the pairwise-sum and coverage diversity measures (reformulated as minimization objectives) are submodular functions on the lattice L^* defined by left-right ordered collections of s-t mincuts, and that this lattice is in fact distributive. Using the currently fastest algorithm for SFM by Jiang <cit.>, together with an appropriate representation of the lattice L^*, we can obtain an algorithm solving these problems in O(k^5n^5) time. \n\nIn Section <ref>, we obtain better time bounds for the special case of finding collections of s-t mincuts that are pairwise disjoint. Similar to SUM-k-DMC and COV-k-DMC, our approach exploits the partial order structure of s-t mincuts. We use this to efficiently solve the following optimization problem, which we call k-Disjoint Minimum s-t Cuts: given a graph G = (V, E), vertices s,t \u2208 V, and an integer k \u2264 k_max, find k pairwise disjoint s-t mincuts in G. Here, k_max denotes the maximum number of disjoint s-t mincuts in G. Our algorithm is significantly simpler than the previous best algorithm by Wagner <cit.>, which runs in the time of a poly-logarithmic number of calls to any min-cost flow algorithm. Our algorithm takes O(F(m, n) + m\u03bb) time, where F(m, n) is the time required by a unit-capacity max-flow computation, and \u03bb is the size of an s-t mincut in the graph. By plugging in the running time of the current fastest deterministic max-flow algorithms of <cit.>, we obtain the following time bounds. When \u03bb\u2264 m^1/3 + o(1), our algorithm improves upon the previous best runtime for this problem. \n\n \nk-Disjoint Minimum s-t Cuts can be solved in time O(m^4/3 + o(1) + m \u03bb). \n\n\n\n\n  \nRelated Work.\nMany efforts have been devoted to finding diverse solutions in combinatorial problems. In their seminal paper <cit.>, Kuo et al. were the first to explore this problem from a complexity-theoretic perspective. They showed that the basic problem of maximizing a distance norm \nover a set of elements is already NP-hard. Since then, the computational complexity of finding diverse solutions in many other combinatorial problems has been studied. For instance, diverse variants of Vertex Cover, Matching and Hitting Set have been shown to be NP-hard, even when considering simple diversity measures like the pairwise-sum of Hamming distances, or the minimum Hamming distance between sets. This has motivated the study of these and similar problems from the perspective of fixed-parameter tractable (FPT) algorithms <cit.>. \n\nAlong the same line, Hanaka et al.\u00a0<cit.> recently developed a framework to design approximation algorithms for diverse variants of combinatorial problems. On the positive side, diverse variants of other classic problems are known to be polynomially solvable when considering certain set-based diversity measures, such as Spanning Tree <cit.> and Shortest Path <cit.>, but not much is known about graph partitioning problems in light of diversity. \n\nThe problem of finding multiple minimum cuts has received considerable attention <cit.>. Picard and Queyranne <cit.> initiated the study of finding all minimum s-t cuts in a graph, showing that these can be enumerated efficiently. They observe that the closures of a naturally-defined poset over the vertices of the graph, correspond bijectively to minimum s-t cuts. An earlier work of Escalante <cit.> already introduced an equivalent poset for minimum s-t cuts, but contrary to Picard and Queyranne, no algorithmic implications were given. Nonetheless, Escalante shows that the set of s-t mincuts in a graph, together with this poset, defines a distributive lattice. Similar structural results for stable matchings and circulations have been shown to have algorithmic implications <cit.>, but as far as we know, the lattice structure of s-t mincuts has been seldomly exploited in the algorithmic literature.[Bonsma <cit.> does make implicit use of the lattice structure of minimum s-t cuts to investigate the complexity of finding most balanced minimum cuts and partially ordered knapsack problems, but does not make this connection to lattice theory explicit.]\n\nWagner <cit.> studied the problem of finding k pairwise-disjoint s-t cuts of minimum total cost in an edge-weighted graph.[Notice that when the input graph is unweighted and k \u2264 k_max, Wagner's problem reduces to k-Disjoint Minimum s-t Cuts.] He showed that this problem can be solved in polynomial time by means of a reduction to a transshipment problem; where he raised the question of whether improved complexity bounds were possible by further exploiting the structure of the problem, as opposed to using a general purpose min-cost flow algorithm for solving the transshipment formulation. In sharp contrast, Hanaka et al. <cit.> recently established that the problem of finding k pairwise-disjoint global minimum cuts in a graph is NP-hard (for k part of the input). We are not aware of any algorithm for minimum s-t cuts that runs in polynomial time with theoretical guarantees on diversity. \n\n\n\n\n\u00a7 PRELIMINARIES\n\n\n\n\n \u00a7.\u00a7 Distributive Lattices\n \n\nIn this paper, we use properties of distributive lattices. Here we introduce basic concepts and results on posets and lattices while making an effort to minimize new terminology. For a more detailed introduction to lattice theory see e.g., <cit.>. \n\nA partially ordered set (poset) P = (X, \u227c) is a ground set X together with a binary relation \u227c on X that is reflexive, antisymmetric, and transitive. We use \ud835\udc9f(P) to denote the family of all ideals of P. When the binary operation \u227c is clear from the context, we use the same notation for a poset and its ground set. Here, we consider the standard representation of a poset P as a directed graph G(P) containing a node for each element and edges from an element to its \npredecessors. For a poset P = (X, \u227c), an ideal is a set U \u2286 X where u \u2208 U implies that v \u2208 U for all v \u227c u. In terms of G(P) = (V, E), a subset W of V is an ideal if and only if there is no outgoing edge from W. \n\nA lattice is a poset L = (X, \u227c) in which any two elements x, y \u2208 X have a (unique) greatest lower bound, or meet, denoted by x \u2227 y, as well as a (unique) least upper bound, or join, denoted by x \u2228 y. We can uniquely identify L by the tuple (X, \u2228, \u2227). A lattice L' is a sublattice of L if L' \u2286 L and L' has the same meet and join operations as L. In this paper we only consider distributive lattices, which are lattices whose meet and join operations satisfy distributivity; that is, x \u2228 (y \u2227 z) = (x \u2228 y) \u2227 (x \u2228 z) and x \u2227 (y \u2228 z) = (x \u2227 y) \u2228 (x \u2227 z), for any x,y,z \u2208 L. Note that a sublattice of a distributive lattice is also distributive. \n\nSuppose we have a collection L_1, \u2026, L_k of lattices L_i = (X_i, \u2228_i, \u2227_i) with i \u2208 [k].[Throughout, we use [k] to denote the set {1,...,k}.] The (direct) product lattice L_1 \u00d7\u2026\u00d7 L_k is a lattice with ground set X = {(x_1, \u2026, x_k)   :   x_i \u2208 L_i} and join \u2228 and meet \u2227 operations acting component-wise; that is, x \u2228 y = (x_1 \u2228_1 y_1, \u2026, x_k \u2228_k y_k) and x \u2227 y = (x_1 \u2227_1 y_1, \u2026, x_k \u2227_k y_k) for any x, y \u2208 X. The lattice L^k is the product lattice of k copies of L, and is called the kth power of L. If L is a distributive lattice, then L^k is also distributive. \n\nA crucial notion we will need is that of join-irreducibles. An element x of a lattice L is called join-irreducible if it cannot be expressed as the join of two elements y, z \u2208 L with y, z \u2260 x. In a lattice, any element is equal to the join of all join-irreducible elements lower than or equal to it. The set of join-irreducible elements of L is denoted by J(L). Note that J(L) is a poset whose order is inherited from L. \n\n\nAny distributive lattice L can be represented as the poset of its join-irreducibles J(L), with the order induced from L.\n\n\nDue to Birkhoff's representation theorem\u2014a fundamental tool for studying distributive lattices\u2014every distributive lattice L is isomorphic to the lattice \ud835\udc9f(J(L)) of ideals of its poset of join-irreducibles, with union and intersection as join and meet operations. Hence, a distributive lattice L can be uniquely recovered from its poset J(L). For a distributive lattice L, this implies that there is a compact representation of L as the directed graph G(L) that characterizes its set of join-irreducibles. (The graph G(L) is unique if we remove transitive edges.) This is useful when designing algorithms, as the size of G(L) is O(|J(L)|^2), while L can have as many as 2^|J(L)| elements. See Figure <ref> for an illustration. \n\n\n\n\n\n \u00a7.\u00a7 Submodular Function Minimization\n \nLet f be a real-valued function on a lattice L = (X, \u227c). We say that f is submodular on L if \n\n    f(x \u2227 y) + f(x \u2228 y) \u2264 f(x) + f(y),   for all  x,y \u2208 X.\n\nIf -f is submodular on L, then we say that f is supermodular in L and just modular if f satisfies (<ref>) with equality. The submodular function minimization problem (SFM) on lattices is, given a submodular function f on L, to find an element x \u2208 L such that f(x) is minimum. An important fact that we use in our work is that the sum of submodular functions is also submodular. Also, note \nthat minimizing f is equivalent to maximizing -f. \n\nConsider the special case of a lattice whose ground set X \u2286 2^U is a family of subsets of a set U, and meet and join are intersection and union of sets, respectively. It is known that any function f satisfying (<ref>) on such a lattice can be minimized in polynomial time in |U| <cit.>. This holds when assuming that for any Y \u2286 U, the value of f(Y) is given by an evaluation oracle that also runs in polynomial time in |U|. The current fastest algorithm for SFM on sets runs in O(|U|^3 T_EO) time <cit.>, where T_EO is the time required for one call to the evaluation oracle. \n\nDue to Birkhoff's theorem, the seemingly more general case of SFM on distributive lattices can be reduced to SFM on sets as follows.[For a more detailed description of the reduction from SFM on a distributive lattice to SFM on sets, we refer the reader to <cit.>.] First, recall that every distributive lattice L can be seen as the poset \ud835\udc9f(J(L)) of ideals of its join-irreducibles, with union and intersection of ideals as join and meet operations, respectively. \nThen, one can always construct an analogue function f\u0302 on \ud835\udc9f(J(L)) of the original function f on L in the following way. For the ideal A \u2208\ud835\udc9f(J(L)) corresponding to the set of join-irreducibles lower than or equal to a \u2208 L, simply set f\u0302(A) = f(a). \nThen, the submodularity of f on L gets translated to the submodularity of f\u0302 on \ud835\udc9f(J(L)). Moreover, provided that union and intersection of sets can be computed in polynomial time, computing f\u0302 is polynomially no harder than computing f. So, any polynomial-time algorithm for SFM on sets can be used to minimize a submodular function f \non a distributive lattice L by minimizing the analogue function f\u0302 on \ud835\udc9f(J(L)). An important remark \nis that the running time now depends on the size of the set J(L) of join-irreducibles.\n\n \nFor any distributive lattice L, given by its poset of join-irreducibles J(L), a submodular function f: L \u2192\u211d can be minimized in polynomial time in |J(L)|, provided a polynomial time evaluation oracle for f.\n\n\n\n\n \u00a7.\u00a7 Minimum Cuts\n\nThroughout this paper, we restrict our discussion to directed graphs. All our results can be extended to undirected graphs by means of well-known transformations. Likewise, we deal only with edge-cuts, although our approach can be adapted to vertex-cuts as well.\n\nLet G be a directed graph with vertex set V(G) and edge set E(G). As usual, we define n  |V(G)| and m  |E(G)|. \nGiven a source s \u2208 V(G) and target t \u2208 V(G) in G, we call a subset X \u2282 E(G) an s-t cut if the removal of X from the graph ensures that no path from s to t exists in G \u2216 X. The size of a cut is the total number of edges it contains. If an s-t cut in G has smallest size \u03bb(G), we call it a minimum s-t cut, or an s-t mincut. Note that such a cut need not be unique (in fact, there can be exponentially many). To denote the set of all s-t mincuts of G, we use the notation \u0393_G(s, t). \n\nA (directed) path starting in a vertex u and ending in a vertex v is called a u-v path. By Menger's theorem, the cardinality of a minimum s-t cut in G is equal to the maximum number of internally edge-disjoint s-t paths in the graph. Let \ud835\udcab_s, t(G) denote a maximum-sized set of edge-disjoint paths from s to t in G. Any minimum s-t cut in G contains exactly one edge from each path in \ud835\udcab_s, t(G).\n\nFor two distinct edges (resp. vertices) x and y in a u-v path p, we say that x is a path-predecessor of y in p and write x \u227a_p y if the path p meets x before y. We use this notation indistinctly for edges and vertices. It is easily seen that the relation \u227a_p extends uniquely to a non-strict partial order. We denote this partial order by x \u227c_p y. Consider now any subset W \u2286\u0393_G(s, t) of s-t mincuts in G, and let E(W) denote the set of edges used in any of these cuts. Two crucial notions in this work are those of leftmost and rightmost s-t mincuts. The leftmost s-t mincut in W consists of the set of edges S_min(W) \u2286 E(W) such that, for every path p \u2208\ud835\udcab(s, t), there is no edge e \u2208 E(W) satisfying e \u227a_p f for any f \u2208 S_min(W). Note that S_min(W) is not necessarily one of the cuts in W. Similarly for the rightmost s-t mincut S_max(W) \u2286 E(W). It can be shown that both S_min(W) and S_max(W) are also s-t mincuts in G (see proof of Claim <ref> in the appendix). When W consists of the entire set of s-t mincuts in G, we denote these extremal cuts by S_min(G) and S_max(G). \n\nOn the set of s-t cuts (not necessarily minimum), the following predecessor-successor relation defines a partial order: an s-t cut X is a predecessor of another s-t cut Y, denoted by X \u2264 Y, if every path from s to t in G meets an edge of X at or before an edge of Y. \nIt is known that the set of s-t mincuts together with relation \u2264 defines a distributive lattice L <cit.>. Moreover, a compact representation G(L) can be constructed from a maximum flow in linear time <cit.>. These two facts play a crucial role in the proof of our main result in the next section.\n\n\n\n\u00a7 A POLYNOMIAL TIME ALGORITHM FOR SUM-K-DMC AND COV-K-DMC\n\nThis section is devoted to proving Theorem <ref> by reducing SUM-k-DMC and COV-k-DMC to SMF on distributive lattices. Before giving the actual reduction, however, we need one additional step; which is to show that the domain of solutions of SUM-k-DMC and COV-k-DMC can be restricted to the set of k-tuples that satisfy a particular order, as opposed to the set of k-sized multisets of s-t mincuts (see Corollary <ref> below). \nThe reason for doing so is that the structure provided by the former set can be exploited to assess the \u201cmodularity\u201d of \nthe total-sum and coverage objectives. We begin by introducing the notions of left-right order and edge multiplicity, which are needed throughout the section.\n\nConsider a graph G with source and target s, t \u2208 V(G), and let U^k be the set of all k-tuples over \u0393_G(s, t). An element C \u2208 U^k is a (ordered) collection or sequence [X_1, \u2026, X_k] of cuts X_i \u2208\u0393_G(s, t), where i runs over the index set [k]. \nWe say that C is in left-right order if X_i \u2264 X_j for all i < j. Let us denote by U_lr^k \u2286 U^k the set of all k-tuples over \u0393_G(s, t) that are in left-right order. Then, for any two C_1, C_2 \u2208 U_lr^k, with C_1 = [X_1, \u2026, X_k], C_2 = [Y_1, \u2026, Y_k], we say that C_1 is a predecessor of C_2 (and C_2 a successor of C_1) if X_i \u2264 Y_i for all i \u2208 [k], and denote this by C_1 \u227c C_2. Now, consider again a collection C \u2208 U^k. The set of edges \u22c3{E(X) : X \u2208 C} is denoted by E(C). We define the multiplicity of an edge e \u2208 E(G) with respect to C as the number of cuts in C that contain e and denote it by \u03bc_e(C). We say that an edge e \u2208 E(C) is a shared edge if \u03bc_e(C) \u2265 2. The set of shared edges in C is denoted by E_shr(C). Next we make the following proposition, whose proof is deferred to Appendix <ref>.\n\npropositionpropMultCons \nFor every C \u2208 U^k there exists \u0108\u2208 U_lr^k such that \u03bc_e(C) = \u03bc_e(\u0108) for all e \u2208 E(G). \n\n\nIn other words, given a k-tuple of s-t mincuts, there always exists a k-tuple on the same set of edges that is in left-right order; each edge occurring with the same multiplicity. Consider now the total-sum and the coverage diversity measures first introduced in Section <ref>. We can rewrite them directly in terms of the multiplicity of shared edges as \n\n    d_sum(C) = 2 [\u03bbk2 - \u2211_e \u2208 E_shr(C)\u03bc_e(C)2],   and\n        d_cov(C) = k \u03bb - \u2211_e \u2208 E_shr(C)( \u03bc_e(C) - 1 ).\n\nNotice that the terms outside the summations are constant terms. Equation (<ref>) follows from the fact that we count a shared edge once per pair of cuts that contain it\u2014and there are \u03bc_e(C) such cuts\u2014while equation (<ref>) follows from removing doubly counted edges. From combining (<ref>) (resp. (<ref>)) with Proposition <ref>, we can obtain the following corollary. (For simplicity, we state this only for the d_sum diversity measure, but an analogous claim holds for the d_cov measure.)\n\n \nLet C \u2208 U^k such that d_sum(C) = max_S \u2208 U^k d_sum(S). Then there exists C' \u2208 U_lr^k such that d_sum(C') = d_sum(C). \n\n\nThis corollary tells us that in order to solve SUM-k-DMC (resp. COV-k-DMC) we do not need to optimize over the set U_k of k-element multisets of \u0393_G(s, t). Instead, we can look at the set U_lr^k \u2286 U^k of k-tuples that are in left-right order. On the other hand, from equations (<ref>) and (<ref>) it follows that the problem of maximizing d_sum(C) and d_cov(C) is equivalent to that of minimizing \n\n    d\u0302_sum(C) = \u2211_e \u2208 E_shr(C)\u03bc_e(C)2,   and\n       d\u0302_cov(C) = \u2211_e \u2208 E_shr(C)( \u03bc_e(C) - 1 ),\n\nrespectively. \nIn turn, the submodularity of (<ref>) (resp. (<ref>)) \nimplies the supermodularity of (<ref>) (resp. (<ref>)) \nand vice versa. In the remaining of the section, we shall only focus on the minimization objectives d\u0302_sum and d\u0302_cov. \n\nWe are now ready to show that both SUM-k-DMC and COV-k-DMC can be reduced to SFM. We first show that the poset L^* = (U_lr^k, \u227c) is a distributive lattice (Section <ref>). Next we prove that the diversity measures d\u0302_sum and d\u0302_cov are submodular functions on L^* (Section <ref>). Lastly, we show that there is a compact representation of the lattice L^* and that it can be constructed in polynomial time, concluding with the proof of Theorem <ref> (Section <ref>). \n\n\n\n \u00a7.\u00a7 Proof of Distributivity\n \nWe use the following result of Escalante <cit.> (see also <cit.>). Recall that \u2264 denotes the predecessor-successor relation between two s-t mincuts. \n\n \nThe set \u0393_G(s, t) of s-t mincuts of G together with the binary relation \u2264 forms a distributive lattice L. For any two cuts X, Y \u2208 L, the join and meet operations are given respectively by \n\n    X \u2228 Y =      S_max(X \u222a Y),   and\n    \n        X \u2227 Y =      S_min(X \u222a Y).\n\n\n\nWe can extend this result to the corresponding relation \u227c on the set U_lr^k of k-tuples of s-t mincuts that are in left-right order. \n\n \nThe set U_lr^k, together with relation \u227c, defines a distributive lattice L^*. For any two elements C_1 = [X_1, \u2026, X_k] and C_2 = [Y_1, \u2026, Y_k] in L^*, the join and meet operations are given respectively by\n\n    C_1 \u2228 C_2 =     [S_max(X_1 \u222a Y_1), \u2026, S_max(X_k \u222a Y_k)],   and\n    \n        C_1 \u2227 C_2 =     [S_min(X_1 \u222a Y_1), \u2026, S_min(X_k \u222a Y_k)].\n\n\n \nThis follows directly from Lemma <ref> and the definition of product lattice (see Section <ref>). Let L^k = (U^k, \u227c) be the kth power of the lattice L = (\u0393_G(s, t), \u2264) of minimum s-t cuts, and let L^* = (U_lr^k, \u227c) with U_lr^k \u2286 U^k be the sublattice of left-right ordered k-tuples of minimum s-t cuts. We know from Section <ref> that since L is distributive, then so is the power lattice L^k. Moreover, any sublattice of a distributive lattice is also distributive. Hence, it follows that the lattice L^* is also distributive.\n\n\n\n\n \u00a7.\u00a7 Proof of Submodularity\n \nNow we prove that the functions d\u0302_sum and d\u0302_cov are submodular on the lattice L^*. \nWe start with \ntwo results that establish useful properties of the multiplicity function \u03bc_e(C) on L^* (see the corresponding proofs in Appendix <ref> and <ref>). \n\n \nThe multiplicity function \u03bc_e: U_lr^k \u2192\u2115 is modular on L^*.  \n\n\n\n\n[]lemmamultiplicityProperty \nFor any two C_1, C_2 \u2208 L^* and e \u2208 E(C_1) \u222a E(C_2), it holds that max(\u03bc_e(C_1 \u2228 C_2), \u03bc_e(C_1 \u2227 C_2)) \u2264max(\u03bc_e(C_1), \u03bc_e(C_2)).\n\n\n\n\n\n\n\n\n\n\n\n\nWith these results at our disposal, we \nprove the submodularity of our diversity objectives. \n\n\n\n\n  \nSubmodularity of d\u0302_sum. \nRecall the definition of d\u0302_sum(C) in (<ref>), and let B_e: U_lr^k \u2192\u2115 be the function defined by B_e(C) = \u03bc_e(C)2. We can rewrite (<ref>) as d\u0302_sum(C) = \u2211_e \u2208 E_shr(C) B_e(C). The following is a consequence of Lemmas <ref> and <ref> (see proof in Appendix <ref>).\n\n \nFor any two C_1, C_2 \u2208 L^* and e \u2208 E(G), we have \nB(C_1 \u2228 C_2) + B(C_1 \u2227 C_2) \u2264 B(C_1) + B(C_2).\n\n\nIn other words, the function B_e(C) is submodular in the lattice L^*. \nNow, recall that the sum of submodular functions is also submodular. Then, taking the sum of B_e(C) over all edges e \u2208 E(G) results in a submodular function. \nFrom here, notice that B_e(C) = 0 for unshared edges; that is, when \u03bc_e(C) < 2. This means that such edges do not contribute to the sum. It follows that, for any two C_1, C_2 \u2208 L^*, we have\n\n    \u2211_e \u2208 E_shr(C_1 \u2228 C_2)B_e(C_1 \u2228 C_2) + \u2211_e \u2208 E_shr(C_1 \u2227 C_2)B_e(C_1 \u2227 C_2) \u2264\u2211_e \u2208 E_shr(C_1)B_e(C_1) + \u2211_e \u2208 E_shr(C_2)B_e(C_2).\n\nObserve that each sum in the inequality corresponds to the definition of d\u0302_sum applied to the arguments C_1 \u2228 C_2, C_1 \u2227 C_2, C_1 and C_2, respectively. Hence, by definition of submodularity, we obtain our desired result. \n\n \nThe function d\u0302_sum: U_lr^k \u2192\u2115 is submodular on the lattice L^*.\n\n\n\n\n\n  \nSubmodularity of d\u0302_cov. Consider the function F_e(C) : U_lr^k \u2192\u2115 defined by F_e(C) = \u03bc_e(C)-1. It is an immediate corollary of Lemma <ref> that F_e(C) is modular in L^*. Then, the sum \u2211_e F_e(C) taken over all edges e \u2208 E(G) is still a modular function. Notice that only shared edges in C contribute positively to the sum, while the contribution of unshared edges can be neutral or negative. We can split this sum into two parts: the sum over shared edges e \u2208 E_shr(C), and the sum over e \u2208 E(G) \u2216 E_shr(C). The latter sum can be further simplified to |E(C)| - |E(G)| by observing that only the edges e \u2208 E(G) \u2216 E(C) make a (negative) contribution. Therefore, we can write\n\n    \u2211_e \u2208 E(G) F_e(C) = ( \u2211_e \u2208 E_shr(C)\u03bc_e(C) ) + |E(C)| - |E(G)|.\n\nWe know \u2211_e F_e(C) to be a modular function on L^*, hence for any two C_1, C_2 \u2208 L^* we have\n\n    \u2211_e \u2208 E(G) F_e(C_1 \u2228 C_2) + \u2211_e \u2208 E(G) F_e(C_1 \u2227 C_2) = \u2211_e \u2208 E(G) F_e(C_1) + \u2211_e \u2208 E(G) F_e(C_2),\n\nwhich, by equation <ref>, is equivalent to\n\n    ( \u2211_e \u2208 E_shr(C_1 \u2228 C_2)\u03bc_e(C_1 \u2228 C_2) + \u2211_e \u2208 E_shr(C_1 \u2227 C_2)\u03bc_e(C_1 \u2227 C_2) ) + |E(C_1 \u2228 C_2)| + |E(C_1 \u2227 C_2)| = \n       ( \u2211_e \u2208 E_shr(C_1)\u03bc_e(C_1) + \u2211_e \u2208 E_shr(C_2)\u03bc_e(C_2) ) + |E(C_1)| + |E(C_2)|.\n\nNow, from Lemmas <ref> and <ref>, we observe the following property (see proof in Appendix <ref>). \n\n \nFor any two C_1, C_2 \u2208 L^* we have |E(C_1 \u2228 C_2)| + |E(C_1 \u2227 C_2)| \u2265 |E(C_1)| + |E(C_2)|.\n\n\nGiven Claim <ref>, it is clear that to satisfy equality in equation (<ref>) it must be the case that: \n\n    \u2211_e \u2208 E_shr(C_1 \u2228 C_2)\u03bc_e(C_1 \u2228 C_2) + \u2211_e \u2208 E_shr(C_1 \u2227 C_2)\u03bc_e(C_1 \u2227 C_2) \u2264\u2211_e \u2208 E_shr(C_1)\u03bc_e(C_1) + \u2211_e \u2208 E_shr(C_2)\u03bc_e(C_2),\n\nfrom which the submodularity of d\u0302_cov immediately follows.\n\n \nThe function d\u0302_cov: U_lr^k \u2192\u2115 is submodular on the lattice L^*.\n\n\n\n\n \u00a7.\u00a7 Finding the Set of Join-Irreducibles\n \nWe now turn to the final part of the reduction to SFM. By Lemma <ref>, we know that the lattice L^* of left-right ordered collections of s-t mincuts is distributive. And it follows from Theorems <ref> and <ref> that the objective functions d\u0302_sum and d\u0302_cov are submodular in L^*. As discussed in Section <ref>, it only remains to find an appropriate (compact) representation of L^* in the form of its poset of join-irreducibles J(L^*). \n\nRecall the distributive lattice L of s-t mincuts of a graph G, defined in Lemma <ref>. The leftmost cut S_min(G) can be seen as the meet of all elements in L. In standard lattice notation, this smallest element is often denoted by 0_L := \u22c1_x \u2208 L x. We use the following result of Picard and Queyranne.\n\n \n    Let L be the distributive lattice of s-t mincuts in a graph G, there is a compact representation G(L) of L with the following properties: \n    \n        \n  * The vertex set is J(L) \u222a 0_L,\n        \n  * |G(L)| \u2264 |V(G)|,\n        \n  * Given G as input, G(L) can be constructed in F(n, m) + O(m) time. \n    \n\n\nIn other words, the set J(L) is of size O(n) and can be recovered from G in the time of a single max-flow computation. Moreover, each element of J(L) corresponds to an s-t mincut in G. In view of this lemma, we obtain the following for the poset of join-irreducibles J(L^*). \n\n \n    The set of join-irreducibles of L^* is of size O(kn) and is given by\n    \n  \n        J(L^*) = \u22c3_i = 1^k J_i, where J_i := {(0_L, \u2026, 0_L_i-1  times, p, \u2026, p_k-i+1  times)  :   p \u2208 J(L)}.\n    \n\n\n\nWe know that for an element x \u2208 L^* such that x \u2260 0_L, by definition of join-irreducible, x \u2208 J(L^*) if and only if x has a single immediate predecessor in L^*. To prove our claim, we show that (i) the k-tuples J_i, with 1 \u2264 i \u2264 k, are in L^* and satisfy this property, and (ii) that no other tuple in L^* satisfies it. \n    \n    For (i), let C(i, p) denote the k-tuple (0_L, \u2026, 0_L, p, \u2026, p) \u2208 J_i, where the first i-1 entries contain 0_L and the remaining k-i+1 entries contain the element p, with i \u2208 [k] and p \u2208 J(L). It is clear that C(i, p) \u2208 L^*since each entry in C(i, p) is an s-t mincut, and 0_L \u2264 X for any X \u2208\u0393_s, t(G). \n    Consider now the arbitrary element p \u2208 J(L), and let q denote the immediate predecessor of p in J(L) (with q = 0_L if p has no predecessors). We claim that the k-tuple Q(i, q, p) := (0_L, \u2026, 0_L, q, p, \u2026, p) obtained from C(i, p) by replacing its ith entry with element q, is the unique immediate predecessor of C(i, p). This follows because: (a) replacing any other entry of C(i, p) with q results in a tuple that violates the left-right order, (b) any other choice of q either violates the order or has the tuple Q(i, q, p) as a successor, and (c) replacing any subsequence of ps by qs in C(i, p) has the same consequences as (b).[There is also the case where all ps are replaced by a q such that q > p, but it is clear that no such tuple can be a predecessor of C(i, p).] Since this holds for all i\u2208 [k] and arbitrary p, it follows that each tuple in J(L^*) has a single immediate predecessor. \n\n    It remains to show (ii); that is, that there is no tuple in L^* \u2216\u22c3_i = 1^k J_i which is also a join-irreducible of L^*. For the sake of contradiction, assume that such a tuple T exists in L^*. There are two possibilities for T: (1) T contains more than 2 elements from the set J(L), and (2) T contains no elements from J(L). \n    \n    Consider case (2) first, and let \u03b3 be the kth entry in T. Since \u03b3\u2209J(L), then it has more than one immediate predecessor in L. Let \u03b1 and \u03b2 be two such predecessors (notice that \u03b1 and \u03b2 are incomparable). Then, we can construct two distinct tuples T_1 \u2208 L^* and T_2 \u2208 L^* from T by replacing \u03b3 by \u03b1 and \u03b2, respectively. But T_1 and T_2 are both immediate predecessors of T in L^*, which gives the necessary contradiction. \n\n    Case (1) follows a similar argument. Suppose a, b, c \u2208 J(L) are the last three entries in tuple T; where a < b < c. Let p(c), p(b) \u2208 J(L) be the immediate predecessors of elements c and b, respectively. Notice that a \u2264 p(b) and b \u2264 p(c). Then, like before, we can construct two distinct tuples T_1 \u2208 L^* and T_2 \u2208 L^* from T by replacing c by p(c) and b by p(b), respectively. It is clear that T_1 and T_2 are both immediate predecessors of T in L^*, which once more results in a contradiction. \n\n    From (i) and (ii) above, we have thus shown that the set of join-irreducibles J(L^*) is given by \u22c3_i = 1^k J_i. To conclude the proof, we look at the size of J(L^*). First, observe that the index i runs from 1 to k. Also, by Lemma <ref> we know that |J(L)| = O(n). It then follows that |J(L^*)| = O(kn).\n\n\nGiven Lemma <ref>, a compact representation of the lattice L^* can be obtained as the directed graph G(L^*) that characterizes its poset of join-irreducibles J(L^*) in polynomial time (since |J(L^*)| is polynomial). It is also clear that the functions d\u0302_sum and d\u0302_cov can be computed in polynomial time. Then, by Theorem <ref>, together with Theorems <ref>, <ref> and <ref>, the reduction to SFM is complete. \n\n*\n\nTo give a precise running time bound, we can use Jiang's algorithm <cit.> for minimizing a submodular function on sets. The total running time of our algorithm is O(|U|^3 T_EO), where |U| = O(k n) is the size of the ground set J(L^*), and T_EO = O(k^2 n^2) is the time required to evaluate the analogue function on \ud835\udc9f(J(L^*)) of the function d\u0302_sum (resp. d\u0302_cov) on L^*. The graph representation of the poset J(L^*) can be constructed within the same time bounds since |G(L^*)| = O(k^2n^2). Thus, we get the following result (see Appendix <ref> for a detailed derivation of the time bound.)\n\n[]theorempreciseruntime\n    Sum-k-DMC and Cov-k-DMC can be solved in O(k^5n^5) time.\n\n\n\n\n\u00a7 A SIMPLE ALGORITHM FOR FINDING DISJOINT MINIMUM S-T CUTS\n\n\nIn the previous section, we looked at the problem of finding the k most diverse minimum s-t cuts in a graph. Here, we consider a slightly different problem. Observe that for diversity measures d_sum and d_cov, the maximum diversity is achieved when the elements of a collection are all pairwise disjoint. Thus, it is natural to ask for a maximum cardinality collection of s-t mincuts that are pairwise disjoint; i.e., that are as diverse as possible. We call this problem Maximum Disjoint Minimum s-t Cuts (or Max-Disjoint MC for short). \n\n[Max-Disjoint MC] \nGiven a graph G = (V, E) and vertices s,t \u2208 V(G), find a set S \u2286\u0393_G(s, t) such that X \u2229 Y = \u2205 for all X, Y \u2208 S, and |S| is as large as possible. \n\n\nNow, recall k-Disjoint Minimum s-t Cuts from Section <ref>. Observe that one can easily obtain a solution to this problem by simply returning any k-sized subset of cuts from a solution to Max-Disjoint MC. Hence, any algorithm for Max-Disjoint MC can be used to solve k-Disjoint Minimum s-t Cuts within the same time bound. In this section, we prove Theorem <ref> by giving an algorithm for Max-Disjoint MC that runs in O(F(m, n) + \u03bb(G)m) time, where F(m, n) is the time required by a max-flow computation. First, we look at a restricted case when the input graph can be decomposed into a collection of edge-disjoint s-t paths and (possibly) some additional edges\u2014we refer to such a graph as an s-t path graph\u2014and devise an algorithm that handles such graphs. Then, we use this algorithm as a subroutine to obtain an algorithm that makes no assumption about the structure of the input graph. \n\n\n\n \u00a7.\u00a7 When the input is an s-t path graph\n\n\n\n\n\n\n\n\n\nLet H_s,t be a graph with designated vertices s and t. We call H_s,t an s-t path graph (or path graph for short) if there is a collection of edge-disjoint s-t paths P such that P covers all vertices in V(H_s,t); see Figure <ref> for an illustration. The height of H_s,t, denoted by \u03bb(H_s,t), is the maximum number of edge-disjoint s-t paths in the graph. For fixed P, we call the edges of H_s,t in P path edges and edges of H_s,t not in P non-path edges. Two vertices in H_s,t are path neighbors if they are joined by a path edge, and non-path neighbors if they are joined (exclusively) by a non-path edge. \n\n\n\n\nTwo remarks are in order. The first is that, by Menger's theorem, the size of a minimum s-t cut in an s-t path graph coincides with its height. The second remark is that, from a graph G, one can easily obtain a path graph H_s,t of height \u03bb(G) by finding a maximum-sized set \ud835\udcab_s,t(G) of edge-disjoint s-t paths in G and letting H_s,t be the induced subgraph of their union. Recall that, by Menger's theorem, a minimum s-t cut in G must contain exactly one edge from each path p \u2208\ud835\udcab_s,t(G). Thus, every minimum s-t cut of G is in H_s,t. However, the reverse is not always true. In the above construction, there could be multiple new minimum s-t cuts introduced in H_s, t that arise from ignoring the reachability between \nvertices of \ud835\udcab_s,t(G) in G. \nWe will come back to this issue when discussing the general case in Section <ref>. \n\n\n\n  \nThe algorithm.\n\nThe goal in this subsection is to find a maximum cardinality collection \u0108 of pairwise disjoint s-t mincuts in a path graph H_s, t. \nWe now explain the main ideas behind the algorithm. Without loss of generality, assume that the underlying set of edge-disjoint s-t paths that define H_s,t is of maximum cardinality. \nTo simplify notation, here we denote such set \ud835\udcab_s, t(H_s,t) simply by \ud835\udcab_s, t. \n\nLet X be an s-t mincut in H_s,t, and suppose we are interested in finding an s-t mincut Y disjoint from X such that X < Y. Consider any two edges e = (u, u') and f = (v, v') in X, and let g = (w, w') be a path successor of f; that is f \u227a_p  g with p \u2208\ud835\udcab_s,t. If there is a non-path edge h = (u', z) such that w' \u2264 z, we say that h is crossing with respect to g, and that g is invalid with respect to X (see Figure <ref> for an illustration).\n\n\n\nThe notions of crossing and invalid edges provide the means to identify the edges that cannot possibly be contained in Y. Let E_inv(X) denote the set of invalid edges with respect to X. We make the following observation. \n \n \nLet Y > X. Then Y cannot contain an edge from E_inv(X).\n\n\n    For the sake of contradiction, suppose there exists and edge g=(w,w') in E_inv(X)\u2229 Y. Consider the path p_1 \u2208\ud835\udcab_s,t, and let f be the predecessor of g on p_1 that is in X. Since g \u2208 E_inv(X), there is a crossing edge h=(u',z) with respect to g. Let p_2 \u2208\ud835\udcab_s,t be the path containing u', and let (u,u') be the edge of p_2 that is in X. Let p_3 be the s-t path that follows p_2 from s to u, then follows the crossing edge h, and then continues along p_1 to t. Since Y is an s-t cut it must contain an edge from this path. Since Y must contain exactly one edge from each path in \ud835\udcab_s,t, it cannot contain h. Moreover, Y already contains edge g from p_1. Then Y must contain an edge from the part of p_2 from s to u'. But this contradicts that Y>X. \n\n\nIf we extend the definition of E_inv(X) to also include all the edges that are path predecessors of edges in X, we immediately obtain the following key property. \n \n    For any s-t path p \u2208\ud835\udcab_s,t, the poset E_inv(X) \u2229 p with order relation given by path-distance from s is an ideal of the set E(p) of edges of p.  \n\n\nObservation <ref> implies that if we can identify the (extended) set E_inv(X), then we can restrict our search of cut Y to only the set of valid edges E_val(X):= E(H_s,t) \u2216 E_inv(X). \nThis, in turn, motivates the following iterative algorithm for finding a pairwise disjoint collection of s-t mincuts: Find the leftmost s-t mincut X in H_s,t. Identify the set E_inv(X) and find the leftmost s-t mincut Y amongst E_val(X). Set X = Y and repeat the previous step until E_val(X) \u2229 p = \u2205 for any one path p \u2208\ud835\udcab_s,t. Output the union of identified cuts as the returned collection \u0108. \n\nNotice that the s-t mincut identified at iteration i is a (strict) successor of the mincuts identified at iterations j < i. Hence, the returned collection will consist of left-right ordered and pairwise disjoint s-t mincuts. Moreover, picking the leftmost cut at each iteration prevents the set of invalid edges from growing unnecessarily large, which allows for more iterations and thus, a larger set returned. Next, we give a more formal description of the algorithm, the details of which are presented in Algorithm <ref>.  \n\n\n\nThe algorithm works by traversing the graph from left to right in iterations while marking the vertices it visits. Initially, all vertices are unmarked, except for s. Each iteration consists of two parts: a marking step, and a cut-finding step. In the marking step (Lines 3-9), the algorithm identifies currently invalid edges by marking the non-path neighbors\u2014and their path-predecessors\u2014of currently marked vertices. (Observe that a path edge becomes invalid if both of its endpoints are marked.) In Algorithm <ref>, this is realized by a variable M that keeps track of the vertices that have just been marked as a consequence of the marking of vertices previously present in M.\n\nIn the cut-finding step (Lines 10-14), the algorithm then finds the leftmost minimum s-t cut amongst valid path edges. Notice that, for each s-t path in \ud835\udcab_s,t, removing its first valid edge prevents s from reaching t via that path. This means that our leftmost cut of interest is simply the set of all path edges that have exactly one of their endpoints marked. Following the identification of this cut, the step concludes by marking the head vertices of the identified cut edges. \nFinally, the algorithm terminates when the target vertex t is visited and marked. See Figure <ref> for an example execution of the algorithm. \n\n \n\nWe now make the following claim about the complexity of the algorithm, followed by an analysis of its correctness. \n\n \nThe complexity of Algorithm <ref> on an m-edge, n-vertex path graph is O(m log n). \n \n\nLet H_s,t be our input path graph. First, notice that each vertex v \u2208 H_s, t is visited at most deg(v) times by the algorithm. This follows from the fact that v is only visited whenever one of three cases occurs: (i) v is reachable by a marked vertex via a non-path edge (Line 6), (ii) v is a predecessor of a marked vertex u on a path p \u2208\ud835\udcab_s,t (Line 8), or (iii) v is the head node of an identified minimum s-t cut (Line 12). \nWe know that v can be the endpoint of at most deg(v) - 2 non-path edges. Similarly, v can be the endpoint of at most 2 path edges. Since a vertex cannot be reached again by a previously traversed edge, the remark follows. \n\nNow, observe that each time a vertex is visited, the algorithm performs only O(1) work, except for the step in Line 6 where each currently marked vertex v \u2208 M must identify its rightmost neighbor on each path in \ud835\udcab_s,t. We can assume that each vertex v \u2208 H_s,t is equipped with a data structure A_v that given a query path p \u2208 P(H_s, t), can answer in O(log n) time which is the rightmost neighbor u of v in p.[If we are willing to forego worst-case complexity for amortized complexity, we can assume a data structure with constant insert and query complexity via hash tables.] Therefore, as the algorithm performs O(log n) work each time it visits a vertex v \u2208 H_s,t, and it does so at most deg(v) times, the claim would follow. It only remains to analyze the preprocessing time of equipping the graph with such data structures. \n\nWe claim that the graph can be preprocessed in O(m log n) time as follows. Assume that each node u \u2208 H_s,t has two variables path(u) and pos(u) which store the path to which it belongs and its position in said path, respectively. \nFirst, for each vertex v \u2208 H_s,t we initialize an empty list A_v of tuples of the form (a, b). Then, for each neighbor u of v, query the list A_v for the tuple (x, y) such that x = path(u). If it exists and pos(u) > y, set y = pos(u). If it does not exist, then create the tuple (path(u), pos(u)) and insert it in A_v in sorted order (by path). Since A_v can be of size at most \u03bb(H_s, t), it is clear that querying and inserting can be implemented in O(log (H_s, t)) time by binary search. Equipping each vertex with these lists then requires O(deg(v) \u00b7log (H_s. t)) time per vertex. Thus, the total preprocessing time is O(m log (\u03bb(H_s,t))), which can be simplified to O(m log n).\n\n\n\n\n  \nCorrectness of Algorithm <ref>. \nWe note an important property of collections of s-t mincuts. \n(We use d(C) to denote any of d_sum(C) or d_cov(C).)\n\n \nLet C be a left-right ordered collection of minimum s-t cuts in a graph G, the collection C\u0303 obtained by replacing S_min(\u22c3_X \u2208 C X) with S_min(G) has cost d(C\u0303) \u2264 d(C). \n\n\nFor simplicity, let us denote S_min(C) := S_min(\u22c3_X \u2208 C X). By definition, we know that no edge of \u22c3_X \u2208 C X lies to the left of S_min(G). Then replacing S_min(C) with S_min(G) can only decrease the number of pairwise intersections previously present between S_min(C) and the cuts in C \u2216 S_min(C). Notice that our measures of diversity only penalize edge intersections. Hence, the cost of collection C\u0303 cannot be greater than that of C.\n\n\nNow, consider an arbitrary collection of k edge-disjoint s-t mincuts in a path graph H_s,t. Corollary <ref> implies that there also exists a collection of k edge-disjoint s-t mincuts in H_s,t that is in left-right order. In particular, this is true for a collection of maximum cardinality k_max. Together with Claim <ref>, this means that there always exists a collection \u0108 of edge-disjoint s-t mincuts in H_s, t with the following properties: \n\n    \n  * \u0108 has size k_max, \n    \n  * \u0108 is in left-right order, and  \n    \n  * \u0108 contains the leftmost minimum s-t cut of H_s, t. \n\nWe devote the rest of the subsection to proving the following lemma, which serves to prove the correctness of Algorithm <ref>. \n\n \nAlgorithm <ref> returns a collection of edge-disjoint minimum s-t cuts that satisfies Properties <ref>\u2013<ref>.\n\n\nLet \u0108 denote the solution returned by the algorithm. First we show that \u0108 contains only disjoint cuts. This follows from the fact that a cut can only be found amongst valid edges at any given iteration, and once an edge has been included in a cut, it becomes invalid at every subsequent iteration. Similarly, Properties <ref> and <ref> are consequences of the notion of invalid edges. We start by proving the latter. Let X_1 denote the leftmost cut in \u0108. For the sake of contradiction, assume there is a minimum s-t cut Y such that e \u227a_p  f. Here, e \u2208 Y, f \u2208 X_1 and w.l.o.g. p is an s-t path from any arbitrary maximum collection of s-t paths in H_s,t. For the algorithm to pick edge f = (u, u') as part of X_1 it must be that vertex u is marked and u' is not. We know that the predecessors of marked vertices must be also marked. Hence we know that both endpoints of edge e are marked. But by definition, this means that edge e is invalid, and cannot be in a minimum s-t cut. This gives us the necessary contradiction, and X_1 must be the leftmost cut in the graph. We continue with Property <ref>. This property follows from the fact that, at any given iteration, the posets of invalid path-edges on each path of H_s,t are ideals of the set of path edges. This means that the edges in the cut found by the algorithm at iteration i are all path predecessors of an edge in the cut found at iteration i+1. It only remains to show Property <ref>, which states that collection \u0108 is of maximum cardinality k_max. For this, we make the following claim, whose proof is analogous to the proof of Property <ref>. \n\n \nConsider set \u0108_i-1 and let X_i be the minimum s-t cut found by the algorithm at iteration i. Then, there is no minimum s-t cut Y such that: (i) Y is disjoint from each X \u2208 C_i-1, and (ii) Y contains an edge that is a path predecessor of an edge of X_i.\n\n\nIn other words, as the algorithm makes progress, no minimum s-t cut\u2014that is disjoint from the ones found so far by the algorithm\u2014has edges to the left of the minimum s-t cut found by the algorithm at the present iteration. Next we show that this implies the maximality of the size of the solution returned by the algorithm. \n\nLet C_max be a maximum-sized collection of s-t mincuts in the graph. Without loss of generality, assume that C_max is in left right order (otherwise, by Corollary <ref> we can always obtain an equivalent collection that is left-right ordered). For the sake of contradiction, suppose that the collection \u0108 returned by our algorithm is not of maximum cardinality. We make the following observation about the interaction between cuts in \u0108 and C_max.\n\n \nThe collections \u0108 and C_max satisfy the following properties: \n\n    \n  * Every cut of \u0108 intersects with at least one cut of C_max. \n    \n  * At least |\u0108| many cuts of C_max intersect with at least one cut of \u0108. \n\n\n\nProperty <ref> is valid since we could otherwise increase the size of C_max by extending the collection with the non-intersecting cuts from \u0108. Similarly, Property <ref> holds as we could otherwise extend C_max by replacing the less-than-|\u0108| many cuts from C_max that intersect with \u0108, with the set of |\u0108| cuts that they intersect with.\n\n\nBy Observation <ref> and the pigeonhole principle, there must exist at least one minimum s-t cut Y \u2208 C_max such that X_i-1 < Y \u2264 X_i, with X_i-1 and X_i two consecutive cuts in \u0108. Thus, Y is disjoint from X_i-1 and all the cuts preceding it. That is, Y is disjoint from each cut in C_i-1. On the other hand, Y \u2264 X_i implies that Y has edges that are path predecessors of edges in X_i. (Notice that Y cannot entirely overlap with X_i, as otherwise, it would intersect with another cut in C_max.) But by Claim <ref>, we know that such a cut cannot exist. Hence, we obtain a contradiction, and the collection \u0108 returned by the algorithm must be of maximum cardinality. This completes the proof of Lemma <ref>. \n\n\n\n \u00a7.\u00a7 Handling the general case\n \n\nWe now consider Max-Disjoint MC in general graphs. Recall from the previous subsection that, from a graph G, one can construct a path graph H_s, t such that every minimum s-t cut in G is also a minimum s-t cut in H_s, t. Ideally, we would like to use Algorithm <ref> in H_s, t to solve Max-Disjoint MC in G. But, as we argued, the path graph H_s,t may not have the same set of s-t mincuts as G. Here we show that H_s,t can be augmented with edges such that its minimum s-t cuts correspond bijectively to those in G, which serves to solve the general problem. \n\n \nAn augmented s-t path graph of G is the subgraph H_s,t(G) induced by the set V(\ud835\udcab_s,t(G)), with additional \nedges between any two vertices u, v \u2208 V(H_s,t(G)) \nif v is reachable from u in G by a path whose internal vertices are exclusively in V(G) \u2216 V(H_s,t(G)). \n\n\nIn view of this definition, the following claim and lemma serve as the correctness and complexity proofs of the proposed algorithm for the general case (see proofs in Appendix <ref>). \n\n \nAn augmented s-t path graph of G has the same set of s-t mincuts as G. \n\n\n \nAn augmented s-t path graph H of a graph G can be constructed in time O(F(m, n) + m\u03bb(G)), where F(m, n) is the time required by a max-flow computation.\n\n\nThe following is an immediate consequence of Lemma <ref> and Claim <ref>. \n\n \nThere is an algorithm that, given a graph G and two specified vertices s, t \u2208 V(G), in O(F(m, n) + m\u03bb(G)) time finds a collection of maximum cardinality of pairwise disjoint s-t mincuts in G. \n\n\nBy replacing F(m, n) in Corollary <ref> with the running time of the current best algorithms of <cit.> for finding a maximum flow, we obtain the desired running time of Theorem <ref>.\n\n\n\n\u00a7 CONCLUDING REMARKS\n\nWe showed that the k-Diverse Minimum s-t Cuts problem can be solved efficiently when considering two natural measures for the diversity of a set of solutions. There exist, however, other sensible measures of diversity. One that often arises in literature is the bottleneck objective. In our context, it consists of maximizing the minimum pairwise Hamming distance of a collection of s-t mincuts. The complexity of k-DMC when considering the bottleneck objective is still open. The challenge of extending our approach to this measure is that it is not immediately clear how to apply our ordering results to this variant of k-DMC.  \n\nFor the special case of finding pairwise-disjoint collections of s-t mincuts, we showed that faster algorithms exist when compared to solving k-DMC for the total-sum and coverage diversity measures. It is thus natural to ask whether there are faster algorithms for Sum-k-DMC and Cov-k-DMC (or other variants of k-DMC) that do not require the sophisticated framework of submodular function minimization. In this work, we relied on the algebraic structure of the problem to obtain a polynomial time algorithm. We believe it is an interesting research direction to assess whether the notion of diversity in other combinatorial problems leads to similar structures, which could then be exploited for developing efficient algorithms. \n\n\n\n\u00a7 ACKNOWLEDGEMENT\n\nWe thank Martin Frohn for bringing the theory of lattices to our attention, and for fruitful discussions on different stages of this work. \n\nThis research was supported by the European Union\u2019s Horizon 2020 research and innovation programme under the Marie Sk\u0142odowska-Curie grant agreement no. 945045, and by the NWO Gravitation project NETWORKS under grant no. 024.002.003.\n\n\n\n\n\n\u00a7 PROOFS OF SECTION <REF>\n \n\n\n\n \u00a7.\u00a7 Proof of Proposition <ref>\n \nBefore proving the proposition, we require the following claim. \n\n \nFor any X, Y \u2208\u0393_G(s, t), we have S_min(X \u222a Y), S_max(X \u222a Y) \u2208\u0393_G(s, t) and |S_min(X \u222a Y) \u2229 S_max(X \u222a Y)| = |X \u2229 Y|.\n\n\nWithout loss of generality, let \ud835\udcab_s,t(G) be any maximum-sized set of edge-disjoint paths from s to t. Recall that, by Menger's theorem, any minimum s-t cut in G contains exactly one edge from each path in \ud835\udcab_s,t(G).\nThus, for a path p \u2208\ud835\udcab_s,t(G), let e, f \u2208 p be the edges that intersect with cuts X and Y, respectively. Then the set S_min(X \u222a Y) can be seen as the subset of X \u222a Y where e \u2208 S_min(X \u222a Y) if e \u2264 f, for each path p \u2208\ud835\udcab_s,t(G). Analogous for S_max(X \u222a Y). \n\nWe want to prove that S_min(X \u222a Y) (resp. S_max(X \u222a Y)) is an s-t cut[Notice that the size of S_min(X \u222a Y) (resp. S_max(X \u222a Y)) is already minimum, as it contains exactly one edge from each path p \u2208\ud835\udcab_s,t(G), which has cardinality \u03bb.], and that |S_min(X \u222a Y) \u2229 S_max(X \u222a Y)| = |X \u2229 Y|. For the latter, simply observe that whenever X and Y intersect at an edge e, by Menger's theorem, the path p \u2208\ud835\udcab_s,t(G) that contains e contains no other edge f from X \u222a Y. Thus, by \ndefinition, the edge e will be contained by both S_min(X \u222a Y) and S_max(X \u222a Y). On the other hand, if S_min(X \u222a Y) and S_max(X \u222a Y) intersect at an edge e'; by definition, the path from \ud835\udcab_s,t(G) containing e' cannot include another edge from X \u222a Y, since either S_min(X \u222a Y) or S_max(X \u222a Y) would contain it, which we know is not the case. Thus, e' \u2208 X \u2229 Y, and the second part of the claim is proven. \n\nNow we show that S_min(X \u222a Y) and S_max(X \u222a Y) are s-t cuts. We only prove this for S_min(X \u222a Y) since the proof for S_max(X \u222a Y) is analogous. For the sake of contradiction, suppose that S_min(X \u222a Y) is not an s-t cut. Then, there exists an s-t path \u03c0 = (s, \u2026, t) in G that does not contain en edge from S_min(X \u222a Y). This means that \u03c0 has a subpath \u03c0^* = (v_1, \u2026, v_2) satisfying v_1 \u2264_p w and w' \u2264_q v_2, where w and w' are, respectively, the head and tail nodes of two (not necessarily distinct) edges e, f \u2208 S_min(X \u222a Y), and p, q \u2208\ud835\udcab_s,t(G). \nIn other words, there exists a path \u03c0^* starting at a node v_1 which appears before an edge e \u2208 S_min in a path p \u2208\ud835\udcab_s,t(G), and ending at a node v_2 that appears after an edge f \u2208 S_min in a path q \u2208\ud835\udcab_s,t(G).   \nIt follows that edge f in path q can never be in an s-t cut together with an edge in path p that is to the right of (and including) edge e (unless an edge from \u03c0 is also cut, but then the cut is not of minimum size). But, since e \u2208 S_min(X \u222a Y), we know that e is the leftmost edge from X \u222a Y in path p. Therefore, f \u2209X \u222a Y, otherwise neither X nor Y would be cuts. But we know that f \u2208 S_min(X \u222a Y), which means f \u2208 X \u222a Y, and we reach a contradiction. Thus, the set S_min(X \u222a Y) is a minimum s-t cut, and the claim is proven. \n\n\nWe now prove Proposition <ref>. We restate it here for the convenience of the reader. \n\n*\n\nWe prove this by giving an algorithm that takes any k-tuple C \u2208 U^k \nto a k-tuple \u0108\u2208 U^k_lr that is in left-right order. The algorithm can be seen in Algorithm <ref>. \n\n\nWe have to verify that for any k-tuple C, the algorithm \nproduces a k-tuple \u0108 that is in left-right order, and that \u03bc_C(e) = \u03bc_\u0108(e) for all e \u2208 E(G). \nTo prove \n\nthe latter, \nnotice that at iteration i of the algorithm, the two cuts X_i and X_j are replaced by S_min(X_i \u222a X_j) and S_max(X_i \u222a X_j), respectively. By definition, S_min(X_i \u222a X_j) \u222a S_max(X_i \u222a X_j) = X_i \u222a X_j and, by Claim <ref>, we know that X_i \u2229 X_j = S_min(X_i \u222a X_j) \u2229 S_max(X_i \u222a X_j). Therefore, the multiplicity of the edges e \u2208 E(G) remains invariant at every iteration. It then follows that the k-tuple \u0108 = LRO(C) output by the algorithm contains the same set of edges as the input tuple; each of them preserving its multiplicity. \n\nIt remains to show that \u0108 is in left-right order. First, notice that \u0108 iterates over every pair of indices (i, j) such that i < j. Furthermore, the algorithm sees such a pair only once. Now, assume that \u0108 is not in left-right order. Then, it contains a pair (X_i, X_j) of incomparable (crossing) cuts; but this cannot be the case, as these would have been replaced by S_min(X_i \u222a X_j) and S_max(X_i \u222a X_j) at iteration (i, j). Therefore \u0108 is in left-right order[Alternatively, one can see that cut X_i at the end of the inner loop satisfies that X_i \u2264 X_j for all i < j; hence, at iteration i of the outer loop the algorithm finds a cut X\u0302_i to the right of X\u0302_i-1 that is leftmost with respect to X\u0302_j for all i < j. That is, X_i-1\u2264 X_i \u2264 X_j for all i \u2208 [k] and i < j.] and the proposition is proved. \n\n\n\n\n \u00a7.\u00a7 Proof of Lemma <ref>\n \nLet C_1 = [X_1, \u2026, X_k] and C_2 = [Y_1, \u2026, Y_k] be distinct elements in the lattice L^* = (U_lr^k, \u227c). \nFor a fixed edge e \u2208 E(G), we are interested in \u03bc_e(C_1 \u2228 C_2) + \u03bc_e(C_1 \u2227 C_2). For this purpose, consider the set of indices P = {1, \u2026, k}. We partition P into four parts: (i) P_1 = {i   :   e \u2209 X_i \u222a Y_i}, (ii) P_2 = {i   :   e \u2208 X_i, e \u2209 Y_i}, (iii) P_3 = {i   :   e \u2209 X_i, e \u2208 Y_i} and (iv) P_4 = {i   :   e \u2208 X_i \u2229 Y_i}. \nWe claim that \u03bc_e(C_1 \u2228 C_2) + \u03bc_e(C_1 \u2227 C_2) = |P_2| + |P_3| + 2|P_4|. This follows because on the one hand, by definition, the edge e must appear in either S_min(X_i \u222a Y_i) or S_max(X_i \u222a Y_i) for each i \u2208 P_2 \u222a P_3. On the other hand, the edge e appears in both S_min(X_i \u222a Y_i) and S_max(X_i \u222a Y_i) for every i \u2208 P_4, since there is no edge f \u2208 X_i \u222a Y_i on the same s-t path p as e such that f \u2264_p e or e \u2264_p f (otherwise it could not be that e \u2208 X_i \u2229 Y_i). \nNow, observe that from the way we partitioned the set P, we have \n\u03bc_e(C_1) = |P_2| + |P_4| and \u03bc_e(C_2) = |P_3| + |P_4|. Combining this with our previous claim, we obtain \u03bc_e(C_1 \u2228 C_2) + \u03bc_e(C_1 \u2227 C_2) = \u03bc_e(C_1) + \u03bc_e(C_2). \nBy definition of modularity, the multiplicity function \u03bc_e is thus modular on the lattice L^* for any edge e \u2208 E(G). \n\n\n\n \u00a7.\u00a7 Proof of Lemma <ref>\n \nWe require the following proposition. \n\n \nFor any C = [X_1, \u2026, X_k] in L^*, the edge e \u2208 E(C) appears in every cut of a contiguous subsequence C' = [X_i, \u2026, X_j] of C, 1 \u2264 i \u2264 j \u2264 k, with size |C'| = \u03bc_e(C).\n\n\n    The case when \u03bc_e(C) = 1 is trivial. Next, we prove the case when \u03bc_e(C) \u2265 2. By contradiction, suppose that e does not appear in a contiguous subsequence of C. Then, there exists some cut X_h \u2208 C with i < h < j such that e \u2208 X_i, e \u2209X_h, and e \u2208 X_j. We know that collection C is in left-right order, thus we have that X_i \u2264 X_j for every i < j. Now, from e \u2208 X_i, it follows that e is a path-predecessor of en edge f in X_h. But from e \u2208 X_j, edge e must also be a path-successor of f. The edges e and f cannot be equal since e \u2209X_h, thus we get the necessary contradiction.\n\n\n  \nBy Proposition <ref>, we can represent the containment of an edge e in a collection C \u2208 L^* as an interval I_e(C) = (i, j), where i \u2264 j, of length \u03bc_e(C) defined on the set of integers {1, \u2026, k}. In this interval representation, the elements of I_e(C) correspond bijectively to the positions of the cuts in C that contain edge e. This will be useful in the proofs of Lemma <ref> and Claim <ref>. \n\n\n\n\nWe are now ready to prove Lemma <ref>. We restate it here for the reader's convenience. \n\n*\n\nWe prove this by case distinction on the containment of e in E(C_1) \u222a E(C_2). There are three cases: e \u2208 E(C_1) \u2216 E(C_2), e \u2208 E(C_2) \u2216 E(C_1), and e \u2208 E(C_1) \u2229 E(C_2). \n\n   \n  Case 1: e \u2208 E(C_1) \u2216 E(C_2). \n   We prove this case by contradiction. Assume that max(\u03bc_e(C_1 \u2228 C_2), \u03bc_e(C_1 \u2227 C_2)) > \u03bc_e(C_1). By Lemma <ref>, we know that \u03bc_e(C_1 \u2228 C_2) + \u03bc_e(C_1 \u2227 C_2) = \u03bc_e(C_1). W.l.o.g., we can assume that \u03bc_e(C_1 \u2227 C_2) > \u03bc_e(C_1 \u2228 C_2). This implies that \u03bc_e(C_1 \u2228 C_2) < 0, which is a contradiction. Hence, it must be that max(\u03bc_e(C_1 \u2228 C_2), \u03bc_e(C_1 \u2227 C_2)) \u2264\u03bc_e(C_1).\n   \n  Case 2: e \u2208 E(C_2) \u2216 E(C_1). \n   This case is symmetrical to Case 1, hence is already proven. \n   \n  Case 3: e \u2208 E(C_1) \u2229 E(C_2).\n   To prove that the statement is true in this case, it is convenient to consider the interval representation of edge e in E(C_1) and E(C_2). Let I_e(C_1) = (\u03b1, \u03b2) and I_e(C_2) = (\u03c3, \u03c4) be such intervals as defined by Remark <ref>. There are two subcases to consider: I_e(C_1) \u2229 I_e(C_2) = \u2205, and I_e(C_1) \u2229 I_e(C_2) \u2260\u2205. \n   \n       \n  Subcase 3.1. We claim that max(\u03bc_e(C_1 \u2228 C_2), \u03bc_e(C_1 \u2227 C_2)) = max(\u03bc_e(C_1), \u03bc_e(C_2)) holds in this subcase. To see this, w.l.o.g., suppose that \u03b2 < \u03c3. Then, because C_2 is in left-right order, the cuts of C_2 in the interval (\u03b1, \u03b2) each contain a path-predecessor of edge e. Then, by definition of the join operation in L^*, we have I_e(C_1 \u2228 C_2) = (\u03b1, \u03b2). Similarly, the cuts of C_1 in the interval (\u03c3, \u03c4) each contain a path-successor of e. Hence, by the meet operation in L^*, we have I_e(C_1 \u2227 C_2) = (\u03c3, \u03c4). Taking the length of the intervals, we obtain \u03bc_e(C_1 \u2228 C_2) = \u03bc_e(C_1) and \u03bc_e(C_1 \u2227 C_2) = \u03bc_e(C_2), from which the claim follows. \n       \n  Subcase 3.2. We have two further subcases to consider: I_e(C_1) \u2288I_e(C_2) (or I_e(C_2) \u2288I_e(C_1)), and I_e(C_1) \u2286 I_e(C_2) (or vice versa). \n       \n           \n  Subcase 3.2.1.\n           The proof of this subcase is analogous to the proof of subcase (3.1), where we also obtain that max(\u03bc_e(C_1 \u2228 C_2), \u03bc_e(C_1 \u2227 C_2)) = max(\u03bc_e(C_1), \u03bc_e(C_2)). \n           \n  Subcase 3.2.2.\n           W.l.o.g., suppose that I_e(C_2) \u2286 I_e(C_1) (see Figure <ref> for an illustration). Then \u03b1\u2264\u03c3\u2264\u03c4\u2264\u03b2. Again, by definition of join and meet, we have that I_e(C_1 \u2228 C_2) = (\u03b1, \u03c4) and I_e(C_1 \u2227 C_2) = (\u03c3, \u03b2). Now, since \u03c4 - \u03b1\u2264\u03b2 - \u03b1 and \u03b2 - \u03c3\u2264\u03b2 - \u03b1, we obtain max(\u03bc_e(C_1 \u2228 C_2), \u03bc_e(C_1 \u2227 C_2)) \u2264max(\u03bc_e(C_1), \u03bc_e(C_2)), which is what we wanted.\n       \n   \n\n\nSince the claim is true for all cases covered and all cases have been considered, the claim is proved.\n\n\n\n\n \u00a7.\u00a7 Proof of Claim <ref>\n \nWe know that e \u2208 E(C_1 \u2228 C_2) \u222a E(C_1 \u2227 C_2) iff e \u2208 E(C_1) \u222a E(C_2) (see proof in Appendix <ref>). Hence, we may only consider the edge set E(C_1) \u222a E(C_2). We prove the claim by case distinction on the containment of e in E(C_1) \u222a E(C_2). There are three cases: e \u2208 E(C_1) \u2216 E(C_2), e \u2208 E(C_2) \u2216 E(C_1), and e \u2208 E(C_1) \u222a E(C_2).\n\n    \n  Case 1: e \u2208 E(C_1) \u2216 E(C_2).\n    We know from Lemma <ref> that \u03bc_e(C_1 \u2228 C_2) \u2264\u03bc_e(C_1) and \u03bc_e(C_1 \u2227 C_2) \u2264\u03bc_e(C_1). Hence we have \u03bc_e(C_1 \u2228 C_2)2\u2264\u03bc_e(C_1)2 and \u03bc_e(C_1 \u2227 C_2)2\u2264\u03bc_e(C_1)2. Moreover, from Lemma <ref>, we know that \u03bc_e(C_1 \u2228 C_2) + \u03bc_e(C_1 \u2227 C_2) = \u03bc_e(C_1). It is clear that a2 + b2 < a + b2 for any a, b \u2208\u2115. Therefore, the claim is satisfied in this case.\n    \n  Case 2: e \u2208 E(C_2) \u2216 E(C_1).\n    This case is symmetrical to Case 1, hence is already proven.\n    \n  Case 3: e \u2208 E(C_1) \u222a E(C_2).\n    Consider the interval representation of e in E(C_1) \u222a E(C_2) (see Remark <ref> for details). There are three subcases: (3.1) I_e(C_1) and I_e(C_2) have no overlap (i.e., I_e(C_1) \u2229 I_e(C_2) = \u2205), (3.2) I_e(C_1) and I_2(C_2) overlap but neither is entirely contained in the other (i.e., I_e(C_1) \u2229 I_e(C_2) \u2260\u2205 and I_e(C_1) \u2288I_e(C_2) nor I_e(C_2) \u2288I_e(C_1)), and (3.3) one of I_e(C_1) or I_e(C_2) is entirely contained in the other (i.e., I_e(C_1) \u2286 I_e(C_2) or I_e(C_2) \u2286 I_e(C_1)). \n    \n        \n  Subcase 3.1.\n        We know by the proof of Lemma <ref> that max(\u03bc_e(C_1 \u2228 C_2), \u03bc_e(C_1 \u2227 C_2)) = max(\u03bc_e(C_1), \u03bc_e(C_2)). And by Lemma <ref>, we also have min(\u03bc_e(C_1 \u2228 C_2), \u03bc_e(C_1 \u2227 C_2)) = min(\u03bc_e(C_1), \u03bc_e(C_2)). It is then immediate that the claim is satisfied with equality in this case. \n        \n        \n  Subcase 3.2.\n        Analogous to Subcase 3.1.\n        \n        \n  Subcase 3.3.\n        It is easy to show that a2 + b2\u2264c2 + d2 for a, b, c, d \u2208\u2115, given that the following properties hold: a + b = c + d, and max(a, b) \u2264max(c, d).[By combining the two properties, we have a \u00b7 b \u2265 c \u00b7 d. Moreover, by the former property, we know that (a+b)^2 = (c+d)^2. Together, these facts imply that a^2 + b^2 \u2264 c^2 + d^2. Again by the first property, we can subtract (a+b) and (c+d) from each side, respectively, resulting in a(a-1) + b(b-1) \u2264 c(c-1) + d(d-1). Then, by definition of the binomial coefficient, the claim immediately follows.] In our context, these are the properties satisfied by the multiplicity function stated in Lemmas <ref> and <ref>. Therefore, the claim is also satisfied in this subcase.\n    \n\n\nSince we have considered all cases, we conclude that the claim holds for every edge e \u2208 E(C_2) \u222a E(C_1). And, since it holds vacuously for edges e \u2209E(C_2) \u222a E(C_1), the generalized claim follows. \n\n\n\n \u00a7.\u00a7 Proof of Claim <ref>\n \nTo prove this claim, we shall look at each edge in the graph, and inspect whether it is contained in each of the four edge sets E(C_1 \u2228 C_2), E(C_1 \u2227 C_2), E(C_1), and E(C_2). \nFor simplicity, we shall denote these sets by A, B, C, and D, respectively. \nWe begin with two simple facts. First, for any two sets X and Y, we may write |X|+|Y| = |X \u2216 Y| + |Y \u2216 X| + 2 |X \u2229 Y|. Second, any edge e \u2208 A \u222a B iff e \u2208 C \u222a D (see proof in Appendix <ref>). \nThus, for an edge e, we can restrict to analyze the following cases: e \u2208 A \u2216 B, e \u2208 B \u2216 A, and e \u2208 A \u2229 B. \n\n\n\n    \n  Case 1: e \u2208 A \u2216 B.\n    We claim that e must be contained in either C or D, but not in both. By contradiction, assume that e is contained in C \u2229 D. Then, by Lemma <ref>, we have \u03bc_e(A) = \u03bc_e(C) + \u03bc_e(D). But this implies that \u03bc_e(A) > max(\u03bc_e(C), \u03bc_e(D)), which stands in contradiction with Lemma <ref>.  \n    Therefore, every time an edge appears exclusively in A or B, it also appears exclusively in C or D (observe that the reverse is not always true). More formally, we have |C \u2216 D| + |D \u2216 C| = |A \u2216 B| + |B \u2216 A| + |X|, where X is the set of edges in C or D that could also appear in A \u2229 B. \n    \n  Case 2: e \u2208 B \u2216 A.\n    Symmetrical to Case 1. \n    \n  Case 3: e \u2208 A \u2229 B.\n    We have three subcases: (3.1) e \u2208 C \u2216 D, (3.2) e \u2208 D \u2216 C, and (3.3) e \u2208 C \u2229 D. \n    \n        \n  Subcases 3.1 & 3.2.\n        An observant reader may notice that these subcases are equivalent to inspecting the set X. In fact, it is enough for our purposes to show that |X| \u2265 0. To see why this holds, assume w.l.o.g. that e \u2208 C \u2216 D in the interval (i, j). Now, consider the case where D contains only cuts that each contains a path-predecessor of e in the interval (1, h) and cuts that each contains a path-successor of e in the interval (h+1, k), with i < h < j. Then, by definition of join and meet in L^*, e \u2208 A in the interval (1,h) and e \u2208 B in the interval (h+1, k). Therefore, e \u2208 A \u2229 B, which implies |X| \u2265 0.\n        \n  Subcase 3.3.\n        By a similar argument to Case 1, it follows that every edge that appears in C \u2229 D also appears in A \u2229 B. Therefore, |A \u2229 B| = |C \u2229 D| + |X|.\n    \n\n\nPutting everything together, we obtain the following:\n\n    |C| + |D|     = |C \u2216 D| + |D \u2216 C| + 2 |C \u2229 D| \n        = |A \u2216 B| + |B \u2216 A| + |X| + 2 |A \u2229 B| - 2 |X| \n        = |A| + |B| - |X|,\n\nand since |X| \u2265 0, we have that |A| + |B| \u2265 |C| + |D| and the claim is proven. \n\n\n\n\u00a7 SOLVING SUM-K-DMC AND COV-K-DMC IN O(K5N5) TIME\n \n*\n\nLet us first look at each step in the reduction to SFM. From the discussion in Section <ref>, to minimize a submodular function f in a distributive lattice L, we should first transform the problem into an equivalent version on sets. For this, we require (i) a compact representation of the lattice L, and (ii) a polynomial evaluation oracle for the function f\u0302 : \ud835\udc9f(J(L)) \u2192\u211d, which is an analogue of f on L but defined on the poset of ideals of the join-irreducibles of L. Then, any algorithm for SFM on sets can be used to solve the original problem. \n\nIn our context, the total running time of the algorithm is, \n\n\n    O(t_c(n, m) + t_SFM(n, m, T_EO)),\n\n\nwhere t_c(n, m) is the time required to construct a compact representation of the lattice L^*, t_SFM(n, m, T_EO) is the time taken by an SFM algorithm on sets, and T_EO is the time required to compute d\u0302'_sum (resp. d\u0302'_cov) by an evaluation oracle. Here d\u0302'_sum (resp. d\u0302'_cov) denotes the analog function on \ud835\udc9f(J(L^*)) of d\u0302_sum (resp. d\u0302_cov) on L^*, and n and m denote the number of vertices and edges of our input graph G. \n\nBy Lemmas <ref> and <ref>, a compact representation of L^* can be computed in time t_c(n, m) = F(n, m) + O(k^2n^2), where F(n, m) is the time required by a max-flow computation. The latter term follows from considering all potential edges between pairs of nodes in the construction of G(L^*) from the set of join-irreducibles J(L^*), which has size O(kn). \n\nNext, we analyze the time T_EO required to compute d\u0302'_sum(A); where A is the set of join-irreducibles lower than or equal to the corresponding element a \u2208 L^*. We know that the original function d\u0302_sum(a) can be efficiently computed in O(kn) time. Hence, if we can recover the element a \u2208 L^* from the ideal A \u2208\ud835\udc9f(J(L)) in t_ideal(n, m) time, we can use our familiar function d\u0302_sum to compute d\u0302'_sum in time t_ideal(n, m) + O(kn). We claim that t_ideal(n, m) = O(k^2n^2). This follows from the fact that a can be recovered from A by computing the join of all O(kn) elements in A, where a join operation between two elements in L^* has complexity O(k \u03bb(G)) = O(kn). \n\nUsing the above, and plugging into t_SFM(n, m, T_EO) the running time of the current best SFM algorithm of Jiang <cit.>, we obtain a total running time of F(n, m) + O(k^2n^2) + O(k^3 n^3 \u00b7 k^2n^2), which simplifies to O(k^5n^5). \n\n\n\n\n\u00a7 PROOFS OF SECTION <REF>\n \n\n\n \u00a7.\u00a7 Proof of Claim <ref>\n\nBy Menger's theorem, we know that a minimum s-t cut in G must contain exactly one edge from each path in \ud835\udcab_s, t(G), where |\ud835\udcab_s, t(G)| = |\u03bb(G)|. W.l.o.g., let H_s, t(G) be the augmented s-t path graph of G such that each path p \u2208\ud835\udcab_s, t(G) is also present in H_s, t(G). \nWe now show that a minimum s-t cut in G is also present in H_s, t(G). The argument in the other direction is similar and is thus omitted. \n\nConsider an arbitrary minimum s-t cut X in G. For the sake of contradiction, assume that X is not a minimum s-t cut in H_s, t(G). Then, after removing every edge of X in H_s, t(G), there is still at least one s-t path left in the graph. Such a path must contain an edge (u, v) such that u \u2264 w and w' \u2264 v, where w and w' are the tail and head nodes of two (not necessarily distinct) edges in X, respectively. By definition of H_s, t(G), there is a path from u to v in G that does not use edges in \ud835\udcab_s, t(G). But then removing the edges of X in G still leaves an s-t path in the graph. Thus X cannot be an s-t cut, and we reach our contradiction. \n\n\n\n \u00a7.\u00a7 Proof of Lemma <ref>\n\nThe idea of the algorithm is rather simple. First, we find a maximum cardinality collection \ud835\udcab_s,t(G) of edge-disjoint s-t paths in G and take their union to construct a \u201cskeleton\u201d graph H. (We call the vertices of G in \ud835\udcab_s,t(G) path vertices and vertices of G not in \ud835\udcab_s,t(G) non-path vertices.) Then, we augment H by drawing an edge between two vertices u, v \u2208 H if v is reachable from u in G by using exclusively non-path vertices. By definition, the resulting graph is an augmented s-t path graph of G.\n\nNow we look into the algorithm's implementation and analyze its running time. It is folklore knowledge that the problem of finding a maximum-sized collection \ud835\udcab_s,t(G) of edge-disjoint s-t paths in a graph with n vertices and m edges can be formulated as a maximum flow problem. Hence, the first step of the algorithm can be performed in F(m, n) time. \n\nThe second step of the algorithm could be computed in O(mn) time by means of an all-pairs reachability algorithm. Notice, however, that for a path vertex v all we require for a correct execution of Algorithm <ref> is knowledge of the rightmost vertices it can reach on each of the \u03bb(G) paths (Line 6 of Algorithm <ref>). Hence, we do not need to augment H with edges between every pair of reachable path vertices (using exclusively non-path vertices) in G, at most \u03bb(G) edges per vertex suffice. This can be achieved in O(m \u03bb(G)) time as follows.   \n\nIn the original graph, first equip each vertex u \u2208 V(G) with a set of \u03bb(G) variables R(p, u), one for each path p\u2208\ud835\udcab_s, t(G). These variables will be used to store the rightmost vertex v \u2208 p that is reachable from u. Next, consider a path p \u2208\ud835\udcab_s, t(G) represented as a sequence [v_1, v_2, \u2026, v_p] of internal vertices (i.e., with s and t removed). For each vertex v \u2208 p, in descending order, execute the following procedure : Find the set N(v) of incoming neighbors of v in G and, for each w \u2208 N(v) if R(p, w) has not been set, let R(p, w) = v and mark w as visited. \nThen, for each node w \u2208 N(v), if w is an unvisited non-path vertex, execute ; \notherwise, do nothing. Notice that, since we iterate from the rightmost vertex in p, any node u such that R(u, p) = v_i cannot change its value when executing  with j < i. In other words, each vertex only stores information about the rightmost vertex it can reach in p. Complexity-wise, every vertex v in G will be operated upon at most deg(v) times. Hence, starting from an unmarked graph, a call to  takes O(m) time. Now, we want to execute the above for each path p \u2208\ud835\udcab_s, t(G) (unmarking all vertices before the start of each iteration). This then gives us our claimed complexity of O(m \u03bb(G)). \n\nBy combining the running time of both steps of the algorithm, the claim follows. \n\n\n\n\u00a7 OTHER PROOFS\n\n\n\n \u00a7.\u00a7 Fact in Claims <ref> and <ref>\n\n\n\nFor any two C_1, C_2 \u2208 L^*, we have that e \u2208 E(C_1 \u2228 C_2) \u222a E(C_1 \u2227 C_2) iff e \u2208 E(C_1) \u222a E(C_2).\n\n\n    Assume, for the sake of contradiction, that there exists an edge e such that e \u2208 E(C_1) \u222a E(C_2) but e \u2209E(C_1 \u2228 C_2) \u222a E(C_1 \u2227 C_2). If e \u2208 E(C_1) \u222a E(C_2), then there exists at least one cut X_i \u2208 C_1 \u222a C_2 such that e \u2208 X_i. W.l.o.g., suppose that X_i \u2208 C_1, and let Y_i be the ith cut in C_2. If e \u2209S_min(X_i \u222a Y_i) then, by definition, it must be that e \u2208 S_max(X_i \u222a Y_i) and vice versa. \n    This gives us the necessary contradiction and e must also be contained in E(C_1 \u2228 C_2) \u222a E(C_1 \u2227 C_2). The other direction of the argument is similar and is thus omitted. \n\n"}