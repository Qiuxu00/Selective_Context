{"entry_id": "http://arxiv.org/abs/2303.07302v1", "published": "20230313172748", "title": "Shallower CNOT circuits on realistic quantum hardware", "authors": ["Timoth\u00e9e Goubault de Brugi\u00e8re", "Simon Martiel"], "primary_category": "quant-ph", "categories": ["quant-ph"], "text": "\n\nThe category of extensions and idempotent completion\n    [\n    March 30, 2023\n====================================================\n\n\n\n\n\nWe focus on the depth optimization of CNOT circuits on hardwares with limited connectivity. We adapt the algorithm from Kutin et al. <cit.> that implements any n-qubit CNOT circuit in depth at most 5n on a Linear Nearest Neighbour (LNN) architecture. Our proposal is a block version of Kutin et al.'s algorithm that is scalable with the number of interactions available in the hardware: the more interactions we have the less the depth. We derive better theoretical upper bounds and we provide a simple implementation of the algorithm. Overall, we achieve better depth complexity for CNOT circuits on some realistic quantum hardware like a grid or a ladder. For instance the execution of a n-qubit CNOT circuit on a grid can be done in depth 4n.\n\n\n\n\n\n\u00a7 INTRODUCTION\n\n\nQuantum decoherence is a major obstacle to the scaling of quantum computing. It is very hard to maintain the qubits isolated from the environment during a calculation and once the qubits interact with external elements the result of the current calculation is lost. The decoherence time is used to designate this limited amount of available computing time. This time is given by the hardware and adds an additional constraint at the software level and more precisely during compilation: the sequence of instructions generated by the compiler for the machine must be able to be executed in a sufficiently short time. In the quantum circuit model, this is equivalent to say that the depth of the circuit must be as low as possible.\n\nIn this article we tackle the depth optimization of a specific class of quantum operators, namely the linear reversible operators or equivalently the CNOT circuits. CNOT circuits are themselves a subclass of the so-called Clifford circuits which play a major role in many different area of quantum computation such as quantum error correction <cit.>, randomized benchmarking protocols <cit.>, quantum state distillation <cit.>. CNOT circuits are also used in other classes of quantum circuits, for instance in the synthesis of phase polynomials <cit.>. More directly, the optimization of CNOT circuits has also been useful for the optimization of more general quantum circuits like arithmetic circuits <cit.>. \n\nWe take into account some architectural constraint between the qubits. The CNOT gate is a two-qubit gate, if two qubits are not close enough in the hardware their interactions is not physically achievable and a CNOT gate between these two qubits cannot be executed. This limits the pair of qubits on which one can apply a CNOT gate and adds even more constraints to the compiler. In an ideal case, all the qubits are connected: then we talk about full connectivity or all-to-all connectivity, otherwise we talk about partial or constrained connectivity between the qubits.\n\nThe optimization of CNOT circuits have attracted a lot of attention in recent years. Two metrics are generally used to evaluate the cost of running a CNOT circuit: its size or its depth. There are also two types of connectivity: full connectivity and partial connectivity. In total, this gives four cases to be treated. If we can find recent works that optimize the size in full connectivity <cit.> and in partial connectivity <cit.>, and works that optimize the depth in full connectivity <cit.>, nothing to our knowledge has been recently proposed to optimize the depth of CNOT circuits with architectural constraints. As far as we know, only two 15-year old works proposed implementations of CNOT circuits in the specific case of a Linear Nearest Neighbour (LNN) architecture <cit.>. The main result is that n-qubit CNOT circuits can be implemented in depth at most 5n for the LNN architecture. No improvement of this result nor extensions to other architectures were proposed since.\n\nWe propose a block generalization of the algorithm proposed in <cit.>. Our algorithm works for any architecture where the qubits can be packed into groups of equal size such that the groups are arranged as a line. So for instance with groups of size 2 our algorithm can treat the case of a ladder like the architecture IBM QX5. With groups of size 4 we can deal with the grid. While not being universal for any qubit connectivity, our algorithm is versatile enough to work for realistic quantum architectures. \n\nWe show that the algorithm skeleton does not depend on a specific architecture or the group size. Our algorithm consists in a series of small problems involving boolean matrices to zero: these problems are the atoms of our algorithm and this is where the block size and the actual architecture specify the constraints with which we have to solve them. We propose several strategies to solve these problems for different problem sizes and different architectures. Overall, we show that any n-qubit CNOT circuit can be executed in depth at most 4n in the case of the ladder. For the grid, a depth of 4n is sufficient and a depth of 15n/4 is enough if we add the diagonals. \n\nThe structure of the article is a follows: in Section\u00a0<ref> we give a brief background about CNOT circuits synthesis and we give a tuned formulation of Kutin et al.'s algorithm proposed in <cit.> for the LNN architecture. Then in Section\u00a0<ref> we propose our block extension of Kutin et al.'s algorithm. We detail the general structure of the algorithm, independent of the architecture and the block size, and the subproblems we have to solve. Then in Section\u00a0<ref> we give several ways to solve these subproblems for different cases of block sizes and architectures. We conclude in Section\u00a0<ref>.\n\n\n\n\n\n\u00a7 BACKGROUND AND KUTIN ET AL.'S ALGORITHM\n \n\n\n\n \u00a7.\u00a7 Background\n\n\nThe CNOT gate is a classical reversible operator. It applies a NOT gate on a target qubit if the value of a control qubit is True. This is equivalent to writing \n\n    CNOT(x_1, x_2) = (x_1, x_1 \u2295 x_2)\n\nwhere x_1, resp. x_2, is the logical input value of the control, resp. target, qubit and \u2295 is the XOR operator. \n\nBy extension any CNOT circuit on n qubits applied to a bitstring x = (x_1, , x_n) outputs a bitstring y = (y_1, , y_n) where each y_i is a linear combination of the x_i's. In other words, \n\n    y = Ax = [ A_11 x_1 \u2295 A_12 x_2 \u2295\u2295 A_1n x_n;                               \u22ee; A_n1 x_1 \u2295 A_n2 x_2 \u2295\u2295 A_nn x_n ].\n\n\nA \u2208\ud835\udd3d_2^n \u00d7 n completely characterizes the functionality of the CNOT circuit. By reversibility of the operator, A is necessarily invertible. Given a CNOT circuit implementing an operator A, outputting a bitstring y=Ax, executing an additional CNOT gate with control i and target j will perform the operation \n\n    CNOT(y_i, y_j) = (y_i, y_i \u2295 y_j) = A'x\n\nwhere A' is given from A by adding the row i to the row j. We write A' = E_ijA where E_ij = I \u2295 e_ji and e_ji is zero everywhere expect in the entry (j,i), and we note that E_ij^-1 = E_ij.\n\nThe simulation of CNOT circuits is therefore efficient and its optimization affordable for a compiler. We just showed an equivalence between applying a CNOT gate and performing an elementary row operation on the matrix operator A. If one finds a suitable sequence of N row operations (E_i_k, j_k)_k such that \n\n    ( E_i_N,j_N\u00d7 E_i_N-1, j_N-1\u00d7\u00d7 E_i_1, j_1) A = I\n \nthen \n\n    A = \u220f_k=1^N E_i_k, j_k\n\nand one gets a direct implementation of A as a CNOT circuit by reading the different elementary row operations. Such decomposition is always possible, for instance any Gaussian elimination algorithm works.\n\nTo summarize the synthesis of a CNOT circuit is equivalent to reducing an invertible boolean matrix to the identity with the use of elementary row operations. One is interested in an efficient algorithm to do such reduction. To evaluate the efficiency of a synthesis algorithm, two metrics are used: \n\n    \n  * the number of CNOT gates in the circuit, in other words the number of row operations used,\n    \n  * the depth of the circuit. This corresponds to the number of time steps needed to execute the circuit given that two gates that act on distinct qubits can be executed simultaneously.\n\n\nMoreover, the CNOT is a two-qubit gate, and therefore requires the interactions between two qubits to be executed. This might not be always physically possible to perform such interactions due to hardware constraints. We talk about graph connectivity to encode the available interactions: the nodes are the qubits and an edge indicates that the two qubits can interact and that a CNOT gate can be executed. When the graph is complete, all qubits are connected and we have a full qubit connectivity. Otherwise, the connectivity is said to be partial. We give some examples of realistic and existing qubit connectivities in Figure\u00a0<ref>.\n\nThe first algorithm improving the Gaussian elimination algorithm was the Patel-Markov-Hayes (PMH) algorithm <cit.>. It works in the case of a full qubit connectivity and generates circuits of size O(n^2/log_2(n)) where n is the number of qubits. Then several algorithms were proposed in recent years to improve the PMH algorithm <cit.> and extensions to partial connectivities were also proposed <cit.>. \n\nFor the depth optimization, surprisingly, the first works treated directly the case of a LNN architecture <cit.>. The main result is that n-qubit CNOT circuit can be executed in depth at most 5n <cit.>. More surprisingly, to our knowledge, no other work was proposed to either improve the complexity in the LNN case or to extend it to other connectivities. For a full qubit connectivity, several algorithms were proposed in recent years <cit.>, notably the asymptotic optimum of O(n/log_2(n)) is achievable <cit.>. \n\nFor completeness and for clarity, we now detail Kutin et al.'s algorithm achieving a depth of 5n on a line. Our block extension is natural with a suitable formulation of this algorithm. \n\n\n\n\n\n\n \u00a7.\u00a7 Kutin et al.'s algorithm\n\n\nIn <cit.>, an algorithm for synthesizing any n-qubit CNOT circuit in depth at most 5n for the LNN architecture has been proposed. We propose a slightly reformulated version of this algorithm. The algorithm consists in two parts: \n\n    \n  * first, reduce the operator A to a north-west triangular operator B, i.e, such that B[i,j] = 0 if i+j > n-1 (the indices start at 0).\n    \n  * secondly, reduce B to the identity operator. \n\n\n\nIn both steps, each qubit/row of the matrix will be given a label and the algorithm will consist in sorting the labels while maintaining some invariants. When the labels are sorted, the invariants impose the expected result: in the first step A will be north-west triangular, in the second step B will be the identity operator. \n\nFirst, write \n\n    A = UPL\n\n\nwhere U is upper triangular, L is lower triangular and P is a permutation matrix. Such decomposition is always possible with a variant of the Gaussian elimination algorithm whose pseudo-code is given in Algorithm\u00a0<ref>. Let J_n be the exchange matrix of size n, write \n\n    A = UPJ_nJ_nL = U  P'  W\n\nwhere P' = PJ_n and W is a north-west triangular matrix. One can check that north-west triangular matrices are stable by left-multiplication with upper triangular matrices. \nTherefore, reducing A to a north-west triangular matrix is equivalent to reducing an upper triangular matrix with columns permuted into an upper triangular matrix. In other words we want to do \n\n    U  P' \u2192 U'\n\nfor some upper-triangular matrix U', during the first step of the algorithm and \n\n    U'W  \u2192 I\n\nduring the second step (UW being north-west triangular).\n\n\n\n  \u00a7.\u00a7.\u00a7 From upper with columns permuted to upper triangular\n\n\n\n\nGiven U and P, we label the rows of UP as the following: row i has label j if P[i,j]=1. \nThen one can check that matrix A=UP satisfies the following property that will be our invariant throughout the synthesis: \n\n  \n  \n\n35em\nInvariant n\u00b01: for each row i of A with label k, for each row j>i, A[j,k]=0.  Also, we always have A[i,k]=1.\n \n\n  \n  \n\n\n\n\nNotice that if the labels are sorted, i.e row i has label i, and the invariant holds, then the matrix is upper-triangular (i.e. P is trivial). \nFigure <ref> depicts a matrix A=UP and its labeling.\n\nLet A be the operator we manipulate during the synthesis with elementary row operations. Initially A = UP. We now show that given two adjacent qubits i, i+1, \none can always apply a linear reversible operator between the two qubits such that the two labels can be swapped while maintaining the invariant on A. \n\nFirst, note that both rows verify A[i,k] = A[i+1,k] = 0 for any label k of the rows 1  i-1. \nIt is clear that this property will remain true after any linear reversible operation between those two rows. \nThe values A[i,k], A[i+1,k] for any label k of the rows k > i+1 are arbitrary and do not participate in the truth value of the invariant. \nSo now it should be clear that to maintain the invariant we only need to focus on the 2 \u00d7 2 submatrix B = A[[i,i+1], [k,k']] where k is the label of row i and k' the label of row i+1. \nBecause of the invariant B can only have two values: \n\n    B = [ 1 1; 0 1 ] or  B = [ 1 0; 0 1 ].\n\n\nTo swap labels k and k', we have to apply a 2-qubit linear reversible operator C such that \n\n    CB = [ \u22c6 1; 1 0 ]\n\nwhere \u22c6 can be either 0 or 1. With CB of this shape, we can assign label k to row i+1 and label k' to row i while maintaining A[i,k'] = 1, A[i+1,k]=1 and A[i+1,k'] = 0. \n\nThe choice of C is simple: \n \n    \n  * if B = [ 1 1; 0 1 ] then C = E_i,i+1 works, one CNOT is sufficient, \n    \n  * if B = [ 1 0; 0 1 ] then C = E_i,i+1E_i+1,i works, and two CNOT are sufficient. \n\n\n\nTo summarize, given a matrix A with labels on the rows and that satisfies invariant n\u00b01, we have a procedure that modifies A such that we can swap the labels of two adjacent rows while maintaining the invariant. This procedure, that we call a box (to follow the terminology of <cit.>) requires at most 2 CNOT gates. Once the labels are sorted, the invariant guarantees us that A will be upper triangular. What remains to do is to propose a quantum circuit made of boxes that guarantees that the labels are sorted after its execution. We want this circuit to be the shallowest possible. What is proposed in <cit.> is a LNN sorting network, an example on 7 bits is given in Figure\u00a0<ref>. \nThe circuit, as a box-based circuit, is of depth at most n. Therefore, given that each box is of depth at most 2, the CNOT-based circuit is of depth at most 2n. \n\n\n\n\n\n\n  \u00a7.\u00a7.\u00a7 From northwest triangular to the identity\n\n\nThe principle is exactly the same than in the first step, except this time we have to reduce a north-west triangular matrix A. For this step, we use the following invariant: \n\n  \n  \n\n35em\nInvariant n\u00b02: for each row i of A with label k, for each row j, if j>i then  A[j,k]=0 ; if j < i and row j has label k' < k then A[j,k]=0.  Also, we always have U[i,k]=1.\n \n\n  \n  \n\n\n\n\n\nInitially, A is northwest triangular and we assign to row i the label n-i+1. One can check that the property is satisfied. Figure <ref> depicts such a matrix A and its labeling.\n\nGiven a pair of qubits i, i+1, we can again swap the labels with some modifications on A. Again, for the same reasons that in the first step, note that we only have to focus on the submatrix B = A[[i,i+1], [k,k']]. If k < k' then necessarily B = [ 1 0; 0 1 ] and there is nothing to be done. If k' < k then B can still have only two values: \n\n    B = [ 1 1; 0 1 ] or  B = [ 1 0; 0 1 ].\n\n\nThe difference this time compared to the first step is that we impose to apply an operator C such that \n\n    CB = [ 0 1; 1 0 ]\n\notherwise the invariant would not be preserved. So we have two possibilities for C:\n \n    \n  * if B = [ 1 1; 0 1 ] then C = E_i+1,iE_i,i+1 works, two CNOT are sufficient, \n    \n  * if B = [ 1 0; 0 1 ] then C = E_i,i+1E_i+1,iE_i,i+1 works, and three CNOT are sufficient. \n\n\nWith the same sorting network, we can sort the labels and reduce A to the identity operator. As a box-based operator, the sorting network is of depth n. But now each box can be of depth at most 3 and therefore the second step can be executed in depth at most 3n. This gives one of the main result of <cit.>:\n\n\nAny n-qubit linear reversible operator can be executed in depth at most 5n on a LNN architecture.\n\n\n\n\nSimply concatenate the two steps, the first step can be executed in depth at most 2n, the second step can be executed in depth at most 3n, hence the result. \n\n\n\n\n\n\n\u00a7 A BLOCK VERSION OF KUTIN ET AL.'S ALGORITHM\n \n\nThe main contribution of our article is a block version of Kutin et al.'s algorithm. \nFor our block version to work, we will need our target qubit topology to verify a simple structure.\n\n\nLet n be the number of qubits, we assume n is a multiple of some integer p which will be the block size. \nWe pose m=n/p the number of blocks. We write b_1 = [1,2, , p], b_2 = [p+1, p+2, , p+p], , b_m the different blocks.\nWe further assume that each block b_i induces a connected subgraph of the topology. Furthermore, the blocks are connected in line,\nmeaning that in each block b_i, i < m, there exists a qubit that is connected to a qubit in b_i+1.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \u00a7.\u00a7 Description of the algorithm\n\n\nGiven the description we made of Kutin et al.'s algorithm, the extension to a block version is straightforward. The idea is to perform Kutin et al.'s algorithm on the line of blocks. \n\n\nWe use the notation A[b_i,:] for the natural indexing of the rows (i-1)*p+1, i*p of A. Similar notations are used to index the columns as well.\n\nThe general procedure is the same as in the case of the path graph: we start from A = UPW, for an upper-triangular matrix U and a north-west triangular matrix W. \nWe label the rows of UP similarly according to P and we reduce UP to a block upper triangular matrix U'. Then we reduce U'W, a block north-west triangular matrix, to the identity. \nDuring the process we will sort the labels by block while maintaining two invariants.\n\n\n\n  \u00a7.\u00a7.\u00a7 From UP to block upper triangular\n\n\nDuring this first step, the invariant we maintain is the following: \n\n  \n  \n\n35em\nInvariant n\u00b03: for each block b_i of A with labels k=[k_1, , k_p], for each block  b_j, j>i, U[b_j,k]=0. Also, we have A[b_i,k] invertible.\n \n\n  \n  \n\n\n\n    \n    \n\nThis new invariant is illustrated in Figure\u00a0<ref>. Similarly to invariant n\u00b01, this invariant holds for any UP with U upper triangular and P a permutation matrix by giving label j to row i if P[i,j]=1. \nMoreover, if the labels are block-sorted, i.e each row of b_i has a label in b_i, then this specifies a block upper triangular matrix. \n\nGiven two adjacent blocks b_i, b_i+1 with labels k, k', we show how to assign any p-sized subset k\u201d of k\u222a k' to block b_i while maintaining the invariant. Let k\u201d' = k\u222a k' \u2216 k\u201d. Similarly to the LNN case, we only need to focus on a particular submatrix, namely a 2p \u00d7 2p matrix B = A[[b_i, b_i+1], [k, k']]. Let's write \n\n    B = [ A_1 A_3;   0 A_2 ]\n\nwhere A_1, A_2, A_3 are p \u00d7 p, by invariant n\u00b02 A_1 and A_2 are invertible, B is full rank, and the lower-left p\u00d7 p block is 0. If we want to assign labels k\u201d to block b_i we are more interested in a column-permuted version of B, namely \n\n    B[:,[k\u201d,k\u201d']] = [ B_1 B_2; B_3 B_4 ],\n \nwhere B_1, B_2, B_3, B_4 are arbitrary as long as B is full rank. If one finds a suitable linear reversible operator C such that \n\n    CB[:,[k\u201d,k\u201d']] = [ B_5 B_6;   0 B_7 ]\n \nthen one can assign labels k\u201d to block b_i. B_6 is arbitrary. CB is full rank so we have B_5 and B_7 invertible and the invariant is fully maintained. Any choice for k\u201d works but in our case we want k\u201d to be the p smallest labels among k,k' to perform a sorting. Then using an LNN sorting network on the blocks one can finally block sort the labels and transform A into a block northwest triangular matrix.\n\nNote that we do not need in fact to focus on the columns labeled by k\u201d' of B. Our goal was to show that the suitable subblocks of B are still invertible, but in practice we only need to focus on \n\n    A[[b_i, b_i+1], k\u201d] = [ A_1; A_2 ]\n \nBecause the labels k\u201d can somehow be arbitrary, we cannot conclude anything on A_1 and A_2 except that they form a matrix of rank p. Our goal is to find a C such that \n\n    CA[[b_i, b_i+1], k\u201d] = [ A_3;   0 ]\n\nwith A_3 necessarily invertible.\n\n\n\n  \u00a7.\u00a7.\u00a7 From block northwest triangular to the identity\n\n\nFor this second step, each block b_n-i+1 has initially the labels \n\n    k_i =  (i-1)\u00b7 p+1, i\u00b7 p .\n \nDuring the second step, the labels will be block sorted but labels within each block label will not be modified. \n\nThe invariant we maintain is the following: \n\n  \n  \n\n35em\nInvariant n\u00b04: for each block b_i of U with labels k_l, for each block  b_j, j>i, A[b_j,k_l]=0. For each block b_j, j < i, with label   k_h, if h < l, then A[b_j, k_l]=0. Also, we have A[b_i,k_l] invertible.\n \n\n  \n  \n\n\n\n\n\nAgain, one can check that this property is satisfied for a block north-west triangular matrix with the chosen labeling. This is illustrated in Figure\u00a0<ref>. Once the labels are block sorted, then the invariant specifies a block-diagonal matrix. \n\nGiven two adjacent blocks b_i, b_i+1 with labels k_j, k_j', j > j', we show how to swap the blocks of labels while maintaining the invariant. We focus on the 2p \u00d7 2p submatrix B = A[[b_i, b_i+1], [k_j', k_j]]. We write \n\n    B = [ A_1 A_3; A_2   0 ]\n\nwhere A_2, A_3 are invertible. We want to find a linear reversible operator C such that \n\n    CB = [ A_4   0;   0 A_5 ].\n\n\nAfter applying C the two blocks of labels can be swapped, obviously A_4 and A_5 are invertible and the invariant is preserved. Again we use an LNN sorting network on the blocks such that we eventually reduce the northwest triangular matrix into a block diagonal matrix. \n\n\n\n  \u00a7.\u00a7.\u00a7 From block diagonal to the identity\n\n\nThis final step is straightforward: we assume we can perform a direct synthesis on each block in parallel that reduces each block to the identity gate. This can be done in depth O(p), so provided the block size is a O(1) this step can be done in depth O(1).\n\n\n\n  \u00a7.\u00a7.\u00a7 Summary\n\n\nGiven an hardware composed of m blocks of p qubits laid out as a line, we have shown that we can perform Kutin et al.'s algorithm directly on the blocks. The resulting quantum circuit consists of two sorting networks made of \"block-boxes\", i.e, linear reversible operators that act on 2 adjacent blocks (2p adjacent qubits). During the first step, those block-boxes transform binary matrices of the form \n\n    [ A_1; A_2 ]\n\nto \n\n    [ A_3;   0 ]\n\nwhere A_3 is invertible, A_1 and A_2 are arbitrary. This is our Problem 1: \n\n\n\n  Input        \u2218 an integer p > 0, \n\n               \u2218 A full rank 2p \u00d7 p boolean matrix B = [ B_1; B_2 ], \n\n               \u2218 a connectivity graph G of size 2p giving the available row operations on B, \n\n    \n\n  Problem 1      Find a sequence of row operations C G-compliant such that:  \n\n                 \u2218 CB = [ B_3;   0 ].\n\n\n\nDuring the second step, the block-boxes transform binary matrices of the form \n\n    [ A_1 A_3; A_2   0 ]\n\nto \n\n    [ A_4   0;   0 A_5 ]\n\nwhere A_2, A_3, A_4 and A_5 are invertible. A_1 is arbitrary. This is our Problem 2: \n \n\n\n  Input        \u2218 an integer p > 0, \n\n               \u2218 A 2p \u00d7 2p boolean matrix B = [ B_1 B_3; B_2   0 ] with B_2 and B_3 invertible, \n\n               \u2218 a connectivity graph G of size 2p giving the available row operations on B, \n\n    \n\n  Problem 2      Find a sequence of row operations C G-compliant such that:  \n\n                 \u2218 CB = [ B_4   0;   0 B_5 ].\n\n \n\nA third step simply consists on the synthesis of linear reversible operators on p qubits. This is our Problem 3.\n\nA pseudo-code is given in Algorithm\u00a0<ref>. A detailed example on 8 qubits with blocks of size 2 and a topology of a ladder with diagonals is given in Figure\u00a0<ref>. For the moment our framework is very generic because we have not proposed algorithms to synthesize shallow block-boxes. This corresponds to the function \"ZeroBlock\" in our pseudo-code. This will be the subject of the next section. \n\nLet's now derive a general formula for the total depth. If we write d_1(p), resp. d_2(p), the maximum depth needed to perform the transformations necessary during the first step, resp. the second step, and if we note d^*(p) the maximum depth required to do the synthesis of a linear reversible operator on p qubits, then \n\n    d(n) \u2264n/p\u00d7(d_1(p) + d_2(p) ) + d^*(p).\n\n\nThe main question now is to propose algorithms for different architectures that will give interesting values for d_1, d_2, d^*. \n\n\n\n\n\n\n\n\n\n\n\n\n\u00a7 PRACTICAL IMPLEMENTATIONS FOR DIFFERENT QUBIT CONNECTIVITIES\n \n\nBefore proposing strategies, note that our two problems are unchanged after column operations. Either during Problem 1 when working on \n\n    [ A_1; A_2 ]\n\nor during Problem 2 with\n\n    [ A_1 A_3; A_2   0 ]\n\nany column operation on A_1, A_2 during Problems 1 and 2 gives another problem whose solutions are exactly the same. One can check that undoing the column operations on \n\n    [ A_3;   0 ]\n\nresp.,\n\n    [ A_4   0;   0 A_5 ]\n\nwill not modify the desired structure. \n\n\n\n\n \u00a7.\u00a7 Exhaustive search for small blocks\n\n\nFor small p, it might be interesting to try an exhaustive search in order to have the best possible bounds on the depth. The search will consist in a breadth-first search. To perform such search, we need three elements: \n\n    \n  * starting roots, these elements need depth 0 to solve Problem 1 or 2,\n    \n  * a set of all available operations of depth 1,\n    \n  * a characterization of the set of all elements we need to find.\n\n\nThe matrix at a maximum distance from the roots will give the maximum depth required to solve Problem 1 or 2.\nThe roots for Problem 1 are all matrices of the form \n\n    [ A_3;   0 ]\n\nwith A_3 invertible. Similarly for Problem 2 the roots are all matrices of the form \n\n    [ A_4   0;   0 A_5 ]\n\nwith A_4, A_5 invertible. \n\nFor Problem 1, we need to cover all full rank matrices of size 2p \u00d7 p. For Problem 2, we need to cover all matrices of the form \n\n    [ A_1 A_3; A_2   0 ]\n\nwith A_2, A_3 invertible and A_1 is arbitrary. \n\nFortunately, we can rely on the invariance of the problems by column operations to reduce the search space. With column operations, we can put our matrices in reduced column-echelon form. Such form is unique for one given matrix. This has two consequences:\n\n    \n  * first, both Problem 1 and 2 have only one root, namely \n\n    [ I_p;   0 ]\n\u00a0\nfor Problem 1 and \n\n    [ I_p   0;   0 I_p ]\n\nfor Problem 2,\n    \n  * secondly, for Problem 1 we only need to cover the set of matrices of size 2p \u00d7 p in reduced column-echelon form. For Problem 2 we will have to search through the set of matrices of the form \n    \n    [ R_1 R_2 ]\n\n    where R_1, R_2 are 2p \u00d7 p and are in reduced column-echelon form. Note that not all matrices of this form are of interest (the targeted matrices have more structure) but this is the smallest stable set in which we can do the search.\n\n\n\nThe set of available operations can be computed in the following way: \n\n    \n  * enumerate all possible matchings of the connectivity graph G,\n    \n  * each edge of a matching is a pair of qubits on which two different CNOT gates can be applied, depending on which qubit is the control and the target. For each matching do all possible combinations, i.e, if for each edge we assign a 0 or a 1 characterizing which CNOT is applied.\n\n\nThe results of this exhaustive search are given in Table\u00a0<ref>. \nFirst, note that for Problem 1 we recover the number of full rank matrices under reduced row echelon form. This is equivalent to counting the number of different p dimensional subspaces of the 2p dimensional vector space over GF(2). This is known to be the Gaussian binomial coefficient 2pp_2 (see, e.g, <cit.>). \nFor Problem 2, all target matrices can be put in the canonical form \n\n\n    [ A I; I 0 ]\n\n\nwhere A is an arbitrary p \u00d7 p boolean matrix. \nWe recover the fact that there can be 2^p^2 of them. From those maximal depth values, we deduce the complexities summarized in Table\u00a0<ref> where we explicit the depth to solve each Problem for each architecture and the total depth required for full operator synthesis. \n\nTable <ref> gives an overview of the achieved asymptotic depth complexities for the various explored architectures.\nThe main results, in our opinion, are the ones for the grid: any CNOT circuit on n qubits can be executed in depth 4n + O(1) on a grid and 15n/4 + O(1) when we add diagonal interactions. \n\n\nWe also want to emphasize that when there is a full connectivity between blocks of size 4, the total depth is 7n/4 + O(1), which is better than the 2n result given by the extension of Kutin at al.'s to the \nfull qubit connectivity <cit.>. \nThe best practical method so far synthesizes CNOT circuits in depth n + o(n) <cit.>. \nThis shows that with slightly more connectivity between the qubits than the LNN architecture we are able to significantly reduce the computational depth of CNOT circuits and have close to similar results to \nthe full connectivity case.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \u00a7.\u00a7 Combining block layouts\n\n\nEquipped with the asymptotic bounds for step 1 and 2 of our algorithm for different architectures, one can try to combine them in order to improve the overall depth bound in some case.\nWe propose two possible improvements formalized in the following propositions.\n\n\n\n    In a 2\u00d7 2L grid layout (n=4L), any n-qubits linear reversible operator can be implemented in depth at most 15n/4 + O(1).\n\n\nIn this hardware setting, one can either divide the grid in 2L blocks of size p=2 and use the \u201cWidth-2 ladder\u201d bounds, or divide the grid into L blocks of size 4 and use the \u201cGrid\u201d bounds.\nOne can combine step 1 of the grid layout (7n/4) with step 2 of the Width-2 ladder layout (2n).\nIn order to achieve this, we need to be able to turn a block north-west triangular matrix with block size 4 into a block north-west triangular matrix with block size 2.\nThis step is at most as costly as performing a full block synthesis, and can thus be bounded by d^*(4), which is constant.\nHence, the overall depth bound is of 7n/4 + 2n + O(1) = 15n/4 + O(1).\n\n\n\n\n\n\n    In a 2L\u00d7 2K grid layout (n=4LK) with 2L-2 additional connections as in Figure <ref>, any n-qubits linear reversible operator can be implemented in depth at most 15n/4 + O(1).\n\n\n\n\n    In a 2L\u00d7 2K grid layout (n=4LK) with diagonals (every other row) with 2L-2 additional connections as in Figure <ref>, any n-qubits linear reversible operator can be implemented in depth at most 7n/2 + O(1).\n\n\n\nThe proofs of those propositions are similar to the one of Proposition <ref>. \nWe use the additional connections in order to allow for a Width-2 ladder block layout to perform the second step.\n\nConsider for instance a square grid of even dimensions n=4L^2. \nIn that setting, by adding 2L-2 = o(n) connections, we can obtain an asymptotic improvements of n/4 with respect to the complexity obtained for a standard Grid and Grid + diagonals layouts.\n\n\n\n \u00a7.\u00a7 All-to-all connectivity between larger blocks\n\n\nWe now explore the more general case where we have a full connectivity between any pair of qubits in neighboring blocks and where the block size is arbitrary. In other words, in that setting, all the qubits in one block are fully connected, and all the qubits in block b_i are connected to all the qubits in block b_i+1.\nThis is an hypothesis that can become true in some hardware models where each qubit has an interaction radius: each qubit can interact with any qubit within a certain distance <cit.>. In the case of a grid, with suitable interaction radius, our hypothesis can be true and the larger the radius the larger the block size can be. \n\nWe propose two ways to solve the two problems, our method essentially relies on previous works about the synthesis of linear reversible circuits for unconstrained architecture <cit.>. \n\n\n\n  \u00a7.\u00a7.\u00a7 Problem 1\n\n\nBy assumption we are given a full rank 2p \u00d7 p binary matrix of the form \n\n    [ A_1; A_2 ].\n\nWith a CNOT circuit of depth 1 we can add suitable rows of A_2 to A_1 to make A_1 invertible. Then, we consider the matrix B = A_2A_1^-1 that we zero with the following available operations: \n\n    \n  * elementary row operations on A_2 \u2192 available row operations on B,\n    \n  * elementary row operations on A_1 \u2192 available column operations on B,\n    \n  * elementary row operations from A_1 to A_1 \u2192 flip one entry of B. \n\n\nIt is well-known that we can encode B in a bipartite graph such that any matching on B corresponds to a set of parallel row operations between A_1 and A_2. If B has at most k entries equal to 1 on each row and column, then the corresponding bipartite graph has degree k and can be decomposed as a sum of k matchings. Therefore, B can be zeroed in depth at most k. B is p \u00d7 p so we are ensured that B can be zeroed in depth at most p.\n\n Problem 1 can be solved in depth at most 1+p.\n\n\nWe can improve this result by using a technique used in <cit.>, they show that we can write \n\n    B = B' \u22951\u00b7 v_1^T \u2295 v_2 \u00b71^T\n\nwhere v_1, v_2 are two arbitrary vectors and B' has at most p/2 entries on each row and column. Therefore step 1 can be realized first by performing B \u2295 B' in depth p/2. Then \n\n    B \u2295 B' = [   1 v_2 ]\u00b7[ v_1   1 ]^T  = w_1 \u00b7 w_2^T\n\nwhere w_1, w_2 are p \u00d7 2. We can reduce in parallel both w_1 and w_2 with elementary row and column operations on B \u2295 B'. Note that only 2 different nonzero rows can be found in w_1: [1,0] and [1,1], similarly in w_2 we can only find [0,1] and [1,1]. In both cases, we can zero any duplicate in depth at most log(p): given m occurences of [1,0] for instance, we can zero m/2 of them in depth 1, and we repeat the process. We eventually have the top 2 \u00d7 2 entries of w_1 and w_2 that are nonzero: this corresponds to a 2 \u00d7 2 block in B that can be zeroed in depth at most 2. \n\n Problem 1 can be solved in depth at most 3+p/2+log(p).\n\n\n\n\n  \u00a7.\u00a7.\u00a7 Problem 2\n\n\nIn the all-to-all case, Problem 2 is very similar to Problem 1. By assumption we are given a 2p \u00d7 2p binary matrix of the form \n\n    [ A_1 A_3; A_2   0 ]\n\n\nwhere A_2 and A_3 are invertible. In depth 2 we can obtain the matrix\n\n    [       A_2         0; A_1 \u2295 A_2       A_3 ]\n\nand we have to zero A_1 \u2295 A_2 using A_2 in a similar way that we did during first step. \n\n Problem 2 can be solved in depth at most 2+p.\n\n\n Problem 2 can be solved in depth at most 4+p/2+log(p).\n\n\n\n\n  \u00a7.\u00a7.\u00a7 Third step\n\n\nFor this step we can also rely on the work already done for linear reversible circuits synthesis on unconstrained architectures <cit.>. The best method so far is a divide-and-conquer algorithm but for simplicity we use the adaptation of Kutin et al.'s algorithm to the all-to-all connectivity: any p-qubit linear reversible operator can be synthesized in depth at most 2p+6.\n\n\n\n  \u00a7.\u00a7.\u00a7 Results\n\n\n In a quantum hardware with blocks of p qubits arranged on a line and with full connectivity between any pair of consecutive blocks, any n-qubit linear reversible operator can be synthesized in depth at most (2 + 3/p)n+ 2p + 6.\n\n\n\nWe simply add the depths: \n\n    d(n) = n/p \u00d7 (1+p+2+p) + 2p+6 = 3n/p + 2n + 2p + 6.\n\n\n\n In a quantum hardware with blocks of p qubits arranged on a line and with full connectivity between any pair of blocks, any n-qubit linear reversible operator can be synthesized in depth at most (1+7/p+2log(p)/p)n + 2p + 6.\n\n\n\nWe simply add the depths: \n\n    d(n) = n/p \u00d7 (3+p/2+log(p) + 4+p/2+log(p)) + 2p+6 < n + 7n/p + 2nlog(p)/p + 2p + 6.\n\n\n\n\n\n\u00a7 CONCLUSION\n \n\nWe proposed a block generalization of Kutin et al.'s algorithm that synthesizes CNOT circuits for an LNN architecture. Our generalization needs the blocks of qubits to be arranged as a line in the hardware. Despite this prerequisite, some realistic quantum hardware can fit into our framework. We showed that the depth complexity of our algorithm essentially depends on the solving of two elementary problems involving O(p)-sized boolean matrices where p is the size of the block. We brute-forced the solution for some small blocks (p \u2264 4) and we gave an algorithm for general p when the blocks are fully connected. As a result we improved the depth complexity for useful quantum hardware such as the grid. \n\nAs a future work, it would be interesting to extend this framework to other classes of circuits: CZ circuits, Clifford circuits, phase polynomials. We could have used normal form for Clifford circuits <cit.> to propose preliminary results but we believe deeper analysis can be done. \n\n\n\n\n\u00a7 ACKNOWLEDGMENTS\n\n\nThis work has been supported by the French state through the ANR as a part of Plan France 2030, projects NISQ2LSQ (ANR-22-PETQ-0006) and EPiQ (ANR-22-PETQ-0007), as well as the ANR project SoftQPro (ANR-17-CE25-0009).\nThe authors would like to thank J\u00e9r\u00f4me Pioux for his patience: running the enumerations took a bit longer than anticipated :)\n\nabbrv\n\n\n"}